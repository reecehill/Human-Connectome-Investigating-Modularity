"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager

lgr = ...
@contextmanager
def lock_if_check_fails(check, lock_path, operation=..., blocking=..., _return_acquired=..., **kwargs): # -> Generator[tuple[Any, None] | tuple[Any, InterProcessLock | None, bool] | tuple[Any, InterProcessLock | None], Any, None]:
    """A context manager to establish a lock conditionally on result of a check

    It is intended to be used as a lock for a specific file and/or operation,
    e.g. for `annex get`ing a file or extracting an archive, so only one process
    would be performing such an operation.

    If verification of the check fails, it tries to acquire the lock, but if
    that fails on the first try, it will rerun check before proceeding to func

    checker and lock_path_prefix could be a value, or callable, or
    a tuple composing callable and its args

    Unfortunately yoh did not find any way in Python 2 to have a context manager
    which just skips the entire block if some condition is met (in Python3 there
    is ExitStack which could potentially be used).  So we would need still to
    check in the block body if the context manager return value is not None.

    Note also that the used type of the lock (fasteners.InterprocessLock) works
    only across processes and would not lock within the same (threads) process.

    Parameters
    ----------
    check: callable or (callable, args) or value
      If value (possibly after calling a callable) evaluates to True, no
      lock is acquired, and no context is executed
    lock_path: callable or (callable, args) or value
      Provides a path for the lock file, composed from that path + '.lck'
      extension
    operation: str, optional
      If provided, would be part of the locking extension
    blocking: bool, optional
      If blocking, process would be blocked until acquired and verified that it
      was acquired after it gets the lock
    _return_acquired: bool, optional
      Return also if lock was acquired.  For "private" use within DataLad (tests),
      do not rely on it in 3rd party solutions.
    **kwargs
      Passed to `.acquire` of the fasteners.InterProcessLock

    Returns
    -------
    result of check, lock[, acquired]
    """
    ...

@contextmanager
def try_lock_informatively(lock, purpose=..., timeouts=..., proceed_unlocked=...): # -> Generator[bool, Any, None]:
    """Try to acquire lock (while blocking) multiple times while logging INFO messages on failure

    Primary use case is for operations which are user-visible and thus should not lock
    indefinitely or for long period of times (so user would just Ctrl-C if no update is provided)
    without "feedback".

    Parameters
    ----------
    lock: fasteners._InterProcessLock
    purpose: str, optional
    timeouts: tuple or list, optional
    proceed_unlocked: bool, optional
    """
    ...


"""
This type stub file was generated by pyright.
"""

from pathlib import PurePosixPath
from datalad.utils import Path

lgr = ...
def local_path_representation(path: str) -> str:
    """Return an OS-specific representation of a Posix-style path

    With a posix path in the form of "a/b" this function will return "a/b" on
    Unix-like operating systems and "a\\b" on Windows-style operating systems.
    """
    ...

def local_url_path_representation(url_path: str) -> str:
    """Return an OS-specific representation of the path component in a file:-URL

    With a path component like "/c:/Windows" (i.e. from a URL that reads
    "file:///c:/Windows"), this function will return "/c:/Windows" on a
    Unix-like operating systems and "C:\\Windows" on Windows-like operating
    systems.
    """
    ...

def local_path_from_url(url: str) -> str:
    """Parse the url and extract an OS-specific local path representation"""
    ...

def is_windows_path(path): # -> bool:
    ...

def get_response_disposition_filename(s): # -> str | None:
    """Given a string s as from HTTP Content-Disposition field in the response
    return possibly present filename if any
    """
    ...

def get_url_disposition_filename(url, headers=...): # -> str | None:
    """Get filename as possibly provided by the server in Content-Disposition
    """
    ...

def get_url_straight_filename(url, strip=..., allowdir=...): # -> str | None:
    """Get file/dir name of the last path component of the URL

    Parameters
    ----------
    strip: list, optional
      If provided, listed names will not be considered and their
      parent directory will be selected
    allowdir: bool, optional
      If url points to a "directory" (ends with /), empty string
      would be returned unless allowdir is True, in which case the
      name of the directory would be returned
    """
    ...

def get_url_filename(url, headers=..., strip=...): # -> str | None:
    """Get filename from the url, first consulting server about Content-Disposition
    """
    ...

def get_url_response_stamp(url, response_info): # -> dict[str, int | None]:
    ...

def get_tld(url):
    """Return top level domain from a url

    Parameters
    ----------
    url : str
    """
    ...

def rfc2822_to_epoch(datestr): # -> int:
    """Given rfc2822 date/time format, return seconds since epoch"""
    ...

def iso8601_to_epoch(datestr): # -> int:
    """Given ISO 8601 date/time format, return in seconds since epoch

    iso8601 is used to parse properly the time zone information, which
    can't be parsed with standard datetime strptime
    """
    ...

def retry_urlopen(url, retries=...): # -> Response | None:
    ...

def is_url_quoted(url): # -> Literal[False]:
    """Return whether URL looks being already quoted
    """
    ...

def same_website(url_rec, u_rec): # -> bool:
    """Decide whether a link leads to external site

    Parameters
    ----------
    url_rec: ParseResult
      record for original url
    u_rec: ParseResult
      record for new url
    """
    ...

def dlurljoin(u_path, url): # -> str:
    ...

class SimpleURLStamper:
    """Gets a simple stamp about the URL: {url, time, size} of whatever was provided in the header
    """
    def __init__(self, mode=...) -> None:
        ...
    
    def __call__(self, url): # -> dict[str, int | None]:
        ...
    


class RI:
    """Resource Identifier - base class and a factory for URL, SSHRI, etc

    Intended to be a R/O object (i.e. no fields should be changed in-place).
    Subclasses define specific collections of fields they care about in _FIELDS
    class variable.
    The idea is that this class should help to break apart a URL, while being
    able to rebuild itself into a string representation for reuse

    `RI` could be used as factory, whenever type of the resource is unknown and
    must be guessed from the string representation.  One of the subclasses will be
    provided as output, e.g.

    >>> RI('http://example.com')
    URL(hostname='example.com', netloc='example.com', scheme='http')
    >>> RI('file://C:/Windows')
    URL(hostname='c', netloc='C:', path='/Windows', scheme='file')
    >>> RI('example.com:path')
    SSHRI(hostname='example.com', path='path')
    """
    _FIELDS = ...
    __slots__ = ...
    def __new__(cls, ri=..., **kwargs):
        """Used as a possible factory for known RI types

        Returns
        -------
        RI
           uninitialized RI object of appropriate class with _str
           set to string representation if was provided

        Raises
        ------
        ValueError
          Whenever the RI type cannot be determined.
        """
        ...
    
    def __init__(self, ri=..., **fields) -> None:
        """
        Parameters
        ----------
        ri: str, optional
          String version of a resource specific for this class.  If you would like
          a type of the resource be deduced, use RI(ri). Note that this value
          will be passed to str(), so you do not have to cast it yourself.
        **fields: dict, optional
          The values for the fields defined in _FIELDS class variable.
        """
        ...
    
    @property
    def fields(self): # -> dict[Literal['path'], Any]:
        """Returns shallow copy of fields to ease manipulations"""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    @classmethod
    def from_str(cls, ri_str): # -> Self:
        ...
    
    @property
    def localpath(self):
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __getattribute__(self, item): # -> Any:
        ...
    
    def __setattr__(self, item, value): # -> None:
        ...
    


class URL(RI):
    """Universal resource locator

    Although largely decorating urlparse.ParseResult, it
    - doesn't mandate providing all parts of the URL
    - doesn't require netloc but rather asks for separate username, password, and hostname
    """
    _FIELDS = ...
    support_unc = ...
    def as_str(self): # -> str:
        """Render URL as a string"""
        ...
    
    def to_pr(self): # -> ParseResult:
        """Convert URL to urlparse.ParseResults namedtuple"""
        ...
    
    @property
    def query_dict(self): # -> dict[Any, Any] | dict[bytes, bytes]:
        ...
    
    @property
    def fragment_dict(self): # -> dict[Any, Any] | dict[bytes, bytes]:
        ...
    
    @property
    def localpath(self): # -> str:
        ...
    


class PathRI(RI):
    """RI pointing to a (local) file/directory"""
    def as_str(self): # -> Any:
        ...
    
    @property
    def localpath(self): # -> str:
        ...
    
    @property
    def posixpath(self): # -> Any:
        ...
    


class RegexBasedURLMixin:
    """Base class for URLs which we could simple parse using regular expressions"""
    _REGEX = ...


class SSHRI(RI, RegexBasedURLMixin):
    """RI pointing to a remote location reachable via SSH"""
    _FIELDS = ...
    _REGEX = ...
    def as_str(self, escape=...): # -> str:
        ...
    


class DataLadRI(RI, RegexBasedURLMixin):
    """RI pointing to datasets within default DataLad super-dataset"""
    _FIELDS = ...
    _REGEX = ...
    def as_str(self): # -> str:
        ...
    
    def as_git_url(self): # -> str:
        """Dereference /// into original URLs which could be used by git for cloning

        Returns
        -------
        str
          URL string to reference the DataLadRI from its /// form
        """
        ...
    


class GitTransportRI(RI, RegexBasedURLMixin):
    """RI for some other RI with git transport prefix"""
    _FIELDS = ...
    _REGEX = ...
    def as_str(self): # -> str:
        ...
    


_SSH_ESCAPED_CHARACTERS = ...
def escape_ssh_path(path):
    """Escape all special characters present in the path"""
    ...

def unescape_ssh_path(path):
    """Un-escape all special characters present in the path"""
    ...

def parse_url_opts(url): # -> tuple[str, dict[Any, Any] | dict[bytes, bytes]]:
    """Given a string with url-style query, split into content before # and options as dict"""
    ...

def is_url(ri): # -> bool:
    """Returns whether argument is a resource identifier what datalad should treat as a URL

    This includes ssh "urls" which git understands.

    Parameters
    ----------
    ri : str or RI
      The resource identifier (as a string or RI) to "analyze"
    """
    ...

def is_datalad_compat_ri(ri): # -> bool:
    """Returns whether argument is a resource identifier what datalad should treat as a URL

    including its own DataLadRI
    """
    ...

def is_ssh(ri): # -> Any | bool:
    """helper to determine, whether `ri` requires an SSH connection

    Parameters
    ----------
    ri: str or RI

    Returns
    -------
    bool
    """
    ...

def get_local_file_url(fname: str, compatibility: str = ..., allow_relative_path: bool = ...) -> str:
    """Return OS specific URL pointing to a local file

    Parameters
    ----------
    fname : string
        Filename.  If not absolute, abspath is used
    compatibility : str, optional
        This parameter is only interpreted on Windows systems. If set to
        anything else than 'git', the anchor, e.g. `C:` of `fname` will be put
        into the `file-auth` part, i.e. network location, defined in RFC 8089.
        This option is mainly used to support git-annex specific encoding of
        Windows paths.
    allow_relative_path: bool, optional
        Allow `fname` to be a relative path. The path will be converted to an
        absolute path, by using the current directory as path prefix.
    """
    ...

def get_url_cache_filename(url, name=...): # -> str:
    """Return a filename where to cache online doc from a url"""
    ...

def get_cached_url_content(url, name=..., fetcher=..., maxage=...): # -> Any:
    """Loader of a document from a url, which caches loaded instance on disk

    Doesn't do anything smart about http headers etc which could provide
    information for cache/proxy servers for how long to retain etc

    TODO: theoretically it is not network specific at all -- and just a memoize
    pattern, but may be some time we would make it treat headers etc correctly.
    And ATM would support any URL we support via providers/downloaders

    Parameters
    ----------
    fetcher: callable, optional
       Function to call with url if needed to be refetched
    maxage: float, optional
       Age in days to retain valid for.  <0 - would retain forever.  If None -
       would consult the config, 0 - would force to reload
    """
    ...

def download_url(url, dest=..., overwrite=...):
    """Download a file from a URL

    Supports and honors any DataLad "downloader/provider" configuration.

    Parameters
    ----------
    url: str
      Source URL to download from.
    dest: Path-like or None
      Destination file name (file must not exist), or name of a target
      directory (must exists, and filename must be derivable from `url`).
      If None, the downloaded content will be returned as a string.
    overwrite: bool
      Force overwriting an existing destination file.

    Returns
    -------
    str
      Path of the downloaded file, or URL content if `dest` is None.

    Raises
    ------
    DownloadError
      If `dest` already exists and is a file, or if `dest` is a directory
      and no filename could be determined from `url`, or if no file was
      found at the given `url`.
    """
    ...

def local_path2url_path(local_path: str, allow_relative_path: bool = ...) -> str:
    """Convert a local path into an URL path component"""
    ...

def url_path2local_path(url_path: str | PurePosixPath) -> str | Path:
    ...

def quote_path(path: str, safe: str = ...) -> str:
    """quote the path component of a URL, takes OS specifics into account

    On Windows-like system a path-prefix consisting of a slash, a single letter,
    a colon, and a slash, i.e. '/c:/Windows', the colon will not be quoted.
    All characters after the colon will be quoted by `urllib.parse.quote`.

    On Unix-like systems the complete path component will be quoted by
    'urllib.parse.quote'.

    Parameters
    ----------
    path: str
      The path that should be quoted

    safe: str (default '/')
       Characters that should not be quoted, passed
       on to the save-parameter of `urllib.parse.quote`.

    Returns
    -------
    str
       The quoted path component
    """
    ...


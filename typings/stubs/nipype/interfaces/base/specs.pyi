"""
This type stub file was generated by pyright.
"""

from .traits_extension import traits

"""

Base I/O specifications for Nipype interfaces
.............................................

Define the API for the I/O of interfaces

"""
_float_fmt = ...
nipype_version = ...
class BaseTraitedSpec(traits.HasTraits):
    """
    Provide a few methods necessary to support nipype interface api

    The inputs attribute of interfaces call certain methods that are not
    available in traits.HasTraits. These are provided here.

    new metadata:

    * usedefault : set this to True if the default value of the trait should be
      used. Unless this is set, the attributes are set to traits.Undefined

    new attribute:

    * get_hashval : returns a tuple containing the state of the trait as a dict
      and hashvalue corresponding to dict.

    XXX Reconsider this in the long run, but it seems like the best
    solution to move forward on the refactoring.
    """
    package_version = ...
    def __init__(self, **kwargs) -> None:
        """Initialize handlers and inputs"""
        ...
    
    def items(self): # -> Generator[tuple[Unknown, Unknown], None, None]:
        """Name, trait generator for user modifiable traits"""
        ...
    
    def __repr__(self): # -> LiteralString:
        """Return a well-formatted representation of the traits"""
        ...
    
    def trait_get(self, **kwargs): # -> tuple[Unknown, ...] | dict[Unknown, Unknown] | list[Unknown] | None:
        """Returns traited class as a dict

        Augments the trait get function to return a dictionary without
        notification handles
        """
        ...
    
    get = ...
    def get_traitsfree(self, **kwargs): # -> tuple[Unknown, ...] | dict[Unknown, Unknown] | list[Unknown] | None:
        """Returns traited class as a dict

        Augments the trait get function to return a dictionary without
        any traits. The dictionary does not contain any attributes that
        were Undefined
        """
        ...
    
    def has_metadata(self, name, metadata, value=..., recursive=...): # -> bool:
        """
        Return has_metadata for the requested trait name in this
        interface
        """
        ...
    
    def get_hashval(self, hash_method=...): # -> tuple[list[Unknown], str]:
        """Return a dictionary of our items with hashes for each file.

        Searches through dictionary items and if an item is a file, it
        calculates the md5 hash of the file contents and stores the
        file name and hash value as the new key value.

        However, the overall bunch hash is calculated only on the hash
        value of a file. The path and name of the file are not used in
        the overall hash calculation.

        Returns
        -------
        list_withhash : dict
            Copy of our dictionary with the new file hashes included
            with each file.
        hashvalue : str
            The md5 hash value of the traited spec

        """
        ...
    
    @property
    def __all__(self): # -> list[Unknown]:
        ...
    
    def __getstate__(self): # -> dict[Unknown, Unknown]:
        """
        Override __getstate__ so that OutputMultiObjects are correctly pickled.

        >>> class OutputSpec(TraitedSpec):
        ...     out = OutputMultiObject(traits.List(traits.Int))
        >>> spec = OutputSpec()
        >>> spec.out = [[4]]
        >>> spec.out
        [4]

        >>> spec.__getstate__()['out']
        [[4]]

        >>> spec.__setstate__(spec.__getstate__())
        >>> spec.out
        [4]

        """
        ...
    


class TraitedSpec(BaseTraitedSpec):
    """Create a subclass with strict traits.

    This is used in 90% of the cases.
    """
    _ = traits.Disallow


class BaseInterfaceInputSpec(TraitedSpec):
    ...


class DynamicTraitedSpec(BaseTraitedSpec):
    """A subclass to handle dynamic traits

    This class is a workaround for add_traits and clone_traits not
    functioning well together.
    """
    def __deepcopy__(self, memo): # -> HasTraits:
        """
        Replace the ``__deepcopy__`` member with a traits-friendly implementation.

        A bug in ``__deepcopy__`` for ``HasTraits`` results in weird cloning behaviors.
        """
        ...
    


class CommandLineInputSpec(BaseInterfaceInputSpec):
    args = ...
    environ = ...


class StdOutCommandLineInputSpec(CommandLineInputSpec):
    out_file = ...


class MpiCommandLineInputSpec(CommandLineInputSpec):
    use_mpi = ...
    n_procs = ...


def get_filecopy_info(cls): # -> list[Unknown] | None:
    """Provides information about file inputs to copy or link to cwd.
    Necessary for pipeline operation
    """
    ...


"""
This type stub file was generated by pyright.
"""

import enum
from collections import deque
from collections.abc import Generator
from queue import Queue
from typing import IO, Optional
from .protocol import WitlessProtocol

"""
Thread based subprocess execution with stdout and stderr passed to protocol objects
"""
__docformat__ = ...
lgr = ...
STDIN_FILENO = ...
STDOUT_FILENO = ...
STDERR_FILENO = ...
class _ResultGenerator(Generator):
    """
    Generator returned by run_command if the protocol class
    is a subclass of `datalad.runner.protocol.GeneratorMixIn`
    """
    class GeneratorState(enum.Enum):
        initialized = ...
        process_running = ...
        process_exited = ...
        connection_lost = ...
        waiting_for_process = ...
        exhausted = ...
    
    
    def __init__(self, runner: ThreadedRunner, result_queue: deque) -> None:
        ...
    
    def send(self, message):
        ...
    
    def throw(self, exception_type, value=..., trace_back=...):
        ...
    


class ThreadedRunner:
    """
    A class the contains a naive implementation for concurrent sub-process
    execution. It uses `subprocess.Popen` and threads to read from stdout and
    stderr of the subprocess, and to write to stdin of the subprocess.

    All read data and timeouts are passed to a protocol instance, which can
    create the final result.
    """
    timeout_resolution = ...
    def __init__(self, cmd: str | list, protocol_class: type[WitlessProtocol], stdin: int | IO | bytes | Queue[Optional[bytes]] | None, protocol_kwargs: Optional[dict] = ..., timeout: Optional[float] = ..., exception_on_error: bool = ..., **popen_kwargs) -> None:
        """
        Parameters
        ----------
        cmd : list or str
            Command to be executed, passed to `subprocess.Popen`. If cmd
            is a str, `subprocess.Popen will be called with `shell=True`.

        protocol : WitlessProtocol class or subclass which will be
            instantiated for managing communication with the subprocess.

            If the protocol is a subclass of
            `datalad.runner.protocol.GeneratorMixIn`, this function will
            return a `Generator` which yields whatever the protocol callback
            fed into `GeneratorMixIn.send_result()`.

            If the protocol is not a subclass of
            `datalad.runner.protocol.GeneratorMixIn`, the function will return
            the result created by the protocol method `_generate_result`.

        stdin : file-like, bytes, Queue, or None
            If stdin is a file-like, it will be directly used as stdin for the
            subprocess. The caller is responsible for writing to it and closing
            it. If stdin is a bytes, it will be fed to stdin of the subprocess.
            If all data is written, stdin will be closed.
            If stdin is a Queue, all elements (bytes) put into the Queue will
            be passed to stdin until None is read from the queue. If None is
            read, stdin of the subprocess is closed.
            If stdin is None, nothing will be sent to stdin of the subprocess.
            More precisely, `subprocess.Popen` will be called with `stdin=None`.

        protocol_kwargs : dict, optional
            Passed to the protocol class constructor.

        timeout : float, optional
            If a non-`None` timeout is specified, the `timeout`-method of
            the protocol will be called if:

            - stdin-write, stdout-read, or stderr-read time out. In this case
              the file descriptor will be given as argument to the
              timeout-method. If the timeout-method return `True`, the file
              descriptor will be closed.

            - process.wait() timeout: if waiting for process completion after
              stdin, stderr, and stdout takes longer than `timeout` seconds,
              the timeout-method will be called with the argument `None`. If
              it returns `True`, the process will be terminated.

        exception_on_error : bool, optional
            This argument is only interpreted if the protocol is a subclass
            of `GeneratorMixIn`. If it is `True` (default), a
            `CommandErrorException` is raised by the generator if the
            sub process exited with a return code not equal to zero. If the
            parameter is `False`, no exception is raised. In both cases the
            return code can be read from the attribute `return_code` of
            the generator.

        popen_kwargs : dict, optional
            Passed to `subprocess.Popen`, will typically be parameters
            supported by `subprocess.Popen`. Note that `bufsize`, `stdin`,
            `stdout`, `stderr`, and `shell` will be overwritten internally.
        """
        ...
    
    def run(self) -> dict | _ResultGenerator:
        """
        Run the command as specified in __init__.

        This method is not re-entrant. Furthermore, if the protocol is a
        subclass of ``GeneratorMixIn``, and the generator has not been
        exhausted, i.e. it has not raised `StopIteration`, this method should
        not be called again. If it is called again before the generator is
        exhausted, a ``RuntimeError`` is raised. In the non-generator case, a
        second caller will be suspended until the first caller has returned.

        Returns
        -------
        Any
            If the protocol is not a subclass of ``GeneratorMixIn``, the
            result of protocol._prepare_result will be returned.

        Generator
            If the protocol is a subclass of ``GeneratorMixIn``, a Generator
            will be returned. This allows to use this method in constructs
            like::

                for protocol_output in runner.run():
                    ...

            Where the iterator yields whatever protocol.pipe_data_received
            sends into the generator.
            If all output was yielded and the process has terminated, the
            generator will raise StopIteration(return_code), where
            return_code is the return code of the process. The return code
            of the process will also be stored in the "return_code"-attribute
            of the runner. So you could write::

                gen = runner.run()
                for file_descriptor, data in gen:
                    ...

                # get the return code of the process
                result = gen.return_code

        """
        ...
    
    def process_loop(self) -> dict:
        ...
    
    def process_timeouts(self) -> bool:
        """Check for timeouts

        This method checks whether a timeout occurred since
        it was called last. If a timeout occurred, the timeout
        handler is called.

        Returns: bool
            Return `True` if at least one timeout occurred,
            `False` if no timeout occurred.
        """
        ...
    
    def should_continue(self) -> bool:
        ...
    
    def is_stalled(self) -> bool:
        ...
    
    def check_for_stall(self) -> bool:
        ...
    
    def process_queue(self): # -> None:
        """
        Get a single event from the queue or handle a timeout. This method
        might modify the set of active file numbers if a file-closed event
        is read from the output queue, or if a timeout-callback return True.
        """
        ...
    
    def remove_process(self): # -> None:
        ...
    
    def remove_file_number(self, file_number: int): # -> None:
        """
        Remove a file number from the active set and from
        the timeout set.
        """
        ...
    
    def close_stdin(self): # -> None:
        ...
    
    def ensure_stdin_stdout_stderr_closed(self): # -> None:
        ...
    
    def ensure_stdout_stderr_closed(self): # -> None:
        ...
    
    def wait_for_threads(self): # -> None:
        ...
    


def run_command(cmd: str | list, protocol: type[WitlessProtocol], stdin: int | IO | bytes | Queue[Optional[bytes]] | None, protocol_kwargs: Optional[dict] = ..., timeout: Optional[float] = ..., exception_on_error: bool = ..., **popen_kwargs) -> dict | _ResultGenerator:
    """
    Run a command in a subprocess

    this function delegates the execution to an instance of
    `ThreadedRunner`, please see `ThreadedRunner.__init__()` for a
    documentation of the parameters, and `ThreadedRunner.run()` for a
    documentation of the return values.
    """
    ...


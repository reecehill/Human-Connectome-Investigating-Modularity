%%
%  coordsIn3d = zeros(size(allFunctionalData.modules.threeDimensions),3);
%             % Create matrix where each element is a vector of coordinates.
%             coordsIn3d(sub2ind(size(coordsIn3d),xSubsection,ySubsection,zSubsection))=allFunctionalData.nodes.mni152(activeNodes);

%% INSTRUCTIONS
% Anatomical, DWI, fMRI data are used in this script.

ISO2MESH_TEMP='C:\Users\Reece\Documents\tempiso2mesh';
try
    %% Initialise.
    addpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Collections\Iso2Mesh');
    addpath(genpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Toolboxes\Brain Connectivity Toolbox'));
    addpath(genpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Collections\SurfStat'));
    close all;
    clearvars -except pathToParticipants subject roiStructuralData optimalGamma;
    pathToParticipants = 'D:\Dissertation\Participants';
    subject = 'sub-002';
    surf = struct('nodes',[],'faces',[],'edges',[],'regions',[],'holes',[]);
    modules = [struct('nodeIds',[],'activeVoxels',0,'surfaceAreas',[],'centreOfMasses',[],'shapes',{},'surf',[surf])];
    nodes = [struct('ids',[],'labels',[],'moduleIds',[],'mni152',[],'threeDimensions',[],'shape',[])];
    baseStruct.adjacencyMatrix = [];
    baseStruct.nodes = nodes;
    baseStruct.modules = modules;
    baseStruct.surf = surf;    
    tempStoreOfStrucModuleIds = [];
    if(exist("roiStructuralData",'var') && exist("optimalGamma",'var'))
        tempStoreOfStrucModuleIds = roiStructuralData.nodes.moduleIds;
        tempStoreOfOptimalGamma = optimalGamma;
    end
    allStructuralData = baseStruct;
    roiStructuralData = baseStruct;
    allFunctionalData = baseStruct;
    roiFunctionalData = baseStruct;
    allBrainData = baseStruct;
    roiBrainData = baseStruct;

    %% Parameters
    roiLabels = ["lh.precentral.label"]; % only supports single values for now.
    showTicksPer = 500;

    %% Load external parameters
    adj_matrix = matfile([pathToParticipants '\' subject '\matrices.mat']).adj_matrix;
    load([pathToParticipants '\' subject '\labelSRF.mat'],"nvl","nvr","nfl","nfr","glpfaces","glpvertex","grpfaces","grpvertex","faceROIidL","faceROIidR","subROIid","filenames","subfilenames");
    load([pathToParticipants '\' subject '\edgeList.mat'], "lpcentroids","rpcentroids");
    load([pathToParticipants '\' subject '\MNIcoor.mat'],"Coor_MNI152","Coor_MNI305");
    load([pathToParticipants '\' subject '\1stlevel\fMRIModules_0002.mat']);

    %% TODO: Automate getting transformation matrices.
    % To get tkrRAS coordinates from row,col,slice of fmri data:
    % inv(mri.hdr.tkrvox2ras)*rmmissing(Reg)*[R A S 1]'

    % where tMov is generated by:
    % mri_info --vox2ras-tkr ${SUBJECTS_DIR}/sub-002/data/func/task-HcpMotor_acq-ap_bold.nii
    tMov = [  -1.50000    0.00000    0.00000   96.00000;
        0.00000    0.00000    1.50000  -69.75000;
        0.00000   -1.50000    0.00000   96.00000;
        0.00000    0.00000    0.00000    1.00000;];

    % where REG was obtained by:
    %  tkregister2 --mov "${SUBJECTS_DIR}/sub-002/data/func/sartask-HcpMotor_acq-ap_bold.nii" --s sub-002/data/  --noedit --regheader --reg "${SUBJECTS_DIR}/sub-002/data/func/register6.dat" --targ "${SUBJECTS_DIR}/sub-002/data/bert/mri/orig.mgz"
    Reg = table2array(readtable([pathToParticipants '/' subject ,'/data/func/register6.dat']));
    %Reg = table2array(readtable([pathToParticipants '/' subject ,'/data/func/register.dat']));

    %% Convert label to label's index
    allFilenames = [filenames;transpose(subfilenames)];
    roiLabelIndexes = find(ismember(allFilenames,roiLabels));
    regionNameIds = [faceROIidL; faceROIidR+34; subROIid+34+17];
    allLabels = allFilenames(regionNameIds);

    %% All mock data: functional voxel volume to confirm transformation matrices.
    % Generate binary image with central mock block (activation zone).
    dimensionsOfMockBlock = [40,40,51]; % must be [even even odd] if scan image is [even even odd]; min = [4 4 5];
    intensitiesPerVoxel_mock = ones(dimensionsOfMockBlock);
    paddingSize = (size(intensitiesPerVoxel)-size(intensitiesPerVoxel_mock))./2;
    intensitiesPerVoxel_mock = padarray(intensitiesPerVoxel_mock,paddingSize,0,'both');
    xSubsection = 1:1:size(intensitiesPerVoxel_mock,1);
    ySubsection = 1:1:size(intensitiesPerVoxel_mock,2);
    zSubsection = 1:1:size(intensitiesPerVoxel_mock,3);
    opt.keepratio = 1;
    opt.radbound = 10;
    opt.distbound = 0.2;
    [nodes,elements,regions,holes]=vol2surf(intensitiesPerVoxel_mock,xSubsection,ySubsection,zSubsection,opt,0,'simplify',1);
    % Transform block to tkRAS coordinates.
    colOfOnes = ones(size(nodes,1),1);
    nodes = [nodes colOfOnes];
    nodes = transpose(inv(rmmissing(Reg)) * tMov * nodes'); %nodes are now represented in mm rather than indice.
    nodes(:,4) = []; %remove column of ones;

    % View slices of the mock block.
    figure;
    title('View mock block data.');
    sliceViewer(intensitiesPerVoxel_mock);
    % Plot the point cloud of mock block.
    figure;
    title('View mock block data: surface.');
    hold on;
    modulePointCloud = pointCloud(nodes);
    plotsurf(nodes,elements,'FaceColor','g');
    %pcshow(modulePointCloud,'MarkerSize',50);

    % TODO: For a scenario of mock block [4,4,5], a node is removed erroneously. Is this a problem?

    %     -----------
    %     ---
    %     -----------

    %% All Anatomical data
    allBrainData.nodes.mni152 = Coor_MNI152;
    % Left hemisphere
    allBrainData.leftHemisphere.surf.faces = nfl;
    %allBrainData.leftHemisphere.surf.faces = glpfaces;
    allBrainData.leftHemisphere.surf.nodes = nvl;
    %allBrainData.leftHemisphere.surf.nodes = glpvertex;

    % Right hemisphere
    allBrainData.rightHemisphere.surf.faces = nfr;
    %allBrainData.rightHemisphere.surf.faces = grpfaces;
    allBrainData.rightHemisphere.surf.nodes = nvr;
    %allBrainData.rightHemisphere.surf.nodes = grpvertex;

    % Both hemispheres make a whole.
    [allBrainData.surf.nodes, allBrainData.surf.faces] = mergesurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces);
    figure;
    plotmesh(allBrainData.surf.nodes, allBrainData.surf.faces);
    allBrainData.surf.faces_mni152 = Coor_MNI305;
    allBrainData.surf.edges = meshedge(allBrainData.surf.faces);


    %% ROI Anatomical data
    % Left  hemisphere
    LFaceIndexesOfRoi = find(ismember(faceROIidL, roiLabelIndexes));
    allBrainData.roi.centroids = lpcentroids(LFaceIndexesOfRoi,:);
    % Right hemisphere
    RFaceIndexesOfRoi = find(ismember(faceROIidR, roiLabelIndexes));
    allBrainData.roi.centroids = [allBrainData.roi.centroids; rpcentroids(RFaceIndexesOfRoi,:)];
    
    figure;
    hold on;
    plotsurf(allBrainData.surf.nodes,allBrainData.surf.faces,'FaceAlpha',0.5,'EdgeAlpha',0.5,'DisplayName','Both hemispheres');
    plot3(allBrainData.roi.centroids(:,1),allBrainData.roi.centroids(:,2),allBrainData.roi.centroids(:,3),'r.','DisplayName','ROI nodes');

    
    clearvars rpcentroids lpcentroids;

    %% All Structural data
    % All structure data
    allStructuralData.nodes.ids = 1:1:length(allLabels);
    allStructuralData.adjacencyMatrix = adj_matrix;
    clearvars adj_matrix;

    %% ROI Structural Data
    % Filtered structure data, of only those from ROI.
    roiStructuralData.nodes.ids = find(ismember(allLabels, roiLabels));
    roiStructuralData.nodes.mni152 = allBrainData.nodes.mni152(roiStructuralData.nodes.ids,:);
    roiStructuralData.adjacencyMatrix = allStructuralData.adjacencyMatrix(roiStructuralData.nodes.ids,roiStructuralData.nodes.ids);
    roiStructuralData.nodes.labels = allLabels(roiStructuralData.nodes.ids);
    if(~isempty(tempStoreOfStrucModuleIds))
        roiStructuralData.nodes.moduleIds = tempStoreOfStrucModuleIds;
        optimalGamma = tempStoreOfOptimalGamma;
    else
        disp('Sorting DWI data into modules...');
        [roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, 0.78, 0.78);
        %[roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, -0.02, 0);
    end

    xSubsection = 1:1:256;
    ySubsection = 1:1:256;
    zSubsection = 1:1:256;
    volumeOfAVoxel = 1*1*1; % in mm (taken from scanner).
    opt.radbound = 1;
    opt.distbound = 1;
    opt.keepratio = 0.1;
    % Loop through structural modules to fill data, and plot resulting surface.
    figure(4);
    hold on;;
    title('Structural modules surfaces');

    % Copy brain surface so that modules can be indicated.
    roiStructuralData.leftHemisphere.surf.faces = allBrainData.leftHemisphere.surf.faces;
    roiStructuralData.leftHemisphere.surf.nodes = allBrainData.leftHemisphere.surf.nodes;
    roiStructuralData.rightHemisphere.surf.faces = allBrainData.rightHemisphere.surf.faces;
    roiStructuralData.rightHemisphere.surf.nodes = allBrainData.rightHemisphere.surf.nodes;
    

    for moduleIndex=1:max(roiStructuralData.nodes.moduleIds)
        % Get node IDs related to this module
        roiStructuralData.modules(moduleIndex).nodeIds =  roiStructuralData.nodes.ids(find(roiStructuralData.nodes.moduleIds == moduleIndex));
        % Split them into L and R so we can use the face indexes.
        leftNodeIds = roiStructuralData.modules(moduleIndex).nodeIds(roiStructuralData.modules(moduleIndex).nodeIds <= 30606);
        rightNodeIds = roiStructuralData.modules(moduleIndex).nodeIds(roiStructuralData.modules(moduleIndex).nodeIds > 30606);

        % Change face color (4th column) of the elements associated with this module: https://github.com/fangq/iso2mesh/blob/master/plotsurf.m
        roiStructuralData.leftHemisphere.surf.faces(leftNodeIds, 4) = moduleIndex;
        roiStructuralData.rightHemisphere.surf.faces(rightNodeIds, 4) = moduleIndex;

    end
    figure;
    hold on;
    plotsurf(roiStructuralData.leftHemisphere.surf.nodes,roiStructuralData.leftHemisphere.surf.faces);
    plotsurf(roiStructuralData.rightHemisphere.surf.nodes,roiStructuralData.rightHemisphere.surf.faces);
    clearvars tempStoreOfOptimalGamma tempStoreOfStrucModuleIds;

   
    %% All fMRI data
    % Note: the nodes of the fMRI are NOT in the same space, so we cannot
    % just reassign a colour as seen for structural.
    allFunctionalData.nodes.mni152 = funcXyzCoordinatesmm;
    allFunctionalData.nodes.moduleIds = fmriModules(:); % for each node, list its module id.
    %allFunctionalData.nodes.threeDimensions = intensitiesPerVoxel; 
    xSubsection = 1:1:size(fmriModules,1);
    ySubsection = 1:1:size(fmriModules,2);
    zSubsection = 1:1:size(fmriModules,3);
    opt.keepratio = 1;
    opt.radbound = 10;
    opt.distbound = 0.2;

    %% As a test, mesh the entire fMRI volume as a whole first.
    [allFunctionalData.surf.nodes,allFunctionalData.surf.faces,allFunctionalData.surf.regions,allFunctionalData.surf.holes]= ...
            vol2surf(fmriModules,xSubsection,ySubsection,zSubsection,opt,0,'simplify',1);
    % Transform allFmriNodes CRS (column-row-slice) coordinates to tkRAS coordinates: https://surfer.nmr.mgh.harvard.edu/fswiki/CoordinateSystems.
    colOfOnes = ones(size(allFunctionalData.surf.nodes,1),1);
    allFunctionalData.surf.nodes = [allFunctionalData.surf.nodes colOfOnes];
    allFunctionalData.surf.nodes = transpose(inv(rmmissing(Reg)) * tMov * allFunctionalData.surf.nodes'); %allFmriNodes are now represented in mm rather than indice.
    allFunctionalData.surf.nodes(:,4) = []; %remove column of ones;

    %% Now, mesh individual fMRI modules.
    figure(7);
    for moduleIndex=1:1:max(fmriModules,[],'all')
        % Get nodeIds that belong to current module (starting from 1, not
        % 0).
        allFunctionalData.modules(moduleIndex).nodeIds = find(allFunctionalData.nodes.moduleIds == moduleIndex); % the ids of all nodes with a module.

        % Build a binary volume for this module.
        % The threeDimensions variable is a MxNxP matrix of modules, its
        % not binary.
        allFunctionalData.modules(moduleIndex).volume = fmriModules==moduleIndex;
        
        % View slice of each fMRI module.
        figure;
        title(['fMRI Module: ' num2str(moduleIndex)]);
        subtitle("Note that this is pre-transformation into tkRAS coordinates.");
        sliceViewer(allFunctionalData.modules(moduleIndex).volume);


        [allFunctionalData.modules(moduleIndex).surf.nodes,allFunctionalData.modules(moduleIndex).surf.faces,allFunctionalData.modules(moduleIndex).surf.regions,allFunctionalData.modules(moduleIndex).surf.holes]= ...
            vol2surf(allFunctionalData.modules(moduleIndex).volume,xSubsection,ySubsection,zSubsection,opt,0,'simplify',1);
        
        % Transform fMRI coordinates into tkRAS coordinates (in aparc+aseg space).
        % As the surface works on CRS (column-row-slice) indices,
        % we transform each surface independently.
        colOfOnes = ones(size(allFunctionalData.modules(moduleIndex).surf.nodes,1),1);
        allFunctionalData.modules(moduleIndex).surf.nodes = [allFunctionalData.modules(moduleIndex).surf.nodes colOfOnes];
        allFunctionalData.modules(moduleIndex).surf.nodes = transpose(inv(rmmissing(Reg)) * tMov * allFunctionalData.modules(moduleIndex).surf.nodes'); %nodes are now represented in mm rather than indice.
        allFunctionalData.modules(moduleIndex).surf.nodes(:,4) = moduleIndex; %remove column of ones, replace with moduleIndex for colouring.;

        % For the whole-fMRI mesh, change colour of module.
        %allFunctionalData.surf.faces(allFunctionalData.modules(moduleIndex).nodeIds,4) = moduleIndex;
        
        % View generated surface for each fMRI module.
        figure(7);
        hold on;
        plotsurf(allFunctionalData.modules(moduleIndex).surf.nodes,allFunctionalData.modules(moduleIndex).surf.faces);
    end
    figure(7);
    hold on;
    plotsurf(allBrainData.surf.nodes,allBrainData.surf.faces,'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');

    % Draw whole module for comparison.
    figure(70);
    hold on;
    title("fMRI modules when meshed as a whole.")
    plotsurf(allBrainData.surf.nodes,allBrainData.surf.faces,'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');
    plotsurf(allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
    clearvars fmriModules intensitiesPerVoxel xyzCoordinatesmm colOfOnes;

    

    %% COARSE PLOTTING
    figure;
    title('Entire brain surface with nodes of ROI')
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,'FaceAlpha',0.5,'EdgeAlpha',0.5,'DisplayName','Left hemisphere');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces,'FaceAlpha',0.5,'EdgeAlpha',0.5,'DisplayName','Right hemisphere');
    plot3(allBrainData.roi.centroids(:,1),allBrainData.roi.centroids(:,2),allBrainData.roi.centroids(:,3),'r.','DisplayName','ROI nodes');


    % Find overlapping regions.
    [LoverlappingNodes,LoverlappingFaces]=surfboolean(allBrainData.surf.nodes,allBrainData.surf.faces,'and',allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
    ISO2MESH_TEMP='C:\Users\Reece\Documents\tempiso2mesh';
    [RseparateNodes,RseparateFaces] = surfboolean(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces,'diff',allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
    
    [LseparateNodes,LseparateFaces] = surfboolean(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,'diff',allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
    [RoverlappingNodes,RoverlappingFaces]=surfboolean(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces,'and',allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
    
    [~,~,matchingNodeIndexes] = intersect(LoverlappingNodes,allBrainData.surf.nodes,'rows');
    [~,~,matchingFaceIndexes] = intersect(LoverlappingFaces,allBrainData.surf.faces,'rows');
    
    %% Map fMRI activation clusters to surface.
    % Generate point cloud of fMRI nodes to find closest DWI nodes.
    pointCloudVar = pointCloud(allFunctionalData.surf.nodes);

    % Find nearest nodes to each of the fMRI points.
    nv = nodesurfnorm(allBrainData.surf.nodes,allBrainData.surf.faces(1:3));
    [distanceToSurface,closestSurfaceNodeIds] = dist2surf(allBrainData.surf.nodes,nv,pointCloudVar.Location);
    
    % Compute a table that maps node to adjacent faces
    [facesAdjacentToNodes,nodeNeighbourNumber,~]=neighborelem(allBrainData.surf.faces,length(allBrainData.surf.nodes));

    % Find face IDs that are closest to activate nodes.
    activeNodes = allBrainData.surf.nodes(closestSurfaceNodeIds);
    neighbouringFacesPerActiveNode = facesAdjacentToNodes(find(activeNodes),:);
    allNeighbouringFaces = cat(2,neighbouringFacesPerActiveNode{:});

    % Change colour of neighbouring faces.
    allBrainData.surf.faces(allNeighbouringFaces,4) = 100;

    % Plot faces on brain.
    plotsurf(allBrainData.surf.nodes,allBrainData.surf.faces,'FaceAlpha','0.5');
    plot3(allBrainData.surf.nodes(closestSurfaceNodeIds,1),allBrainData.surf.nodes(closestSurfaceNodeIds,2),allBrainData.surf.nodes(closestSurfaceNodeIds,3),'g.','MarkerSize',20);

    % Visualise overlapping regions.
    figure;
    hold on;
    title('fMRI regions on the surface.');
    %plotsurf(allBrainData.surf.nodes,allBrainData.surf.faces,'EdgeColor','none','FaceAlpha','0.05','FaceColor',[0.2 0.2 0.2]);
    %plotsurf(LoverlappingNodes,LoverlappingFaces);
    plotsurf(allBrainData.surf.nodes,allBrainData.surf.faces,'FaceAlpha',0.2,'EdgeAlpha',0.2,'FaceColor',[0.2 0.2 0.2],'DisplayName','Left hemisphere');
    plot3(allBrainData.roi.centroids(:,1),allBrainData.roi.centroids(:,2),allBrainData.roi.centroids(:,3),'r.');
    %plot3(allBrainData.surf.faces(matchingFaceIndexes,1),allBrainData.surf.faces(matchingFaceIndexes,2),allBrainData.surf.faces(matchingFaceIndexes,3),'g.')
    plot3(allBrainData.surf.nodes(closestSurfaceNodeIds,1),allBrainData.surf.nodes(closestSurfaceNodeIds,2),allBrainData.surf.nodes(closestSurfaceNodeIds,3),'g.');
    volumeOverlap = fillsurf(LoverlappingNodes,LoverlappingFaces) + fillsurf(RoverlappingNodes,RoverlappingFaces);
    
    figure;
    hold on;
    plotsurf(RoverlappingNodes,RoverlappingFaces,'FaceAlpha',0.3,'EdgeAlpha',0.3,'FaceColor','g');
    plotsurf(RseparateNodes,RseparateFaces,'FaceAlpha',0.1,'EdgeAlpha',0.3,'FaceColor',[0.2 0.2 0.2]);
    plotsurf(LoverlappingNodes,LoverlappingFaces,'FaceAlpha',0.3,'EdgeAlpha',0.3,'FaceColor','g');
    plotsurf(LseparateNodes,LseparateFaces,'FaceAlpha',0.1,'EdgeAlpha',0.3,'FaceColor',[0.2 0.2 0.2]);
    plot3(allBrainData.rightHemisphere.roi.centroids(:,1),allBrainData.rightHemisphere.roi.centroids(:,2),allBrainData.rightHemisphere.roi.centroids(:,3),'r.');
    plot3(allBrainData.leftHemisphere.roi.centroids(:,1),allBrainData.leftHemisphere.roi.centroids(:,2),allBrainData.leftHemisphere.roi.centroids(:,3),'r.');

    
    for moduleIndex=1:max(allFunctionalData.nodes.moduleIds)
        activeNodes = find(allFunctionalData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            [xSubsection,ySubsection,zSubsection] = ind2sub(size(allFunctionalData.modules.threeDimensions),activeNodes);

            %[node,elem,face]=vol2mesh(allFunctionalData.modules.threeDimensions==moduleIndex,xSubsection,ySubsection,zSubsection,2,2,1);
            opt.keepratio = 0.1;
            opt(1).maxnode = 5000;
            opt.autoregion=0;
            [no,el,regions,holes]=vol2surf(allFunctionalData.modules.threeDimensions==moduleIndex,xSubsection,ySubsection,zSubsection,opt,1,'simplify',1);
            modulePointCloud = pointCloud(no);

            figure(1);
            pcshow(modulePointCloud.Location);
            %plotsurf(node,face,'FaceColor','g','EdgeColor','k','EdgeAlpha',0.5,'FaceAlpha',0.5);
            coords = allFunctionalData.nodes.mni152(activeNodes,:);
            allFunctionalData.modules.shapes{moduleIndex} = alphaShape(coords);
            allFunctionalData.modules.surfaceAreas(moduleIndex) = surfaceArea(allFunctionalData.modules.shapes{moduleIndex});
            [~,boundaryCoordsOfShape] = boundaryFacets(allFunctionalData.modules.shapes{moduleIndex});
            allFunctionalData.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoordsOfShape);
        end
    end


    overlappingRegions = baseStruct;
    overlappingRegionIndex = 1;
    %% Find the functional modules shapes that overlap with structural modules.
    for strucShape=roiStructuralData.modules.shapes
        for funcShape=allFunctionalData.modules.shapes
            if(~isempty(funcShape{1}) && ~isempty(strucShape{1}))
                coords = inShape(strucShape{1},funcShape{1}.Points);
                overlappingCoordinates = funcShape{1}.Points(coords,:);
                if(~isempty(overlappingCoordinates))
                    % An overlapping area has been found. Build shape of
                    % the overlapping area.
                    overlappingRegions.modules.shapes{overlappingRegionIndex} = alphaShape(overlappingCoordinates);
                    [~,boundaryCoordsOfShape] = boundaryFacets(overlappingRegions.modules.shapes{overlappingRegionIndex});
                    overlappingRegions.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoordsOfShape);
                    overlappingRegions.modules.surfaceAreas(overlappingRegionIndex) = surfaceArea(overlappingRegions.modules.shapes{overlappingRegionIndex});
                    overlappingRegionIndex = overlappingRegionIndex + 1;
                end
            end
        end
    end

    figure
    plot(alphaShape(glpvertex));
    hold on;
    plot(allBrainData.modules.shape,'FaceColor','r');

    totalSurfaceAreaOfAllModules = sum(roiStructuralData.modules.surfaceAreas,'all') + sum(allFunctionalData.modules.surfaceAreas,'all');
    totalSurfaceAreaOfOverlappingRegions = sum(overlappingRegions.modules.surfaceAreas,'all');
    percentageCover = (totalSurfaceAreaOfOverlappingRegions/totalSurfaceAreaOfAllModules)*100;

    figure2 = figure;
    plottedLabels = allStructuralData.nodes.labels(1:showTicksPer:end);
    spy(adj_matrix);
    rectangle('Position',[min(roiStructuralData.nodes.ids) min(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids)], 'EdgeColor','red')
    xticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Global network - connectivity matrix')
    subtitle('Square shows local connectivity (figure 2)')

    figure(2);
    plottedLabels = roiStructuralData.nodes.labels(1:showTicksPer:end);
    spy(roiStructuralData.adjacencyMatrix);
    xticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Local network (lSF-lSP) - connectivity matrix')



    nStrucModulesToPlot = max(roiStructuralData.nodes.moduleIds,[],'all') - unique(roiStructuralData.nodes.moduleIds);
    nFuncModulesToPlot = max(allFunctionalData.nodes.moduleIds,[],'all') - unique(allFunctionalData.nodes.moduleIds);
    nThingsToPlot = length(nStrucModulesToPlot)+length(nFuncModulesToPlot);
    strucColorMap = colormap(jet(nThingsToPlot));
    funcColorMap = flipud(strucColorMap);


    figure('Name',"Shape Map");
    subtitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma) ' | % cover: ' num2str(percentageCover) '%']);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    %plot(allBrainData.nodes.shape,'FaceColor',[0.8 0.15 0.15],'FaceAlpha',0.6,'BackFaceLighting','lit','FaceLighting','gouraud','EdgeColor','none','DisplayName','Brain from mask');
    %plot(allStructuralData.modules.shape,'FaceColor',[0.1 0.8 0.1],'FaceAlpha',0.6,'EdgeColor','none','DisplayName','Brain from structural nodes','AmbientStrength',0.5,'AlignVertexCenters','on','FaceLighting','flat');
    plot(roiBrainData.modules.shape,'FaceColor',[0.1 0.8 0.8],'FaceAlpha',0.6,'EdgeColor','none','DisplayName','ROI from mask','AmbientStrength',0.5,'AlignVertexCenters','on','FaceLighting','flat');
    plot3(roiStructuralData.modules.centreOfMasses(:,1),roiStructuralData.modules.centreOfMasses(:,2),roiStructuralData.modules.centreOfMasses(:,3),'*','MarkerSize',10,'Color','g','DisplayName','Struc COM');

    plot3(roiBrainData.modules.centreOfMasses(:,1),roiBrainData.modules.centreOfMasses(:,2),roiBrainData.modules.centreOfMasses(:,3),'*','MarkerSize',10,'Color','r','DisplayName','ROIMask COM');
    strucModule = 1;
    for shapeToPlot=roiStructuralData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            hold on;
        end
        strucModule = strucModule + 1;

    end

    funcModule = 1;
    for shapeToPlot=allFunctionalData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['fMRI Module #' num2str(funcModule)])
            hold on;
        end
        funcModule = funcModule + 1;
    end

    overlappingRegion = 1;
    for shapeToPlot=overlappingRegions.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(overlappingRegion,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['Overlap #' num2str(overlappingRegion)])
            hold on;
        end
        overlappingRegion = overlappingRegion + 1;
    end

    %% Visualise overlap
    figure(6);
    subtitle(['DWI- and fMRI-derived "modules" in MNI152 space']);
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucModules = find(roiStructuralData.nodes.moduleIds(:)==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucModules,:);
        centrePoint = mean(activeStrucModuleCoords);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            plot3(centrePoint(:,1),centrePoint(:,2),centrePoint(:,3),'*','Color','k','HandleVisibility','off');
        end
        %plot3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'^','DisplayName',['DWI
        %Module #' num2str(strucModule)]);
        hold on;
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no
        % activation).
        if(funcModule>0)
            roiFunctionalData.modules.byId = find(allFunctionalData.nodes.moduleIds(:)==funcModule);
            activeFmriModuleCoords = allFunctionalData.nodes.mni152(roiFunctionalData.modules.byId,:);
            plot3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','Color',funcColorMap(funcModule,:),'DisplayName',['fMRI Module #' num2str(funcModule)]);
            hold on;
        end
    end


    figure(7);
    %suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on; legend on;
    %circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    %roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1).* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4,.4, .4]);
    boundaryOfBrain = boundary(allStructuralData.nodes.mni152,1);
    trisurf(boundaryOfBrain,allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),'FaceColor',[0.1,0.1,0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area') %hold on;
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            %surf(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',cmap(strucModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation).
        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);

        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end



    figure(8);
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]); subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on;
    legend on;
    circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1) .* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4, .4, .4]);
    plot(allStructuralData.modules.shape,'FaceColor',[0.1 0.1 0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    %boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area')
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        activeStrucModuleShape = alphaShape(activeStrucModuleCoords);
        activeStrucModuleCentre = mean(activeStrucModuleCoords);
        activeStrucModuleSurfaceArea = surfaceArea(activeStrucModuleShape);

        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(activeStrucModuleShape))
            plot(activeStrucModuleShape,'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation). if(funcModule>0)

        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);
        activeFuncModuleShape = alphaShape(activeFmriModuleCoords);
        if(~isempty(boundaryOfModule))
            plot(activeFuncModuleShape,'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end


    %% Visualise strucModules
    %     figure1 = figure;
    %     hold on;
    %     moduleIndex = min(roiStructuralData.nodes.moduleIds); % For each module
    %     cmap = hsv(length(roiStructuralData.nodes.moduleIds));
    %     for i = transpose(roiStructuralData.nodes.moduleIds)
    %         % Get ids of nodes that are in this module.
    %         nodeIds = find(roiStructuralData.nodes.moduleIds == i);
    %         nodesByModule = zeros(size(roiStructuralData.adjacencyMatrix));
    %
    %         nodesByModule(nodeIds, nodeIds) = 1;
    %         spy(nodesByModule);
    %         x=get(gca,'children');
    %         lastX = length(x);
    %         color = [cmap(lastX,:)];
    %         set(x(lastX),'color',color);
    %     end
    sound(sin(1:1000)); pause(0.2); sound(sin(1:1000));

        %% COARSE PLOTTING
    figure;
    title('Entire brain surface with nodes of ROI')
    plotsurf(allBrainData.leftHemisphere.nodes,allBrainData.leftHemisphere.faces,'FaceAlpha',0.5,'EdgeAlpha',0.5,'DisplayName','Left hemisphere');
    plotsurf(allBrainData.rightHemisphere.nodes,allBrainData.rightHemisphere.faces,'FaceAlpha',0.5,'EdgeAlpha',0.5,'DisplayName','Right hemisphere');
    plot3(allBrainData.leftHemisphere.roi.centroids(:,1),allBrainData.leftHemisphere.roi.centroids(:,2),allBrainData.leftHemisphere.roi.centroids(:,3),'r.','DisplayName','ROI nodes');
    plot3(allBrainData.rightHemisphere.roi.centroids(:,1),allBrainData.rightHemisphere.roi.centroids(:,2),allBrainData.rightHemisphere.roi.centroids(:,3),'r.','DisplayName','ROI nodes');


    figure;
    [LoverlappingNodes,LoverlappingFaces]=surfboolean(allBrainData.leftHemisphere.nodes,allBrainData.leftHemisphere.elements,'and',no,el);
    [LseparateNodes,LseparateFaces] = surfboolean(allBrainData.leftHemisphere.nodes,allBrainData.leftHemisphere.elements,'diff',no,el);
    [RoverlappingNodes,RoverlappingFaces]=surfboolean(allBrainData.rightHemisphere.nodes,allBrainData.rightHemisphere.elements,'and',no,el);
    [RseparateNodes,RseparateFaces] = surfboolean(allBrainData.rightHemisphere.nodes,allBrainData.rightHemisphere.elements,'diff',no,el);
    figure;
    hold on;
    plotsurf(RoverlappingNodes,RoverlappingFaces,'FaceAlpha',0.3,'EdgeAlpha',0.3,'FaceColor','g');
    plotsurf(RseparateNodes,RseparateFaces,'FaceAlpha',0.1,'EdgeAlpha',0.3,'FaceColor',[0.2 0.2 0.2]);
    plotsurf(LoverlappingNodes,LoverlappingFaces,'FaceAlpha',0.3,'EdgeAlpha',0.3,'FaceColor','g');
    plotsurf(LseparateNodes,LseparateFaces,'FaceAlpha',0.1,'EdgeAlpha',0.3,'FaceColor',[0.2 0.2 0.2]);
    plot3(allBrainData.rightHemisphere.roi.centroids(:,1),allBrainData.rightHemisphere.roi.centroids(:,2),allBrainData.rightHemisphere.roi.centroids(:,3),'r.');
    plot3(allBrainData.leftHemisphere.roi.centroids(:,1),allBrainData.leftHemisphere.roi.centroids(:,2),allBrainData.leftHemisphere.roi.centroids(:,3),'r.');


catch ME
    sound(tan(1:1000)); pause(0.2); sound(tan(1:1000));
    rethrow(ME);
end

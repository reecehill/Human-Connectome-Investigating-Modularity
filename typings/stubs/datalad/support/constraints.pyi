"""
This type stub file was generated by pyright.
"""

"""Helper for parameter validation, documentation and conversion"""
__docformat__ = ...
class Constraint:
    """Base class for input value conversion/validation.

    These classes are also meant to be able to generate appropriate
    documentation on an appropriate parameter value.
    """
    def __repr__(self):
        """Rudimentary repr to avoid default scary to the user Python repr"""
        ...
    
    def __and__(self, other): # -> Constraints:
        ...
    
    def __or__(self, other): # -> AltConstraints:
        ...
    
    def __call__(self, value):
        ...
    
    def long_description(self):
        ...
    
    def short_description(self):
        ...
    


class EnsureDType(Constraint):
    """Ensure that an input (or several inputs) are of a particular data type.
    """
    def __init__(self, dtype) -> None:
        """
        Parameters
        ----------
        dtype : functor
        """
        ...
    
    def __call__(self, value): # -> list[Unknown]:
        ...
    
    def short_description(self): # -> LiteralString | str:
        ...
    
    def long_description(self): # -> LiteralString | str:
        ...
    


class EnsureInt(EnsureDType):
    """Ensure that an input (or several inputs) are of a data type 'int'.
    """
    def __init__(self) -> None:
        """Initializes EnsureDType with int"""
        ...
    


class EnsureFloat(EnsureDType):
    """Ensure that an input (or several inputs) are of a data type 'float'.
    """
    def __init__(self) -> None:
        """Initializes EnsureDType with float"""
        ...
    


class EnsureListOf(Constraint):
    """Ensure that an input is a list of a particular data type
    """
    def __init__(self, dtype) -> None:
        """
        Parameters
        ----------
        dtype : functor
        """
        ...
    
    def __call__(self, value): # -> list[Unknown]:
        ...
    
    def short_description(self): # -> LiteralString | str:
        ...
    
    def long_description(self): # -> LiteralString | str:
        ...
    


class EnsureTupleOf(Constraint):
    """Ensure that an input is a tuple of a particular data type
    """
    def __init__(self, dtype) -> None:
        """
        Parameters
        ----------
        dtype : functor
        """
        ...
    
    def __call__(self, value): # -> tuple[Unknown, ...]:
        ...
    
    def short_description(self): # -> LiteralString | str:
        ...
    
    def long_description(self): # -> LiteralString | str:
        ...
    


class EnsureBool(Constraint):
    """Ensure that an input is a bool.

    A couple of literal labels are supported, such as:
    False: '0', 'no', 'off', 'disable', 'false'
    True: '1', 'yes', 'on', 'enable', 'true'
    """
    def __call__(self, value): # -> bool:
        ...
    
    def long_description(self): # -> Literal['value must be convertible to type bool']:
        ...
    
    def short_description(self): # -> Literal['bool']:
        ...
    


class EnsureStr(Constraint):
    """Ensure an input is a string.

    No automatic conversion is attempted.
    """
    def __init__(self, min_len=...) -> None:
        """
        Parameters
        ----------
        min_len: int, optional
           Minimal length for a string.
        """
        ...
    
    def __call__(self, value): # -> bytes | str:
        ...
    
    def long_description(self): # -> Literal['value must be a string']:
        ...
    
    def short_description(self): # -> Literal['str']:
        ...
    


class EnsureNone(Constraint):
    """Ensure an input is of value `None`"""
    def __call__(self, value): # -> None:
        ...
    
    def short_description(self): # -> Literal['None']:
        ...
    
    def long_description(self): # -> Literal['value must be `None`']:
        ...
    


class EnsureCallable(Constraint):
    """Ensure an input is of value `None`"""
    def __call__(self, value):
        ...
    
    def short_description(self): # -> Literal['callable']:
        ...
    
    def long_description(self): # -> Literal['value must be a callable']:
        ...
    


class EnsureChoice(Constraint):
    """Ensure an input is element of a set of possible values"""
    def __init__(self, *values) -> None:
        """
        Parameters
        ----------
        *values
           Possible accepted values.
        """
        ...
    
    def __call__(self, value):
        ...
    
    def long_description(self): # -> str:
        ...
    
    def short_description(self): # -> str:
        ...
    


class EnsureKeyChoice(EnsureChoice):
    """Ensure value under a key in an input is in a set of possible values"""
    def __init__(self, key, values) -> None:
        """
        Parameters
        ----------
        key : str
          The to-be-tested values are looked up under the given key in
          a dict-like input object.
        values : tuple
           Possible accepted values.
        """
        ...
    
    def __call__(self, value):
        ...
    
    def long_description(self): # -> str:
        ...
    
    def short_description(self): # -> str:
        ...
    


class EnsureRange(Constraint):
    """Ensure an input is within a particular range

    No type checks are performed.
    """
    def __init__(self, min=..., max=...) -> None:
        """
        Parameters
        ----------
        min
            Minimal value to be accepted in the range
        max
            Maximal value to be accepted in the range
        """
        ...
    
    def __call__(self, value):
        ...
    
    def long_description(self): # -> str:
        ...
    
    def short_description(self): # -> None:
        ...
    


class AltConstraints(Constraint):
    """Logical OR for constraints.

    An arbitrary number of constraints can be given. They are evaluated in the
    order in which they were specified. The value returned by the first
    constraint that does not raise an exception is the global return value.

    Documentation is aggregated for all alternative constraints.
    """
    def __init__(self, *constraints) -> None:
        """
        Parameters
        ----------
        *constraints
           Alternative constraints
        """
        ...
    
    def __or__(self, other): # -> Self@AltConstraints:
        ...
    
    def __call__(self, value): # -> None:
        ...
    
    def long_description(self): # -> str:
        ...
    
    def short_description(self): # -> str:
        ...
    


class Constraints(Constraint):
    """Logical AND for constraints.

    An arbitrary number of constraints can be given. They are evaluated in the
    order in which they were specified. The return value of each constraint is
    passed an input into the next. The return value of the last constraint
    is the global return value. No intermediate exceptions are caught.

    Documentation is aggregated for all constraints.
    """
    def __init__(self, *constraints) -> None:
        """
        Parameters
        ----------
        *constraints
           Constraints all of which must be satisfied
        """
        ...
    
    def __and__(self, other): # -> Self@Constraints:
        ...
    
    def __call__(self, value): # -> None:
        ...
    
    def long_description(self): # -> str:
        ...
    
    def short_description(self): # -> str:
        ...
    


constraint_spec_map = ...
def expand_constraint_spec(spec): # -> EnsureFloat | EnsureInt | EnsureBool | EnsureStr:
    """Helper to translate literal constraint specs into functional ones

    e.g. 'float' -> EnsureFloat()
    """
    ...


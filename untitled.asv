try
    % Iterative community finetuning. W is the input connection matrix.
    close all;
    % clear workspace;
    showTicksPer = 500;

    adj_matrix = matfile('D:\Dissertation\Participants\sub-002\matrices.mat').adj_matrix;
    load('D:\Dissertation\Participants\sub-002\labelSRF.mat',"glpfaces","faceROIidL","faceROIidR","subROIid","filenames","subfilenames","glpvertex");
    %load('D:\Dissertation\Participants\sub-002\edgeList.mat');

    load('D:\Dissertation\Participants\sub-002\MNIcoor.mat',"Coor_MNI152");
    load('D:\Dissertation\Participants\sub-002\1stlevel\fMRIModules_0002.mat');

    allFilenames = [filenames;transpose(subfilenames)];
    regionNameIds = [faceROIidL; faceROIidR+34; subROIid+34+17];
    allLabels = allFilenames(regionNameIds);


    baseStruct.adjacencyMatrix = [];
    baseStruct.nodes.ids = [];
    baseStruct.nodes.labels = [];
    baseStruct.nodes.moduleIds = []; % for each node, list its module id.
    baseStruct.nodes.mni152 = []; % the 3D coord of each node.
    baseStruct.nodes.threeDimensions = []; % module ids in 3d
    baseStruct.nodes.shape = [];
    baseStruct.modules.nodeIds = []; % the ids of all nodes WITH a module.
    baseStruct.modules.surfaceAreas = [];
    baseStruct.modules.centreOfMasses = [];
    tempStoreOfStrucModuleIds = [];
    if(exist("roiStructuralData",'var'))
        tempStoreOfStrucModuleIds = roiStructuralData.nodes.moduleIds;
        tempStoreOfOptimalGamma = optimalGamma;
    end
    baseStruct.modules.shapes = {};
    allStructuralData = baseStruct;
    roiStructuralData = baseStruct;
    allFunctionalData = baseStruct;
    roiFunctionalData = baseStruct;

    %% Structural data
    % All structure data
    allStructuralData.nodes.ids = 1:1:length(allLabels);
    allStructuralData.nodes.mni152 = Coor_MNI152;
    clear Coor_MNI152;
    allStructuralData.nodes.labels = allLabels;
    %allStructuralData.nodes.threeDimensions =
    %getThreeDimensions(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3));

    % Filtered structure data, of only those from ROI.
    roiStructuralData.nodes.ids = find(ismember(allLabels, ["lh.precentral.label"]));
    roiStructuralData.adjacencyMatrix = adj_matrix(roiStructuralData.nodes.ids,roiStructuralData.nodes.ids);
    if(~isempty(tempStoreOfStrucModuleIds))
        roiStructuralData.nodes.moduleIds = tempStoreOfStrucModuleIds;
        optimalGamma = tempStoreOfOptimalGamma;
    else
        disp('Sorting structural data into modules...');
        [roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, 0.6, 1.4);
    end
    roiStructuralData.nodes.labels = allLabels(roiStructuralData.nodes.ids);
    roiStructuralData.nodes.mni152 = allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:);
    clearvars tempStoreOfOptimalGamma tempStoreOfStrucModuleIds;


    %% Functional data
    allFunctionalData.nodes.mni152 = funcXyzCoordinatesmm;
    allFunctionalData.nodes.moduleIds = fmriModules(:); % for each node, list its module id.
    allFunctionalData.nodes.threeDimensions = intensitiesPerVoxel;
    allFunctionalData.modules.threeDimensions = fmriModules; % module ids in 3d
    allFunctionalData.modules.nodeIds = find(allFunctionalData.nodes.moduleIds>0); % the ids of all nodes with a module.
    clearvars fmriModules intensitiesPerVoxel xyzCoordinatesmm;

    % Filtered functional data, on only those from ROI. TO DO: filter
    % functional data to get only specific areas.


    %% Build shapes from coordinates.
    allStructuralData.nodes.shape = alphaShape(allStructuralData.nodes.mni152);
    roiStructuralData.nodes.shape = alphaShape(roiStructuralData.nodes.mni152);
    for moduleIndex=1:max(roiStructuralData.nodes.moduleIds)
        activeNodes = find(roiStructuralData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            coords = roiStructuralData.nodes.mni152(activeNodes,:);
            roiStructuralData.modules.shapes{moduleIndex} = alphaShape(coords);
            roiStructuralData.modules.surfaceAreas(moduleIndex) = surfaceArea(roiStructuralData.modules.shapes{moduleIndex});
            boundaryPointsIndexes = boundaryFacets(roiStructuralData.modules.shapes{moduleIndex});
            boundaryCoords = coords(boundaryPointsIndexes);
            roiStructuralData.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoords);
        else
            disp("Not draeing...")
        end
    end

    for moduleIndex=1:max(allFunctionalData.nodes.moduleIds)
        activeNodes = find(allFunctionalData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            coords = allFunctionalData.nodes.mni152(activeNodes,:);
            allFunctionalData.modules.shapes{moduleIndex} = alphaShape(coords);
            allFunctionalData.modules.surfaceAreas(moduleIndex) = surfaceArea(allFunctionalData.modules.shapes{moduleIndex});
            boundaryPointsIndexes = boundaryFacets(allFunctionalData.modules.shapes{moduleIndex});
            boundaryCoords = coords(boundaryPointsIndexes);
            allFunctionalData.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoords);
        end
    end

    overlappingRegions = baseStruct;
    overlappingRegionIndex = 1;
    %% Find the functional modules shapes that overlap with structural modules.
    for strucShape=roiStructuralData.modules.shapes
        for funcShape=allFunctionalData.modules.shapes
            if(~isempty(funcShape{1}) && ~isempty(strucShape{1}))
                coords = inShape(strucShape{1},funcShape{1}.Points);
                overlappingCoordinates = funcShape{1}.Points(coords,:);
                if(~isempty(overlappingCoordinates))
                    % An overlapping area has been found. Build shape of
                    % the overlapping area.
                    overlappingRegions.modules.shapes{overlappingRegionIndex} = alphaShape(overlappingCoordinates);
                    overlappingRegions.modules.centreOfMasses(overlappingRegionIndex,:) = mean(overlappingCoordinates);
                    overlappingRegions.modules.surfaceAreas(overlappingRegionIndex) = surfaceArea(overlappingRegions.modules.shapes{overlappingRegionIndex});
                    overlappingRegionIndex =+ 1;
                end
            end
        end
    end


    figure2 = figure;
    plottedLabels = allStructuralData.nodes.labels(1:showTicksPer:end);
    spy(adj_matrix);
    rectangle('Position',[min(roiStructuralData.nodes.ids) min(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids)], 'EdgeColor','red')
    xticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Global network - connectivity matrix')
    subtitle('Square shows local connectivity (figure 2)')

    figure(2);
    plottedLabels = roiStructuralData.nodes.labels(1:showTicksPer:end);
    spy(roiStructuralData.adjacencyMatrix);
    xticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Local network (lSF-lSP) - connectivity matrix')



    nStrucModulesToPlot = max(roiStructuralData.nodes.moduleIds,[],'all') - unique(roiStructuralData.nodes.moduleIds);
    nFuncModulesToPlot = max(allFunctionalData.nodes.moduleIds,[],'all') - unique(allFunctionalData.nodes.moduleIds);
    nThingsToPlot = length(nStrucModulesToPlot)+length(nFuncModulesToPlot);
    strucColorMap = colormap(jet(nThingsToPlot));
    funcColorMap = flipud(strucColorMap);


    figure('Name',"Shape Map");
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;
    plot(brainShape,'FaceColor',[0.1 0.1 0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain');
    strucModule = 1;
    for shapeToPlot=roiStructuralData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            hold on;
        end
        strucModule = strucModule + 1;

    end

    funcModule = 1;
    for shapeToPlot=allFunctionalData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['fMRI Module #' num2str(funcModule)])
            hold on;
        end
        funcModule = funcModule + 1;
    end

    overlappingRegion = 1;
    for shapeToPlot=overlappingRegions.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(overlappingRegion,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['Overlap #' num2str(overlappingRegion)])
            hold on;
        end
        overlappingRegion = overlappingRegion + 1;
    end

    %% Visualise overlap
    figure(6);
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucModules = find(roiStructuralData.nodes.moduleIds(:)==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucModules,:);
        centrePoint = mean(activeStrucModuleCoords);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            plot3(centrePoint(:,1),centrePoint(:,2),centrePoint(:,3),'*','Color','k','HandleVisibility','off');
        end
        %plot3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'^','DisplayName',['DWI
        %Module #' num2str(strucModule)]);
        hold on;
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no
        % activation).
        if(funcModule>0)
            roiFunctionalData.modules.byId = find(allFunctionalData.nodes.moduleIds(:)==funcModule);
            activeFmriModuleCoords = allFunctionalData.nodes.mni152(roiFunctionalData.modules.byId,:);
            plot3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','Color',funcColorMap(funcModule,:),'DisplayName',['fMRI Module #' num2str(funcModule)]);
            hold on;
        end
    end


    figure(7);
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on; legend on;
    %circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    %roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1).* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4,.4, .4]);
    boundaryOfBrain = boundary(allStructuralData.nodes.mni152,1);
    trisurf(boundaryOfBrain,allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),'FaceColor',[0.1,0.1,0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area') %hold on;
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            %surf(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',cmap(strucModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=min(allFunctionalData.nodes.moduleIds,[],'all'):max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation). if(funcModule>0)

        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);

        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end



    figure(8);
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]); subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on;
    legend on;
    circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1) .* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4, .4, .4]);
    brainShape = alphaShape(allStructuralData.nodes.mni152);
    plot(brainShape,'FaceColor',[0.1 0.1 0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    %boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area')
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=roiStructuralData.nodes.moduleIds
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        activeStrucModuleShape = alphaShape(activeStrucModuleCoords);
        activeStrucModuleCentre = mean(activeStrucModuleCoords);
        activeStrucModuleSurfaceArea = surfaceArea(activeStrucModuleShape);

        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(activeStrucModuleShape))
            plot(activeStrucModuleShape,'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=min(allFunctionalData.nodes.moduleIds,[],'all'):max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation). if(funcModule>0)

        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);
        activeFuncModuleShape = alphaShape(activeFmriModuleCoords);
        if(~isempty(boundaryOfModule))
            plot(activeFuncModuleShape,'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end


    %% Visualise strucModules
    figure1 = figure;
    hold on;
    moduleIndex = min(strucModules); % For each module
    cmap = hsv(length(strucModules));
    for i = transpose(strucModules)
        % Get ids of nodes that are in this module.
        nodeIds = find(strucModules == i);
        nodesByModule = zeros(size(roiStructuralData.adjacencyMatrix));

        nodesByModule(nodeIds, nodeIds) = 1;
        spy(nodesByModule);
        x=get(gca,'children');
        lastX = length(x);
        color = [cmap(lastX,:)];
        set(x(lastX),'color',color);
    end
    sound(sin(1:1000)); pause(0.2); sound(sin(1:1000));
catch ME
    sound(tan(1:1000)); pause(0.2); sound(tan(1:1000));
    rethrow(ME);
end

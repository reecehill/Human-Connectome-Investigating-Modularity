"""
This type stub file was generated by pyright.
"""

from typing import TypeVar

"""Interface utility functions

"""
__docformat__ = ...
anInterface = TypeVar('anInterface', bound='Interface')
lgr = ...
def handle_dirty_dataset(ds, mode, msg=...): # -> None:
    """Detect and treat unsaved changes as instructed by `mode`

    Parameters
    ----------
    ds : Dataset or None
      Dataset to be inspected. Does nothing if `None`.
    mode : {'fail', 'ignore', 'save-before'}
      How to act upon discovering unsaved changes.
    msg : str or None
      Custom message to use for a potential commit.

    Returns
    -------
    None
    """
    ...

def get_tree_roots(paths): # -> dict[Any, Any]:
    """Return common root paths for a set of paths

    This function determines the smallest set of common root
    paths and sorts all given paths under the respective
    root.

    Returns
    -------
    dict
      paths by root
    """
    ...

def discover_dataset_trace_to_targets(basepath, targetpaths, current_trace, spec, includeds=...): # -> None:
    """Discover the edges and nodes in a dataset tree to given target paths

    Parameters
    ----------
    basepath : path
      Path to a start or top-level dataset. Really has to be a path to a
      dataset!
    targetpaths : list(path)
      Any non-zero number of paths that are termination points for the
      search algorithm. Can be paths to datasets, directories, or files
      (and any combination thereof).
    current_trace : list
      For a top-level call this should probably always be `[]`
    spec : dict
      `content_by_ds`-style dictionary that will receive information about the
      discovered datasets. Specifically, for each discovered dataset there
      will be an item with its path under the key (path) of the respective
      superdataset.
    includeds : sequence, optional
      Any paths given are treated as existing subdatasets, regardless of
      whether they can be found in the filesystem. Such subdatasets will appear
      under the key of the closest existing dataset in the `spec`.

    Returns
    -------
    None
      Function calls itself recursively and populates `spec` dict in-place.
      Keys are dataset paths, values are sets of subdataset paths
    """
    ...

def get_result_filter(fx): # -> Callable[..., Any]:
    """Wrap a filter into a helper to be able to accept additional
    arguments, if the filter doesn't support it already"""
    ...

def eval_results(wrapped): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Generator[Dict[Any, Any], None, None] | Any | list[Any] | None]:
    ...

def generic_result_renderer(res): # -> None:
    ...

default_result_renderer = ...
def render_action_summary(action_summary): # -> None:
    ...

def keep_result(res, rfilter, **kwargs): # -> bool:
    ...

def xfm_result(res, xfm):
    ...


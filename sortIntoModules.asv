function [strucModules, Q1] = sortIntoModules(structuralAdjacencyMatrix, startGamma, endGamma)
allGammas = startGamma:0.02:endGamma;
allIterations = 1:1:2;
Q_corts = zeros([max(allIterations),1]);
Q_rands = zeros([max(allIterations),1]);
Q_max = zeros([length(allGammas),1]);

%% Create random adjancency matrix.
numberOfEdgesToCreate = nnz(structuralAdjacencyMatrix); %number of non-zero elements
densityOfRandomMatrix = numberOfEdgesToCreate / numel(structuralAdjacencyMatrix);
structuralAdjacencyMatrixDims = size(structuralAdjacencyMatrix);
randomAdjacencyMatrix = sprand(structuralAdjacencyMatrixDims(1),structuralAdjacencyMatrixDims(2), densityOfRandomMatrix);


%% Trial all iterations for cortical data...
%gammaIndex = 1;
for gamma=allGammas
    gammaIndex = find(gamma == allGammas);
    figure("Name","Structural");
    strucAxes = gca;
    figure("Name","Random");
    randAxes = gca;
    parfor iterationIndex=allIterations
        disp(['Sorting cortex (ROI) into modules: gamma=' num2str(gamma) ', iteration #' num2str(iterationIndex) '/' num2str(max(allIterations))]);
        Q0 = -1; Q1 = 0;            % initialize modularity values
        plot(strucAxes,[get(strucAxes,'XData') iterationIndex],[get(strucAxes,'YData') Q1-Q0])
        while Q1-Q0>1e-5           % while modularity increases
            Q0 = Q1;                % perform community detection
            [~, Q1] = community_louvain(structuralAdjacencyMatrix, gamma);
            Q_corts(iterationIndex) = Q1;
        end
        
        disp(['Sorting cortex (Random) into modules: gamma=' num2str(gamma) ', iteration #' num2str(iterationIndex) '/' num2str(max(allIterations))]);
        Q0 = -1; Q1 = 0;            % initialize modularity values
        while Q1-Q0>1e-5           % while modularity increases
            Q0 = Q1;                % perform community detection
            [~, Q_rands(iterationIndex)] = community_louvain(randomAdjacencyMatrix, gamma);
        end
    end

    Q_corts_mean = mean(Q_corts);
    Q_rand_mean = mean(Q_rands);
    Q_max(gammaIndex) = Q_corts_mean - Q_rand_mean;
    %gammaIndex =+ 1;
end

function [modules,Q1] = runLouvainAlgorithm(adjacencyMatrix, gamma)
    disp('Running louvain algorithm...')
    %% attempt module detection
    % Iterative community finetuning.
    % W is the input connection matrix.
    %n  = size(adjacencyMatrix,1);             % number of nodes
    %M  = 1:n;                   % initial community affiliations
    Q0 = -1; Q1 = 0;            % initialize modularity values
    while Q1-Q0>1e-5           % while modularity increases
        Q0 = Q1;                % perform community detection
        [modules, Q1] = community_louvain(adjacencyMatrix, gamma);
    end
end

%% Redo the value for gamma that returned the largest modularity
optimalGamma = find(Q_max == max(Q_max));
[strucModules,Q1] = runLouvainAlgorithm(structuralAdjacencyMatrix,optimalGamma);

end
function [trkEP_full,trk_len_full,trk_type_full]=conversion_mni(pathToFile, type, nTrackIterations)
%% This script takes MNINonLinear coordinates and images only.

% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS

% load tt file generated by dsi studio
close all;
restoredefaultpath;
gcp;
addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));
addpath('toolboxes/FieldTrip');
ft_defaults;
ft_hastoolbox('gifti',1);
ft_hastoolbox('iso2mesh',1);
ft_hastoolbox('freesurfer',1);
disp('step1: performing conversion from .trk to surface and atlas')
disp(['Type: ' num2str(type) ' (' class(type) ')'])

atlas_mni = ft_read_mri([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);
atlasMniDim = atlas_mni.dim;
disp("It's important to confirm the labels used in your atlas file" + ...
            " (e.g., aparc+aseg) and update the code accordingly. Assumed values for white matter have been used.");

% TODO: convert this visualisation step to use MNINonLinear tracts.
% if(exist([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz'],'file'))
%     % trackImg generated by DSI Studio (.tt.nii.gz) - saved in aparc+aseg.nii.gz
%     % space. Note there is also a .trk file that this file relies on for
%     % computations. trackImg is optional for visualisation purposes.
%     trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);
% end



if type==1
    atlas_mni_CRSToTkRAS = atlas_mni.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
elseif type==2
    atlas_mni_CRSToTkRAS = atlas_mni.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
else
    disp('wrong type of surface')
end


trk_len_full=[];
trk_type_full=[];
trkEP_full=[];

%% Loop through track files
for i=1:str2double(nTrackIterations)
    nTracksWithTwoUnknownEndpoints = 0;
    nTracksWithOneUnknownEndpoint = 0;
    %whiteMatterEndpointLabelIDs =[];

    %Read .trk meta and coordinates.
    track_terminals = readmatrix([pathToFile,'/T1w/Diffusion/1m',num2str(i-1),'_int1w_mni.csv']);
    start_points = track_terminals(2:2:end, :);
    end_points = track_terminals(1:2:end, :);
    rawTrkLen = size(start_points,1);

    trk_len=zeros(rawTrkLen,1,'single');
    trk_type=zeros(rawTrkLen,3,'single');
    trkEP=zeros(rawTrkLen,6,'single');
    storeTrkStartP = zeros([4,rawTrkLen]);
    storeTrkEndP = zeros([4,rawTrkLen]);
    storeTrkStartCoords_mni = zeros([4,rawTrkLen]);

    milestones = round(rawTrkLen * (0:0.1:1));
    tic;
    disp("Looping through each track and converting endpoints (in MNI) from IJK to XYZ and getting labels.");
    disp("Note: We get the anatomy label using aparc+aseg and *.trk when both in MNINonLinear space.");
    
    parfor k=1:rawTrkLen
        if ismember(k,milestones)
            disp((k/rawTrkLen)*100+"%");
        end
        trkMatrix_crs = [start_points(k,1:3); end_points(k,1:3) ];
        % Define the endpoints of the track.
        trkMatrix_crs_terminals = [trkMatrix_crs(1,:)'  trkMatrix_crs(end,:)'; 1 1;];


        trkstartp = round(trkMatrix_crs_terminals(1:3,1)); %rename for readability
        trkendp = round(trkMatrix_crs_terminals(1:3,end)); %rename for readability
        trkstartp = boundByAtlasDimensions(trkstartp, atlasMniDim);
        trkendp = boundByAtlasDimensions(trkendp, atlasMniDim);

        %% Transform track coordinates from CRS into Scanner RAS space
        % Get track coordinates from CRS into Scanner RAS space.
        trkMatrix_ras = atlas_mni_CRSToTkRAS * [trkMatrix_crs'; ones(1,size(trkMatrix_crs,1))];
        % Get track endpoints from CRS into Scanner RAS space.
        trkMatrix_ras_terminals = atlas_mni_CRSToTkRAS * trkMatrix_crs_terminals;


        trkMatrix_registered_ras = trkMatrix_ras;
        trkMatrix_registered_ras_terminals = trkMatrix_ras_terminals;
                
        
        storeTrkStartP(:, k) = [trkstartp; 1]; % store endpoint in matrix for visualisation.
        storeTrkStartCoords_mni(:, k) = [trkMatrix_registered_ras(1:3,1); 1]; % store endpoint in matrix for visualisation.
        
        %storeTrkEndP(:, k) = [trkendp; 1];

        %% TODO: Insert validation check. Are points being moved inconsiderable
        %% distances?

        %Compute track length along each vertex
        % NB: This is invalid, as we do not have each point along the
        % tract. (This would have to be from .trk!)
        trk_len(k,1)=1;

        % for the track to pial surface space
        trkEP(k,:)=[double(trkMatrix_registered_ras_terminals(1:3,1)') double(trkMatrix_registered_ras_terminals(1:3,end)')];

        % tmp information:
        % 1: trkstartp anatomical label ID
        % 2: trkendp anatomical label ID
        % 3: neighbouring voxels are in grey matter. (e.g., terminating within
        % subcortical structures). 1 = "ends in grey matter".
        tmp=NaN(1,3);
        try
            tmp(1:2)=[atlas_mni.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas_mni.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            %scatter3(trkMatrix(1,1),trkMatrix(1,2),trkMatrix(1,3));
            %scatter3(trkMatrix(end,1),trkMatrix(end,2),trkMatrix(end,3));
            disp("Error: The track endpoints yield indices that are not within the atlas image.");
            pause;
        end


        %% Check subcortical regions
        % For info on the choice of these numbers (1000, 3000 etc) check the
        % Freesurfer lookup table:
        % https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT
        whiteMatterIndices = getAtlasIndicesInGroups('whiteMatter');
        subcorticalIndices = getAtlasIndicesInGroups('subcortical');
        unknownIndices = getAtlasIndicesInGroups('unknown');
        if(ismember(tmp(1),whiteMatterIndices) || ...
                ismember(tmp(2),whiteMatterIndices))
            % If either endpoint is in the white matter, mark it.
            tmp(1,3)=0;
            
            if(tmp(1,3) == 0)
                if(ismember(tmp(1),whiteMatterIndices))
                    %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                end
                if(ismember(tmp(2),whiteMatterIndices))
                    %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                end
            end
        else
            % If the tracks do not terminate in white matter, confirm they
            % terminate in grey matter.
            if( ismember(tmp(1),subcorticalIndices) && ...
                    ismember(tmp(2),subcorticalIndices))
                % Both endpoints end in subcortical/grey matter...
                tmp(1,3)=1;
            elseif ( ismember(tmp(1),subcorticalIndices) && ...
                    ismember(tmp(2),unknownIndices))
                % Endpoint starts in subcortical/grey matter but
                % ends in "unknown"...
                try
                    nTracksWithOneUnknownEndpoint = nTracksWithOneUnknownEndpoint + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas_mni,trkendp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                    pause
                end
            elseif ( ismember(tmp(1),unknownIndices) && ...
                    ismember(tmp(2),subcorticalIndices))
                % Endpoint starts in "unknown" but
                % ends in subcortical/grey matter...
                try
                    nTracksWithOneUnknownEndpoint = nTracksWithOneUnknownEndpoint + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas_mni,trkstartp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                    pause
                end
            elseif (ismember(tmp(1),unknownIndices) && ...
                    ismember(tmp(2),unknownIndices))
                % If both track endpoints are "unknown"...
                try
                    nTracksWithTwoUnknownEndpoints = nTracksWithTwoUnknownEndpoints + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas_mni,trkstartp) && checkInNeighbourVoxels_withsubcortical(atlas_mni,trkendp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                    pause
                end
            else
                disp("Endpoint not analysed.");
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;
    end
    
    disp("Done looping converting tracks to endpoints.")
    toc;
    disp([num2str(nTracksWithOneUnknownEndpoint), " tracks w/ 1 unknown endpoint"]);
    disp([num2str(nTracksWithTwoUnknownEndpoints), " tracks w/ 2 unknown endpoints"]);
    disp([size(trk_type,1)-sum(trk_type(:,3)), " tracks in white matter (filtered out)"]);
    if(sum(isnan(trk_type(:,3))) > 0)
        disp([num2str(sum(isnan(trk_type(:,3)))), " tracks w/ endpoints uncategorised as white/grey matter"]);        
        pause
    end
    disp([sum(trk_type(:,3)), " tracks w/ both end points in grey matter (filtered in):"]);
    disp(["Total tracts:", size(trk_type,1)]);
    
    trk_len_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen) =trk_len;
    trk_type_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trk_type;
    trkEP_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trkEP;

end


%% Visualisations
if(exist("trackImg", "var"))
    figure;
    title("Slices of atlas and trackImg nifti files")
    slice(double(atlas_mni.anatomy),size(atlas_mni.anatomy,2)/2,size(atlas_mni.anatomy,1)/2,size(atlas_mni.anatomy,3)/2);
    figure;
    trackImg.anatomy = flip(trackImg.anatomy,2);
    slice(double(trackImg.anatomy),size(trackImg.anatomy,2)/2,size(trackImg.anatomy,1)/2,size(trackImg.anatomy,3)/2);
end

if(1 == 0)
    trkCoords_tkReg_mni = storeTrkStartCoords_mni';

    % Convert: trkCoords_tkReg (tkReg) -> atlas CRS
    atlasCRS_mni = (round(inv(atlas_mni_CRSToTkRAS)*trkCoords_tkReg_mni'))';
    atlasCoords_tkReg_mni = (atlas_mni_CRSToTkRAS*atlasCRS_mni')';

    % ----
    % Figure (1): tracts (MNINonLinear) and aparc (MNINonLinear) superimposed.
    % Used to show tracts are registered to MNINonLinear.
    % ---
    figure;
    title("Tracts and Aparc in coordinates (xyz)");
    subtitle(["Tracts=MNINonLinear space","aparc+aseg=MNINonLinear space"]);
    hold on;
    legend;
    scatter3(atlasCoords_tkReg_mni(:,1),atlasCoords_tkReg_mni(:,2),atlasCoords_tkReg_mni(:,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg_mni(:,1),trkCoords_tkReg_mni(:,2),trkCoords_tkReg_mni(:,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'/tracts_mni__aparc_mni__cords_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_mni__aparc_mni__cords_xyz.png']);
    

    % ----
    % Figure (3): tracts (MNINonLinear) and aparc (MNINonLinear) and fmri (MNINonLinear) superimposed.
    % Used to show tracts are registered to MNINonLinear, with coloured
    % faces from fMRI.
    % ---
    mycifti = ft_read_cifti([pathToFile,'/MNINonLinear/Results/tfMRI_MOTOR/tfMRI_MOTOR_hp200_s2_level2_MSMAll.feat/100206_tfMRI_MOTOR_level2_hp200_s2_MSMAll.dscalar.nii']);
    mygifti_L = gifti([pathToFile,'/MNINonLinear/fsaverage_LR32k/100206.L.pial.32k_fs_LR.surf.gii']);
    mygifti_R = gifti([pathToFile,'/MNINonLinear/fsaverage_LR32k/100206.R.pial.32k_fs_LR.surf.gii']);

    figure;
    hold on;
    title("Tracts and Aparc and fMRI in coordinates (xyz)");
    subtitle(["Tracts=MNINonLinear space","aparc+aseg=MNINonLinear space","fMRI=MNINonLinear space"]);
    hold on;
    legend;
    xlabel('x');
    ylabel('y');
    zlabel('z');
    mygifti_L_vertices_transformed = [mygifti_L.vertices];
    mygifti_R_vertices_transformed = [mygifti_R.vertices];

    % NB: vertices coords are in SurfaceRAS. Therefore, to go from aparc (CRS)
    % to this, we must use "type 1".
    %mygifti_L.faces(mygifti_L.faces>1) = 1;
    plotsurf(mygifti_L_vertices_transformed(:,1:3), mygifti_L.faces, mycifti.x100206_tfmri_motor_level2_lf_avg_hp200_s2_msmall(mycifti.brainstructure==1), 'DisplayName','L hemisphere surface', 'FaceAlpha', '0.2', 'EdgeAlpha','0.05');
    hold on;
    plotsurf(mygifti_R_vertices_transformed(:,1:3), mygifti_R.faces, mycifti.x100206_tfmri_motor_level2_lf_avg_hp200_s2_msmall(mycifti.brainstructure==2), 'DisplayName','R hemisphere surface', 'FaceAlpha', '0.2', 'EdgeAlpha','0.05');
    scatter3(atlasCoords_tkReg_mni(:,1),atlasCoords_tkReg_mni(:,2),atlasCoords_tkReg_mni(:,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg_mni(:,1),(trkCoords_tkReg_mni(:,2)),trkCoords_tkReg_mni(:,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'/tracts_mni__aparc_mni__fmri_mni__cords_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_mni__aparc_mni__fmri_mni__cords_xyz.png']);

   
end
end
"""
This type stub file was generated by pyright.
"""

import subprocess
from collections.abc import Callable, Iterator, Sequence
from os import PathLike
from typing import Any, List, Optional, TYPE_CHECKING, Tuple, TypeVar, Union, overload
from datalad.cmd import WitlessProtocol
from datalad.dataset.gitrepo import GitRepo as CoreGitRepo, path_based_str_repr
from datalad.support.due import Doi, due
from datalad.typing import Concatenate, Literal, P, Protocol, Self, T, TypedDict
from datalad.utils import Path, optional_args

"""Internal low-level interface to Git repositories

"""
if TYPE_CHECKING:
    ...
_curdirsep = ...
_pardirsep = ...
lgr = ...
Option = Union[str, bool, None, List[Union[str, bool, None]], Tuple[Union[str, bool, None], ...]]
def to_options(split_single_char_options: bool = ..., **kwargs: Option) -> list[str]:
    """Transform keyword arguments into a list of cmdline options

    Imported from GitPython.

    Original copyright:
        Copyright (C) 2008, 2009 Michael Trier and contributors
    Original license:
        BSD 3-Clause "New" or "Revised" License

    Parameters
    ----------
    split_single_char_options: bool

    kwargs:

    Returns
    -------
    list
    """
    ...

class _WithPath(Protocol):
    path: str
    ...


@optional_args
def normalize_path(func: Callable[Concatenate[_WithPath, str, P], T]) -> Callable[Concatenate[_WithPath, str, P], T]:
    """Decorator to provide unified path conversion for a single file

    Unlike normalize_paths, intended to be used for functions dealing with a
    single filename at a time

    Note
    ----
    This is intended to be used within the repository classes and therefore
    returns a class method!

    The decorated function is expected to take a path at
    first positional argument (after 'self'). Additionally the class `func`
    is a member of, is expected to have an attribute 'path'.
    """
    ...

@optional_args
def normalize_paths(func, match_return_type=..., map_filenames_back=..., serialize=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], list[Any] | Any | dict[Any, Any] | RuntimeError]:
    """Decorator to provide unified path conversions.

    Note
    ----
    This is intended to be used within the repository classes and therefore
    returns a class method!

    The decorated function is expected to take a path or a list of paths at
    first positional argument (after 'self'). Additionally the class `func`
    is a member of, is expected to have an attribute 'path'.

    Accepts either a list of paths or a single path in a str. Passes a list
    to decorated function either way, but would return based on the value of
    match_return_type and possibly input argument.

    If a call to the wrapped function includes normalize_path and it is False
    no normalization happens for that function call (used for calls to wrapped
    functions within wrapped functions, while possible CWD is within a
    repository)

    Parameters
    ----------
    match_return_type : bool, optional
      If True, and a single string was passed in, it would return the first
      element of the output (after verifying that it is a list of length 1).
      It makes easier to work with single files input.
    map_filenames_back : bool, optional
      If True and returned value is a dictionary, it assumes to carry entries
      one per file, and then filenames are mapped back to as provided from the
      normalized (from the root of the repo) paths
    serialize : bool, optional
      Loop through files giving only a single one to the function one at a time.
      This allows to simplify implementation and interface to annex commands
      which do not take multiple args in the same call (e.g. checkpresentkey)
    """
    ...

class GitProgress(WitlessProtocol):
    """Reduced variant of GitPython's RemoteProgress class

    Original copyright:
        Copyright (C) 2008, 2009 Michael Trier and contributors
    Original license:
        BSD 3-Clause "New" or "Revised" License
    """
    proc_err = ...
    _num_op_codes = ...
    STAGE_MASK = ...
    OP_MASK = ...
    DONE_TOKEN = ...
    TOKEN_SEPARATOR = ...
    _known_ops = ...
    __slots__ = ...
    re_op_absolute = ...
    re_op_relative = ...
    def __init__(self, done_future: Any = ..., encoding: Optional[str] = ...) -> None:
        ...
    
    def connection_made(self, transport: subprocess.Popen) -> None:
        ...
    
    def process_exited(self) -> None:
        ...
    
    def pipe_data_received(self, fd: int, byts: bytes) -> None:
        ...
    


class StdOutCaptureWithGitProgress(GitProgress):
    proc_out = ...


class FetchInfo(dict):
    """
    dict that carries results of a fetch operation of a single head

    Reduced variant of GitPython's RemoteProgress class

    Original copyright:
        Copyright (C) 2008, 2009 Michael Trier and contributors
    Original license:
        BSD 3-Clause "New" or "Revised" License
    """
    _re_fetch_result = ...
    _flag_map = ...
    _operation_map = ...


class PushInfo(dict):
    """dict that carries results of a push operation of a single head

    Reduced variant of GitPython's RemoteProgress class

    Original copyright:
        Copyright (C) 2008, 2009 Michael Trier and contributors
    Original license:
        BSD 3-Clause "New" or "Revised" License
    """
    _flag_map = ...
    _operation_map = ...


InfoT = TypeVar("InfoT", FetchInfo, PushInfo)
class GitAddOutput(TypedDict):
    file: str
    success: bool
    ...


@path_based_str_repr
class GitRepo(CoreGitRepo):
    """Representation of a git repository

    """
    _config_checked = ...
    GIT_MIN_VERSION = ...
    git_version = ...
    @due.dcite(Doi("10.21105/joss.03262"), path="datalad", description="DataLad - Data management and distribution platform")
    def __init__(self, path: str, runner: Any = ..., create: bool = ..., git_opts: Optional[dict[str, Any]] = ..., repo: Any = ..., fake_dates: bool = ..., create_sanity_checks: bool = ..., **kwargs: Any) -> None:
        """Creates representation of git repository at `path`.

        Can also be used to create a git repository at `path`.

        Parameters
        ----------
        path: str
          path to the git repository; In case it's not an absolute path,
          it's relative to PWD
        create: bool, optional
          if true, creates a git repository at `path` if there is none. Also
          creates `path`, if it doesn't exist.
          If set to false, an exception is raised in case `path` doesn't exist
          or doesn't contain a git repository.
        repo: git.Repo, optional
          This argument is ignored.
        create_sanity_checks: bool, optional
          Whether to perform sanity checks during initialization (when
          `create=True` and target path is not a valid repo already), such as
          that new repository is not created in the directory where git already
          tracks some files.
        kwargs:
          keyword arguments serving as additional options to the git-init
          command. Therefore, it makes sense only if called with `create`.

          Generally, this way of passing options to the git executable is
          (or will be) used a lot in this class. It's a transformation of
          python-style keyword arguments (or a `dict`) to command line arguments,
          provided by GitPython.

          A single character keyword will be prefixed by '-', multiple characters
          by '--'. An underscore in the keyword becomes a dash. The value of the
          keyword argument is used as the value for the corresponding command
          line argument. Assigning a boolean creates a flag.

          Examples:
          no_commit=True => --no-commit
          C='/my/path'   => -C /my/path

        """
        ...
    
    @property
    def bare(self) -> bool:
        """Returns a bool indicating whether the repository is bare

        Importantly, this is not reporting the configuration value
        of 'core.bare', in order to be usable at a stage where a
        Repo instance is not yet equipped with a ConfigManager.
        Instead, it is testing whether the repository path and its
        "dot_git" are identical. The value of 'core.bare' can be query
        from the ConfigManager in a fully initialized instance.
        """
        ...
    
    @classmethod
    def clone(cls, url: str, path: str, *args: Any, clone_options: Optional[list[str] | dict[str, Option]] = ..., **kwargs: Any) -> Self:
        """Clone url into path

        Provides workarounds for known issues (e.g.
        https://github.com/datalad/datalad/issues/785)

        Parameters
        ----------
        url : str
        path : str
        clone_options : dict or list
          Arbitrary options that will be passed on to the underlying call to
          `git-clone`. This may be a list of plain options or key-value pairs
          that will be converted to a list of plain options with `to_options`.
        expect_fail : bool
          Whether expect that command might fail, so error should be logged then
          at DEBUG level instead of ERROR
        kwargs:
          Passed to the Repo class constructor.
        """
        ...
    
    def is_valid_git(self) -> bool:
        """Returns whether the underlying repository appears to be still valid

        Note, that this almost identical to the classmethod is_valid_repo().
        However, if we are testing an existing instance, we can save Path object
        creations. Since this testing is done a lot, this is relevant. Creation
        of the Path objects in is_valid_repo() takes nearly half the time of the
        entire function.

        Also note, that this method is bound to an instance but still
        class-dependent, meaning that a subclass cannot simply overwrite it.
        This is particularly important for the call from within __init__(),
        which in turn is called by the subclasses' __init__. Using an overwrite
        would lead to the wrong thing being called.
        """
        ...
    
    @classmethod
    def is_valid_repo(cls, path: str) -> bool:
        """Returns if a given path points to a git repository"""
        ...
    
    @staticmethod
    def get_git_dir(repo: str | GitRepo) -> str:
        """figure out a repo's gitdir

        '.git' might be a  directory, a symlink or a file

        Note
        ----
        This method is likely to get deprecated, please use GitRepo.dot_git instead!
        That one's not static, but it's cheaper and you should avoid
        not having an instance of a repo you're working on anyway.
        Note, that the property in opposition to this method returns an absolute path.


        Parameters
        ----------
        repo: path or Repo instance
          currently expected to be the repos base dir

        Returns
        -------
        str
          relative path to the repo's git dir; So, default would be ".git"
        """
        ...
    
    @property
    def config(self): # -> ConfigManager:
        ...
    
    def is_with_annex(self) -> bool:
        """Report if GitRepo (assumed) has (remotes with) a git-annex branch
        """
        ...
    
    @classmethod
    def get_toppath(cls, path: str, follow_up: bool = ..., git_options: Optional[list[str]] = ...) -> Optional[str]:
        """Return top-level of a repository given the path.

        Parameters
        -----------
        follow_up : bool
          If path has symlinks -- they get resolved by git.  If follow_up is
          True, we will follow original path up until we hit the same resolved
          path.  If no such path found, resolved one would be returned.
        git_options: list of str
          options to be passed to the git rev-parse call

        Return None if no parent directory contains a git repository.
        """
        ...
    
    @normalize_paths
    def add(self, files: list[str], git: bool = ..., git_options: Optional[list[str]] = ..., update: bool = ...) -> list[GitAddOutput]:
        """Adds file(s) to the repository.

        Parameters
        ----------
        files: list
          list of paths to add
        git: bool
          somewhat ugly construction to be compatible with AnnexRepo.add();
          has to be always true.
        update: bool
          --update option for git-add. From git's manpage:
           Update the index just where it already has an entry matching
           <pathspec>. This removes as well as modifies index entries to match
           the working tree, but adds no new files.

           If no <pathspec> is given when --update option is used, all tracked
           files in the entire working tree are updated (old versions of Git
           used to limit the update to the current directory and its
           subdirectories).

        Returns
        -------
        list
          Of status dicts.
        """
        ...
    
    def add_(self, files: list[str], git: bool = ..., git_options: Optional[list[str]] = ..., update: bool = ...) -> Iterator[GitAddOutput]:
        """Like `add`, but returns a generator"""
        ...
    
    @normalize_paths(match_return_type=False)
    def remove(self, files: list[str], recursive: bool = ..., **kwargs: Option) -> list[str]:
        """Remove files.

        Calls git-rm.

        Parameters
        ----------
        files: list of str
          list of paths to remove
        recursive: False
          whether to allow recursive removal from subdirectories
        kwargs:
          see `__init__`

        Returns
        -------
        [str]
          list of successfully removed files.
        """
        ...
    
    def precommit(self) -> None:
        """Perform pre-commit maintenance tasks
        """
        ...
    
    def configure_fake_dates(self) -> None:
        """Configure repository to use fake dates.
        """
        ...
    
    @property
    def fake_dates_enabled(self) -> bool:
        """Is the repository configured to use fake dates?
        """
        ...
    
    def add_fake_dates(self, env): # -> dict[str, str]:
        ...
    
    def commit(self, msg: Optional[str] = ..., options: Optional[list[str]] = ..., _datalad_msg: bool = ..., careless: bool = ..., files: Optional[list[str]] = ..., date: Optional[str] = ..., index_file: Optional[str] = ...) -> None:
        """Commit changes to git.

        Parameters
        ----------
        msg: str, optional
          commit-message
        options: list of str, optional
          cmdline options for git-commit
        _datalad_msg: bool, optional
          To signal that commit is automated commit by datalad, so
          it would carry the [DATALAD] prefix
        careless: bool, optional
          if False, raise when there's nothing actually committed;
          if True, don't care
        files: list of str, optional
          path(s) to commit
        date: str, optional
          Date in one of the formats git understands
        index_file: str, optional
          An alternative index to use
        """
        ...
    
    def get_indexed_files(self) -> list[str]:
        """Get a list of files in git's index

        Returns
        -------
        list
            list of paths rooting in git's base dir
        """
        ...
    
    def format_commit(self, fmt: str, commitish: Optional[str] = ...) -> Optional[str]:
        """Return `git show` output for `commitish`.

        Parameters
        ----------
        fmt : str
            A format string accepted by `git show`.
        commitish: str, optional
          Any commit identifier (defaults to "HEAD").

        Returns
        -------
        str or, if there are not commits yet, None.
        """
        ...
    
    def get_hexsha(self, commitish: Optional[str] = ..., short: bool = ...) -> Optional[str]:
        """Return a hexsha for a given commitish.

        Parameters
        ----------
        commitish : str, optional
          Any identifier that refers to a commit (defaults to "HEAD").
        short : bool, optional
          Return the abbreviated form of the hexsha.

        Returns
        -------
        str or, if no commitish was given and there are no commits yet, None.

        Raises
        ------
        ValueError
          If a commitish was given, but no corresponding commit could be
          determined.
        """
        ...
    
    @normalize_paths(match_return_type=False)
    def get_last_commit_hexsha(self, files: list[str]) -> Optional[str]:
        """Return the hash of the last commit the modified any of the given
        paths"""
        ...
    
    def get_revisions(self, revrange: str | list[str] | None = ..., fmt: str = ..., options: Optional[list[str]] = ...) -> list[str]:
        """Return list of revisions in `revrange`.

        Parameters
        ----------
        revrange : str or list of str or None, optional
            Revisions or revision ranges to walk. If None, revision defaults to
            HEAD unless a revision-modifying option like `--all` or
            `--branches` is included in `options`.
        fmt : string, optional
            Format accepted by `--format` option of `git log`. This should not
            contain new lines because the output is split on new lines.
        options : list of str, optional
            Options to pass to `git log`.  This should not include `--format`.

        Returns
        -------
        List of revisions (str), formatted according to `fmt`.
        """
        ...
    
    def commit_exists(self, commitish: str) -> bool:
        """Does `commitish` exist in the repo?

        Parameters
        ----------
        commitish : str
            A commit or an object that can be dereferenced to one.

        Returns
        -------
        bool
        """
        ...
    
    def get_merge_base(self, commitishes: str | list[str]) -> Optional[str]:
        """Get a merge base hexsha

        Parameters
        ----------
        commitishes: str or list of str
          List of commitishes (branches, hexshas, etc) to determine the merge
          base of. If a single value provided, returns merge_base with the
          current branch.

        Returns
        -------
        str or None
          If no merge-base for given commits, or specified treeish doesn't
          exist, None returned
        """
        ...
    
    def is_ancestor(self, reva: str, revb: str) -> bool:
        """Is `reva` an ancestor of `revb`?

        Parameters
        ----------
        reva, revb : str
            Revisions.

        Returns
        -------
        bool
        """
        ...
    
    def get_commit_date(self, branch: Optional[str] = ..., date: str = ...) -> Optional[int]:
        """Get the date stamp of the last commit (in a branch or head otherwise)

        Parameters
        ----------
        date: {'authored', 'committed'}
          Which date to return.  "authored" will be the date shown by "git show"
          and the one possibly specified via --date to `git commit`

        Returns
        -------
        int or None
          None if no commit
        """
        ...
    
    def get_active_branch(self) -> Optional[str]:
        """Get the name of the active branch

        Returns
        -------
        str or None
          Returns None if there is no active branch, i.e. detached HEAD,
          and the branch name otherwise.
        """
        ...
    
    def get_corresponding_branch(self, branch: Any = ...) -> Optional[str]:
        """Always returns None, a plain GitRepo has no managed branches"""
        ...
    
    def get_branches(self) -> list[str]:
        """Get all branches of the repo.

        Returns
        -------
        [str]
            Names of all branches of this repository.
        """
        ...
    
    def get_remote_branches(self) -> list[str]:
        """Get all branches of all remotes of the repo.

        Returns
        -----------
        [str]
            Names of all remote branches.
        """
        ...
    
    def get_remotes(self, with_urls_only: bool = ...) -> list[str]:
        """Get known remotes of the repository

        Parameters
        ----------
        with_urls_only : bool, optional
          return only remotes which have urls

        Returns
        -------
        remotes : list of str
          List of names of the remotes
        """
        ...
    
    def get_files(self, branch: Optional[str] = ...) -> list[str]:
        """Get a list of files in git.

        Lists the files in the (remote) branch.

        Parameters
        ----------
        branch: str
          Name of the branch to query. Default: active branch.

        Returns
        -------
        [str]
          list of files.
        """
        ...
    
    def add_remote(self, name: str, url: str, options: Optional[list[str]] = ...) -> tuple[str, str]:
        """Register remote pointing to a url
        """
        ...
    
    def remove_remote(self, name: str) -> None:
        """Remove existing remote
        """
        ...
    
    def update_remote(self, name: Optional[str] = ..., verbose: bool = ...) -> None:
        """
        """
        ...
    
    def fetch(self, remote: Optional[str] = ..., refspec: str | list[str] | None = ..., all_: bool = ..., git_options: Optional[list[str]] = ..., **kwargs: Option) -> list[FetchInfo]:
        """Fetches changes from a remote (or all remotes).

        Parameters
        ----------
        remote : str, optional
          name of the remote to fetch from. If no remote is given and
          `all_` is not set, the tracking branch is fetched.
        refspec : str or list, optional
          refspec(s) to fetch.
        all_ : bool, optional
          fetch all remotes (and all of their branches).
          Fails if `remote` was given.
        git_options : list, optional
          Additional command line options for git-fetch.
        kwargs :
          Deprecated. GitPython-style keyword argument for git-fetch.
          Will be appended to any git_options.
        """
        ...
    
    def fetch_(self, remote: Optional[str] = ..., refspec: str | list[str] | None = ..., all_: bool = ..., git_options: Optional[list[str]] = ...) -> Iterator[FetchInfo]:
        """Like `fetch`, but returns a generator"""
        ...
    
    def push(self, remote: Optional[str] = ..., refspec: str | list[str] | None = ..., all_remotes: bool = ..., all_: bool = ..., git_options: Optional[list[str]] = ..., **kwargs: Option) -> list[PushInfo]:
        """Push changes to a remote (or all remotes).

        If remote and refspec are specified, and remote has
        `remote.{remote}.datalad-push-default-first` configuration variable
        set (e.g. by `create-sibling-github`), we will first push the first
        refspec separately to possibly ensure that the first refspec is chosen
        by remote as the "default branch".
        See https://github.com/datalad/datalad/issues/4997
        Upon successful push if this variable was set in the local git config,
        we unset it, so subsequent pushes would proceed normally.

        Parameters
        ----------
        remote : str, optional
          name of the remote to push to. If no remote is given and
          `all_` is not set, the tracking branch is pushed.
        refspec : str or list, optional
          refspec(s) to push.
        all_ : bool, optional
          push to all remotes. Fails if `remote` was given.
        git_options : list, optional
          Additional command line options for git-push.
        kwargs :
          Deprecated. GitPython-style keyword argument for git-push.
          Will be appended to any git_options.
        """
        ...
    
    def push_(self, remote: Optional[str] = ..., refspec: str | list[str] | None = ..., all_: bool = ..., git_options: Optional[list[str]] = ...) -> Iterator[PushInfo]:
        """Like `push`, but returns a generator"""
        ...
    
    def get_remote_url(self, name: str, push: bool = ...) -> Optional[str]:
        """Get the url of a remote.

        Reads the configuration of remote `name` and returns its url or None,
        if there is no url configured.

        Parameters
        ----------
        name: str
          name of the remote
        push: bool
          if True, get the pushurl instead of the fetch url.
        """
        ...
    
    def set_remote_url(self, name: str, url: str, push: bool = ...) -> None:
        """Set the URL a remote is pointing to

        Sets the URL of the remote `name`. Requires the remote to already exist.

        Parameters
        ----------
        name: str
          name of the remote
        url: str
        push: bool
          if True, set the push URL, otherwise the fetch URL
        """
        ...
    
    def get_branch_commits_(self, branch: Optional[str] = ..., limit: Optional[str] = ..., stop: Optional[str] = ...) -> Iterator[str]:
        """Return commit hexshas for a branch

        Parameters
        ----------
        branch: str, optional
          If not provided, assumes current branch
        limit: None | 'left-only', optional
          Limit which commits to report.  If None -- all commits (merged or not),
          if 'left-only' -- only the commits from the left side of the tree upon
          merges
        stop: str, optional
          hexsha of the commit at which stop reporting (matched one is not
          reported either)

        Yields
        ------
        str
        """
        ...
    
    def checkout(self, name: str, options: Optional[list[str]] = ...) -> None:
        """
        """
        ...
    
    def merge(self, name: str, options: Optional[list[str]] = ..., msg: Optional[str] = ..., allow_unrelated: bool = ..., **kwargs: Any) -> None:
        ...
    
    def remove_branch(self, branch: str) -> None:
        ...
    
    def cherry_pick(self, commit: str) -> None:
        """Cherry pick `commit` to the current branch.

        Parameters
        ----------
        commit : str
            A single commit.
        """
        ...
    
    @property
    def dirty(self) -> bool:
        """Is the repository dirty?

        Note: This provides a quick answer when you simply want to know if
        there are any untracked changes or modifications in this repository or
        its submodules. For finer-grained control and more detailed reporting,
        use status() instead.
        """
        ...
    
    @property
    def untracked_files(self) -> list[str]:
        """Legacy interface, do not use! Use the status() method instead.

        Despite its name, it also reports on untracked datasets, and
        yields their names with trailing path separators.
        """
        ...
    
    def gc(self, allow_background: bool = ..., auto: bool = ...) -> None:
        """Perform house keeping (garbage collection, repacking)"""
        ...
    
    def get_submodules_(self, paths: Optional[list[str | PathLike[str]]] = ...) -> Iterator[dict]:
        """Yield submodules in this repository.

        Parameters
        ----------
        paths : list(pathlib.PurePath), optional
            Restrict submodules to those under `paths`. Paths must be relative
            to the resolved repository root, and must be normed to match the
            reporting done by Git, i.e. no parent dir components
            (ala "some/../this").

        Returns
        -------
        A generator that yields a dictionary with information for each
        submodule.
        """
        ...
    
    def get_submodules(self, sorted_: bool = ..., paths: Optional[list[str | PathLike[str]]] = ...) -> list[dict]:
        """Return list of submodules.

        Parameters
        ----------
        sorted_ : bool, optional
            Sort submodules by path name.
        paths : list(pathlib.PurePath), optional
            Restrict submodules to those under `paths`.

        Returns
        -------
        List of submodule namedtuples if `compat` is true or otherwise a list
        of dictionaries as returned by `get_submodules_`.
        """
        ...
    
    def update_ref(self, ref: str, value: str, oldvalue: Optional[str] = ..., symbolic: bool = ...) -> None:
        """Update the object name stored in a ref "safely".

        Just a shim for `git update-ref` call if not symbolic, and
        `git symbolic-ref` if symbolic

        Parameters
        ----------
        ref : str
          Reference, such as `ref/heads/BRANCHNAME` or HEAD.
        value : str
          Value to update to, e.g. hexsha of a commit when updating for a
          branch ref, or branch ref if updating HEAD
        oldvalue: str
          Value to update from. Safeguard to be verified by git. This is only
          valid if `symbolic` is not True.
        symbolic : None
          To instruct if ref is symbolic, e.g. should be used in case of
          ref=HEAD
        """
        ...
    
    def tag(self, tag: str, message: Optional[str] = ..., commit: Optional[str] = ..., options: Optional[list[str]] = ...) -> None:
        """Tag a commit

        Parameters
        ----------
        tag : str
          Custom tag label. Must be a valid tag name.
        message : str, optional
          If provided, adds ['-m', <message>] to the list of `git tag`
          arguments.
        commit : str, optional
          If provided, will be appended as last argument to the `git tag` call,
          and can be used to identify the commit that shall be tagged, if
          not HEAD.
        options : list, optional
          Additional command options, inserted prior a potential `commit`
          argument.
        """
        ...
    
    @overload
    def get_tags(self, output: None = ...) -> list[dict[str, str]]:
        ...
    
    @overload
    def get_tags(self, output: str) -> list[str]:
        ...
    
    def get_tags(self, output: Optional[str] = ...) -> list[dict[str, str]] | list[str]:
        """Get list of tags

        Parameters
        ----------
        output : str, optional
          If given, limit the return value to a list of values matching that
          particular key of the tag properties.

        Returns
        -------
        list
          Each item is a dictionary with information on a tag. At present
          this includes 'hexsha', and 'name', where the latter is the string
          label of the tag, and the former the hexsha of the object the tag
          is attached to. The list is sorted by the creator date (committer
          date for lightweight tags and tagger date for annotated tags), with
          the most recent commit being the last element.
        """
        ...
    
    def describe(self, commitish: Optional[str] = ..., **kwargs: Option) -> Optional[str]:
        """ Quick and dirty implementation to call git-describe

        Parameters
        ----------
        kwargs:
            transformed to cmdline options for git-describe;
            see __init__ for description of the transformation
        """
        ...
    
    def get_tracking_branch(self, branch: Optional[str] = ..., remote_only: bool = ...) -> tuple[Optional[str], Optional[str]]:
        """Get the tracking branch for `branch` if there is any.

        Parameters
        ----------
        branch: str
            local branch to look up. If none is given, active branch is used.
        remote_only : bool
            Don't return a value if the upstream remote is set to "." (meaning
            this repository).

        Returns
        -------
        tuple
            (remote or None, refspec or None) of the tracking branch
        """
        ...
    
    @property
    def count_objects(self) -> dict[str, int]:
        """return dictionary with count, size(in KiB) information of git objects
        """
        ...
    
    def get_git_attributes(self) -> dict[str, str | bool]:
        """Query gitattributes which apply to top level directory

        It is a thin compatibility/shortcut wrapper around more versatile
        get_gitattributes which operates on a list of paths and returns
        a dictionary per each path

        Returns
        -------
        dict:
          a dictionary with attribute name and value items relevant for the
          top ('.') directory of the repository, and thus most likely the
          default ones (if not overwritten with more rules) for all files within
          repo.
        """
        ...
    
    def get_gitattributes(self, path: str | list[str], index_only: bool = ...) -> dict[str, dict[str, str | bool]]:
        """Query gitattributes for one or more paths

        Parameters
        ----------
        path: path or list
          Path(s) to query. Paths may be relative or absolute.
        index_only: bool
          Flag whether to consider only gitattribute setting that are reflected
          in the repository index, not just in the work tree content.

        Returns
        -------
        dict:
          Each key is a queried path (always relative to the repository root),
          each value is a dictionary with attribute
          name and value items. Attribute values are either True or False,
          for set and unset attributes, or are the literal attribute value.
        """
        ...
    
    def set_gitattributes(self, attrs: list[tuple[str, dict[str, str | bool]]], attrfile: str = ..., mode: str = ...) -> None:
        """Set gitattributes

        By default appends additional lines to `attrfile`. Note, that later
        lines in `attrfile` overrule earlier ones, which may or may not be
        what you want. Set `mode` to 'w' to replace the entire file by
        what you provided in `attrs`.

        Parameters
        ----------
        attrs : list
          Each item is a 2-tuple, where the first element is a path pattern,
          and the second element is a dictionary with attribute key/value
          pairs. The attribute dictionary must use the same semantics as those
          returned by `get_gitattributes()`. Path patterns can use absolute paths,
          in which case they will be normalized relative to the directory
          that contains the target .gitattributes file (see `attrfile`).
        attrfile: path
          Path relative to the repository root of the .gitattributes file the
          attributes shall be set in.
        mode: str
          'a' to append .gitattributes, 'w' to replace it
        """
        ...
    
    def get_content_info(self, paths: Optional[Sequence[str | PathLike[str]]] = ..., ref: Optional[str] = ..., untracked: str = ...) -> dict[Path, dict[str, str | int | None]]:
        """Get identifier and type information from repository content.

        This is simplified front-end for `git ls-files/tree`.

        Both commands differ in their behavior when queried about subdataset
        paths. ls-files will not report anything, ls-tree will report on the
        subdataset record. This function uniformly follows the behavior of
        ls-tree (report on the respective subdataset mount).

        Parameters
        ----------
        paths : list(pathlib.PurePath) or None
          Specific paths, relative to the resolved repository root, to query
          info for. Paths must be normed to match the reporting done by Git,
          i.e. no parent dir components (ala "some/../this").
          If `None`, info is reported for all content.
        ref : gitref or None
          If given, content information is retrieved for this Git reference
          (via ls-tree), otherwise content information is produced for the
          present work tree (via ls-files). With a given reference, the
          reported content properties also contain a 'bytesize' record,
          stating the size of a file in bytes.
        untracked : {'no', 'normal', 'all'}
          If and how untracked content is reported when no `ref` was given:
          'no': no untracked files are reported; 'normal': untracked files
          and entire untracked directories are reported as such; 'all': report
          individual files even in fully untracked directories.

        Returns
        -------
        dict
          Each content item has an entry under a pathlib `Path` object instance
          pointing to its absolute path inside the repository (this path is
          guaranteed to be underneath `Repo.path`).
          Each value is a dictionary with properties:

          `type`
            Can be 'file', 'symlink', 'dataset', 'directory'

          `gitshasum`
            SHASUM of the item as tracked by Git, or None, if not
            tracked. This could be different from the SHASUM of the file
            in the worktree, if it was modified.

        Raises
        ------
        ValueError
          In case of an invalid Git reference (e.g. 'HEAD' in an empty
          repository)
        """
        ...
    
    def status(self, paths: Optional[Sequence[str | PathLike[str]]] = ..., untracked: str = ..., eval_submodule_state: Literal[commit, full, no] = ...) -> dict[Path, dict[str, str]]:
        """Simplified `git status` equivalent.

        Parameters
        ----------
        paths : list or None
          If given, limits the query to the specified paths. To query all
          paths specify `None`, not an empty list. If a query path points
          into a subdataset, a report is made on the subdataset record
          within the queried dataset only (no recursion).
        untracked : {'no', 'normal', 'all'}
          If and how untracked content is reported:
          'no': no untracked files are reported; 'normal': untracked files
          and entire untracked directories are reported as such; 'all': report
          individual files even in fully untracked directories.
        eval_submodule_state : {'full', 'commit', 'no'}
          If 'full' (the default), the state of a submodule is evaluated by
          considering all modifications, with the treatment of untracked files
          determined by `untracked`. If 'commit', the modification check is
          restricted to comparing the submodule's HEAD commit to the one
          recorded in the superdataset. If 'no', the state of the subdataset is
          not evaluated.

        Returns
        -------
        dict
          Each content item has an entry under a pathlib `Path` object instance
          pointing to its absolute path inside the repository (this path is
          guaranteed to be underneath `Repo.path`).
          Each value is a dictionary with properties:

          `type`
            Can be 'file', 'symlink', 'dataset', 'directory'
          `state`
            Can be 'added', 'untracked', 'clean', 'deleted', 'modified'.
        """
        ...
    
    def diff(self, fr: Optional[str], to: Optional[str], paths: Optional[Sequence[str | PathLike[str]]] = ..., untracked: str = ..., eval_submodule_state: Literal[commit, full, no] = ...) -> dict[Path, dict[str, str]]:
        """Like status(), but reports changes between to arbitrary revisions

        Parameters
        ----------
        fr : str or None
          Revision specification (anything that Git understands). Passing
          `None` considers anything in the target state as new.
        to : str or None
          Revision specification (anything that Git understands), or None
          to compare to the state of the work tree.
        paths : list or None
          If given, limits the query to the specified paths. To query all
          paths specify `None`, not an empty list.
        untracked : {'no', 'normal', 'all'}
          If and how untracked content is reported when `to` is None:
          'no': no untracked files are reported; 'normal': untracked files
          and entire untracked directories are reported as such; 'all': report
          individual files even in fully untracked directories.
        eval_submodule_state : {'full', 'commit', 'no'}
          If 'full' (the default), the state of a submodule is evaluated by
          considering all modifications, with the treatment of untracked files
          determined by `untracked`. If 'commit', the modification check is
          restricted to comparing the submodule's HEAD commit to the one
          recorded in the superdataset. If 'no', the state of the subdataset is
          not evaluated.

        Returns
        -------
        dict
          Each content item has an entry under a pathlib `Path` object instance
          pointing to its absolute path inside the repository (this path is
          guaranteed to be underneath `Repo.path`).
          Each value is a dictionary with properties:

          `type`
            Can be 'file', 'symlink', 'dataset', 'directory'
          `state`
            Can be 'added', 'untracked', 'clean', 'deleted', 'modified'.
        """
        ...
    
    @overload
    def diffstatus(self, fr: Optional[str], to: Optional[str], paths: Optional[Sequence[str | PathLike[str]]] = ..., untracked: str = ..., *, eval_submodule_state: Literal["global"], _cache: Optional[dict] = ...) -> str:
        ...
    
    @overload
    def diffstatus(self, fr: Optional[str], to: Optional[str], paths: Optional[Sequence[str | PathLike[str]]] = ..., untracked: str = ..., eval_submodule_state: Literal[commit, full, no] = ..., _cache: Optional[dict] = ...) -> dict[Path, dict[str, str]]:
        ...
    
    def diffstatus(self, fr: Optional[str], to: Optional[str], paths: Optional[Sequence[str | PathLike[str]]] = ..., untracked: str = ..., eval_submodule_state: str = ..., _cache: Optional[dict] = ...) -> dict[Path, dict[str, str]] | str:
        """Like diff(), but reports the status of 'clean' content too.

        It supports an additional submodule evaluation state 'global'.
        If given, it will return a single 'modified'
        (vs. 'clean') state label for the entire repository, as soon as
        it can.
        """
        ...
    
    def get_staged_paths(self) -> list[str]:
        """Returns a list of any stage repository path(s)

        This is a rather fast call, as it will not depend on what is going on
        in the worktree.
        """
        ...
    
    def save(self, message: Optional[str] = ..., paths: Optional[list[Path]] = ..., _status: Optional[dict[Path, dict[str, str]]] = ..., **kwargs: Any) -> list[dict]:
        """Save dataset content.

        Parameters
        ----------
        message : str or None
          A message to accompany the changeset in the log. If None,
          a default message is used.
        paths : list or None
          Any content with path matching any of the paths given in this
          list will be saved. Matching will be performed against the
          dataset status (GitRepo.status()), or a custom status provided
          via `_status`. If no paths are provided, ALL non-clean paths
          present in the repo status or `_status` will be saved.
        _status : dict or None
          If None, Repo.status() will be queried for the given `ds`. If
          a dict is given, its content will be used as a constraint.
          For example, to save only modified content, but no untracked
          content, set `paths` to None and provide a `_status` that has
          no entries for untracked content.
        **kwargs :
          Additional arguments that are passed to underlying Repo methods.
          Supported:

          - git : bool (passed to Repo.add()
          - eval_submodule_state : {'full', 'commit', 'no'}
            passed to Repo.status()
          - untracked : {'no', 'normal', 'all'} - passed to Repo.status()
          - amend : bool (passed to GitRepo.commit)
        """
        ...
    
    def save_(self, message: Optional[str] = ..., paths: Optional[list[Path]] = ..., _status: Optional[dict[Path, dict[str, str]]] = ..., **kwargs: Any) -> Iterator[dict]:
        """Like `save()` but working as a generator."""
        ...
    



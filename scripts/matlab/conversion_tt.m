function [trkEP_full,trk_len_full,trk_type_full]=conversion_tt(pathToFile, type)
%% load tt file generated by dsi studio
close all;
restoredefaultpath;
gcp;
% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS
addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));
addpath('toolboxes/FieldTrip');
ft_defaults;

disp('step1: performing conversion from .trk to surface and atlas')
disp(['Type: ' num2str(type) ' (' class(type) ')'])


%atlas image generated by FreeSurfer.
atlas=ft_read_mri([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);
%trackImg generated by DSI Studio (.tt.nii.gz) - saved in aparc+aseg.nii.gz
%space. Note there is also a .trk file that this file relies on for
%computations.
if(exist([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz'],'file'))
    trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);
end
if type==1
    atlasCRSToTkRAS = atlas.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
elseif type==2
    atlasCRSToTkRAS = atlas.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
    % To generate register.dat
    % tkregister2 --mov [dsi-studio root]/atlas/ICBM152_adult/ICBM152_adult.T1W.nii.gz --targ [subjectRoot]/MNINonLinear/T1w.nii.gz --reg [subjectRoot]/MNINonLinear/register.dat --regheader --noedit
    tkregister_matrix    = importdata([pathToFile '/MNINonLinear/register.dat']);
    tkregister_matrix    = reshape(tkregister_matrix  .data(4:end), [4 4])';
else
    disp('wrong type of surface')
end

trk_len_full=[];
trk_type_full=[];
trkEP_full=[];
for i=1:1
    nNotInAtlas = 0;
    %gunzip([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'.tt.gz'],[pathToFile,'/T1w/Diffusion']);
    %movefile([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'_new.tt'],[pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'_new.mat']);
    [rawTrkHeader, rawtrkCoords_tkReg] = trk_read([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'.trk']);

    rawTrkLen=length(rawtrkCoords_tkReg);

    trk_len=zeros(rawTrkLen,1,'single');
    trk_type=zeros(rawTrkLen,3,'single');
    trkEP=zeros(rawTrkLen,6,'single');%
    storeTrkStartP = zeros([4,rawTrkLen]);
    storeTrkEndP = zeros([4,rawTrkLen]);
    storeTrkStartCoords = zeros([4,rawTrkLen]);
    voxel_size = rawTrkHeader.voxel_size;
    atlasDim = atlas.dim;
    milestones = round(rawTrkLen * (0:0.1:1));
    tic;
    disp("Looping through each track and converting into endpoints.");
    parfor k=1:rawTrkLen
        if ismember(k,milestones)
            disp((k/rawTrkLen)*100+"%");
        end
        trkMatrix_crs = rawtrkCoords_tkReg(k).matrix ./ voxel_size;

        %% It is important we flip Y [LPS (.trk) -> LAS (.anat)]
        trkMatrix_crs(:,2) = (-1 * trkMatrix_crs(:,2)) + atlasDim(2); %flip Y.
        trkMatrix_crs_terminals = [trkMatrix_crs(1,:)'  trkMatrix_crs(end,:)'; 1 1;];
        trkMatrix_tkreg = atlasCRSToTkRAS * [trkMatrix_crs'; ones(1,size(trkMatrix_crs,1))];
        trkMatrix_tkreg_terminals = atlasCRSToTkRAS * trkMatrix_crs_terminals;
        trkMatrix_registered_tkreg = tkregister_matrix * trkMatrix_tkreg;
        trkMatrix_registered_tkreg_terminals = tkregister_matrix * trkMatrix_tkreg_terminals;

        %% code here to see if both endpoints are in the grey matter
        trkstartp = round(trkMatrix_crs_terminals(1:3,1));

        % Where a voxel is now marginally outside atlasDim due to
        % rounding, bring it back in.
        voxelsAboveRange = (trkstartp'-atlasDim==1);
        trkstartp(voxelsAboveRange) = atlasDim(voxelsAboveRange)';
        voxelsBelowRange = (atlasDim-trkstartp'==1);
        trkstartp(voxelsBelowRange) = 1;
        storeTrkStartP(:, k) = [trkstartp; 1];
        storeTrkStartCoords(:, k) = [trkMatrix_registered_tkreg(1:3,1); 1];


        trkendp = round(trkMatrix_crs_terminals(1:3,end));
        voxelsAboveRange = (trkendp'-atlasDim==1);
        trkendp(voxelsAboveRange) = atlasDim(voxelsAboveRange)';
        voxelsBelowRange = (atlasDim-trkendp'==1);
        trkendp(voxelsBelowRange) = 1;

        %storeTrkEndP(:, k) = [trkendp; 1];

        %% TODO: Insert validation check. Are points being moved inconsiderable
        %% distances?
        %
   
        %Compute track length along each vertex
        trkPoints_notLast=trkMatrix_crs(1:end-1,:);
        trkPoints_notFirst=trkMatrix_crs(2:end,:);
        distBetweenTrkPoints=sqrt( (trkPoints_notLast(:,1)-trkPoints_notFirst(:,1)).^2 +(trkPoints_notLast(:,2)-trkPoints_notFirst(:,2)).^2 +(trkPoints_notLast(:,3)-trkPoints_notFirst(:,3)).^2);
        trk_len(k,1)=sum(distBetweenTrkPoints);

        % for the track to pial surface space
        trkEP(k,:)=[single(trkMatrix_registered_tkreg_terminals(1:3,1)') single(trkMatrix_registered_tkreg_terminals(1:3,end)')];


        % tmp information:
        % 1: trkstartp anatomical label ID
        % 2: trkendp anatomical label ID
        % 3: anatomical label ID as per neighbouring voxels.
        tmp=zeros(1,3); 
        try
            tmp(1:2)=[atlas.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            %scatter3(trkMatrix(1,1),trkMatrix(1,2),trkMatrix(1,3));
            %scatter3(trkMatrix(end,1),trkMatrix(end,2),trkMatrix(end,3));
            nNotInAtlas = nNotInAtlas +1;
        end

        if(sum(tmp) == 0)
            nNotInAtlas = nNotInAtlas +1;
        end

        %for info on the choice of these numbers (1000, 3000 etc) check the
        %freesurfer lookup table.

        % add subcortical regions
        if  ( (tmp(1)<7 && tmp(1)>0) || (tmp(1)>26 && tmp(1)<47) || (tmp(1)<1000 && tmp(1)>58) || (tmp(1)>=3000) ) &&  ( (tmp(2)<7 && tmp(2)>0) || (tmp(2)>26 && tmp(2)<47) || (tmp(2)<1000 && tmp(2)>58) || (tmp(2)>=3000) )
            tmp(1,3)=0;
        elseif ( (tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000) ) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24 && ( (tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000) ) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24
            tmp(1,3)=1;
        elseif tmp(1)==0 && tmp(2)==0
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp)*checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                pause
            end
        elseif tmp(1)==0 && ( ((tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000)) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                pause
            end
        elseif tmp(2)==0 && ( ((tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000)) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;
    end
    disp("Done looping converting tracks to endpoints.")
    toc;
    disp("Number of tracts not in atlas:");
    disp(nNotInAtlas);
    trk_len_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen) =trk_len;
    trk_type_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trk_type;
    trkEP_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trkEP;
  
end


%% Visualisations
if(exist("trackImg", "var"))
    figure;
    title("Slices of atlas and trackImg nifti files")
    slice(double(atlas.anatomy),size(atlas.anatomy,2)/2,size(atlas.anatomy,1)/2,size(atlas.anatomy,3)/2);
    figure;
    trackImg.anatomy = flip(trackImg.anatomy,2);
    slice(double(trackImg.anatomy),size(trackImg.anatomy,2)/2,size(trackImg.anatomy,1)/2,size(trackImg.anatomy,3)/2);
end

trkCoords_tkReg = storeTrkStartCoords';

% Convert: trkCoords_tkReg (tkReg) -> atlas CRS
atlasCRS = (round(inv(atlasCRSToTkRAS)*trkCoords_tkReg'))';
atlasCoords_tkReg = (atlasCRSToTkRAS*atlasCRS')';

figure;
title("Tracts and Aparc in coordinates (xyz)")
hold on;
legend;
scatter3(atlasCoords_tkReg(1:1:end,1),atlasCoords_tkReg(1:1:end,2),atlasCoords_tkReg(1:1:end,3), 'DisplayName', "atlasCoords_{tkReg}");
scatter3(trkCoords_tkReg(1:1:end,1),(trkCoords_tkReg(1:1:end,2)),trkCoords_tkReg(1:1:end,3), 'DisplayName', "trkCoords_{tkReg}");


figure;
title("Tracts and Aparc in voxels (ijk)")
% Build: take atlas.nii.gz and binarize it to approximate volume (CRS)
atlasCRSIndices = find(atlas.anatomy > mean(atlas.anatomy,'ALL'));
[atlasX, atlasY, atlasZ] = ind2sub(atlas.dim, atlasCRSIndices);
atlasCRS = [atlasX atlasY atlasZ];
trkCRS = storeTrkStartP;
hold on;
legend;
scatter3(atlasCRS(1:1:end,1),atlasCRS(1:1:end,2),atlasCRS(1:1:end,3), 'DisplayName', "atlasCRS");
scatter3(trkCRS(1,1:1:end),trkCRS(2,1:1:end),trkCRS(3,1:1:end), 'DisplayName', "trkCRS");

end

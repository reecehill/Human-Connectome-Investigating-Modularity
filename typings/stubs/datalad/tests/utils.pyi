"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from http.server import SimpleHTTPRequestHandler
from ..utils import *
from ..support.vcr_ import *
from ..dochelpers import borrowkwargs

"""Miscellaneous utilities to assist with testing"""
_TEMP_PATHS_CLONES = ...
on_travis = ...
neq_ = ...
nok_ = ...
lgr = ...
def skip_if_no_module(module): # -> None:
    ...

def skip_if_scrapy_without_selector(): # -> None:
    """A little helper to skip some tests which require recent scrapy"""
    ...

def skip_if_url_is_not_available(url, regex=...): # -> None:
    ...

def check_not_generatorfunction(func): # -> None:
    """Internal helper to verify that we are not decorating generator tests"""
    ...

def skip_if_no_network(func=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | None:
    """Skip test completely in NONETWORK settings

    If not used as a decorator, and just a function, could be used at the module level
    """
    ...

def skip_if_on_windows(func=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown] | None:
    """Skip test completely under Windows
    """
    ...

@optional_args
def skip_if(func, cond=..., msg=..., method=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown | None]:
    """Skip test for specific condition

    Parameters
    ----------
    cond: bool
      condition on which to skip
    msg: str
      message to print if skipping
    method: str
      either 'raise' or 'pass'. Whether to skip by raising `SkipTest` or by
      just proceeding and simply not calling the decorated function.
      This is particularly meant to be used, when decorating single assertions
      in a test with method='pass' in order to not skip the entire test, but
      just that assertion.
    """
    ...

def skip_ssh(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Skips SSH tests if on windows or if environment variable
    DATALAD_TESTS_SSH was not set
    """
    ...

@optional_args
def skip_v6_or_later(func, method=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Skip tests if v6 or later will be used as the default repo version.

    The default repository version is controlled by the configured value of
    DATALAD_REPO_VERSION and whether v5 repositories are supported by the
    installed git-annex.
    """
    ...

def ok_clean_git(path, annex=..., head_modified=..., index_modified=..., untracked=..., ignore_submodules=...): # -> None:
    """Verify that under given path there is a clean git repository

    it exists, .git exists, nothing is uncommitted/dirty/staged

    Note
    ----
    Parameters head_modified and index_modified currently work
    in pure git or indirect mode annex only. If they are given, no
    test of modification of known repo content is performed.

    Parameters
    ----------
    path: str or Repo
      in case of a str: path to the repository's base dir;
      Note, that passing a Repo instance prevents detecting annex. This might be
      useful in case of a non-initialized annex, a GitRepo is pointing to.
    annex: bool or None
      explicitly set to True or False to indicate, that an annex is (not)
      expected; set to None to autodetect, whether there is an annex.
      Default: None.
    ignore_submodules: bool
      if True, submodules are not inspected
    """
    ...

def ok_file_under_git(path, filename=..., annexed=...): # -> None:
    """Test if file is present and under git/annex control

    If relative path provided, then test from current directory
    """
    ...

def put_file_under_git(path, filename=..., content=..., annexed=...): # -> AnnexRepo | GitRepo:
    """Place file under git/annex and return used Repo
    """
    ...

def ok_symlink(path): # -> None:
    """Checks whether path is either a working or broken symlink"""
    ...

def ok_good_symlink(path): # -> None:
    ...

def ok_broken_symlink(path): # -> None:
    ...

def ok_startswith(s, prefix): # -> None:
    ...

def ok_endswith(s, suffix): # -> None:
    ...

def nok_startswith(s, prefix): # -> None:
    ...

def ok_git_config_not_empty(ar): # -> None:
    """Helper to verify that nothing rewritten the config file"""
    ...

def ok_annex_get(ar, files, network=...): # -> None:
    """Helper to run .get decorated checking for correct operation

    get passes through stderr from the ar to the user, which pollutes
    screen while running tests

    Note: Currently not true anymore, since usage of --json disables
    progressbars
    """
    ...

def ok_generator(gen): # -> None:
    ...

assert_is_generator = ...
def ok_archives_caches(repopath, n=..., persistent=...): # -> None:
    """Given a path to repository verify number of archives

    Parameters
    ----------
    repopath : str
      Path to the repository
    n : int, optional
      Number of archives directories to expect
    persistent: bool or None, optional
      If None -- both persistent and not count.
    """
    ...

def ok_exists(path): # -> None:
    ...

def ok_file_has_content(path, content, strip=..., re_=..., decompress=..., **kwargs): # -> None:
    """Verify that file exists and has expected content"""
    ...

@optional_args
def with_tree(t, tree=..., archives_leading_dir=..., delete=..., **tkwargs): # -> _Wrapped[(...), Unknown, (*arg: Unknown, **kw: Unknown), Unknown]:
    ...

lgr = ...
class SilentHTTPHandler(SimpleHTTPRequestHandler):
    """A little adapter to silence the handler
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def log_message(self, format, *args): # -> None:
        ...
    


class HTTPPath:
    """Serve the content of a path via an HTTP URL.

    This class can be used as a context manager, in which case it returns the
    URL.

    Alternatively, the `start` and `stop` methods can be called directly.

    Parameters
    ----------
    path : str
        Directory with content to serve.
    """
    def __init__(self, path) -> None:
        ...
    
    def __enter__(self): # -> str | None:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    
    def start(self): # -> None:
        """Start serving `path` via HTTP.
        """
        ...
    
    def stop(self): # -> None:
        """Stop serving `path`.
        """
        ...
    


@optional_args
def serve_path_via_http(tfunc, *targs): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Decorator which serves content of a directory via http url
    """
    ...

@optional_args
def with_memory_keyring(t): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Decorator to use non-persistant MemoryKeyring instance
    """
    ...

@optional_args
def without_http_proxy(tfunc): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Decorator to remove http*_proxy env variables for the duration of the test
    """
    ...

@borrowkwargs(methodname=make_tempfile)
@optional_args
def with_tempfile(t, **tkwargs): # -> _Wrapped[(...), Unknown, (*arg: Unknown, **kw: Unknown), Unknown]:
    """Decorator function to provide a temporary file name and remove it at the end

    Parameters
    ----------

    To change the used directory without providing keyword argument 'dir' set
    DATALAD_TESTS_TEMP_DIR.

    Examples
    --------

    ::

        @with_tempfile
        def test_write(tfile):
            open(tfile, 'w').write('silly test')
    """
    ...

def probe_known_failure(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown | None]:
    """Test decorator allowing the test to pass when it fails and vice versa

    Setting config datalad.tests.knownfailures.probe to True tests, whether or
    not the test is still failing. If it's not, an AssertionError is raised in
    order to indicate that the reason for failure seems to be gone.
    """
    ...

@optional_args
def skip_known_failure(func, method=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Test decorator allowing to skip a test that is known to fail

    Setting config datalad.tests.knownfailures.skip to a bool enables/disables
    skipping.
    """
    ...

def known_failure(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Test decorator marking a test as known to fail

    This combines `probe_known_failure` and `skip_known_failure` giving the
    skipping precedence over the probing.
    """
    ...

def known_failure_v6_or_later(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Test decorator marking a test as known to fail in a v6+ test run

    If the default repository version is 6 or later behaves like `known_failure`.
    Otherwise the original (undecorated) function is returned.
    The default repository version is controlled by the configured value of
    DATALAD_REPO_VERSION and whether v5 repositories are supported by the
    installed git-annex.
    """
    ...

known_failure_v6 = ...
def known_failure_direct_mode(func):
    """DEPRECATED.  Stop using.  Does nothing

    Test decorator marking a test as known to fail in a direct mode test run

    If datalad.repo.direct is set to True behaves like `known_failure`.
    Otherwise the original (undecorated) function is returned.
    """
    ...

def known_failure_windows(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Test decorator marking a test as known to fail on windows

    On Windows behaves like `known_failure`.
    Otherwise the original (undecorated) function is returned.
    """
    ...

def known_failure_appveyor(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Test decorator marking a test as known to fail on AppVeyor.
    """
    ...

def known_failure_githubci_win(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Test decorator for a known test failure on Github's Windows CI
    """
    ...

def clone_url(url): # -> str:
    ...

if noton_windows:
    local_testrepo_flavors = ...
else:
    local_testrepo_flavors = ...
_TESTREPOS = ...
@known_failure_appveyor
@optional_args
def with_testrepos(t, regex=..., flavors=..., skip=..., count=...): # -> _Wrapped[(...), Unknown, (*arg: Unknown, **kw: Unknown), None]:
    """Decorator to provide a local/remote test repository

    All tests under datalad/tests/testrepos are stored in two-level hierarchy,
    where top-level name describes nature/identifier of the test repository,
    and there could be multiple instances (e.g. generated differently) of the
    same "content"

    Parameters
    ----------
    regex : string, optional
      Regex to select which test repos to use
    flavors : {'auto', 'local', 'local-url', 'clone', 'network', 'network-clone'} or list of thereof, optional
      What URIs to provide.  E.g. 'local' would just provide path to the
      repository, while 'network' would provide url of the remote location
      available on Internet containing the test repository.  'clone' would
      clone repository first to a temporary location. 'network-clone' would
      first clone from the network location. 'auto' would include the list of
      appropriate ones (e.g., no 'network*' flavors if network tests are
      "forbidden").
    count: int, optional
      If specified, only up to that number of repositories to test with

    Examples
    --------

    >>> from datalad.tests.utils import with_testrepos
    >>> @with_testrepos('basic_annex')
    ... def test_write(repo):
    ...    assert(os.path.exists(os.path.join(repo, '.git', 'annex')))

    """
    ...

@optional_args
def with_sameas_remote(func, autoenabled=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Provide a repository with a git-annex sameas remote configured.

    The repository will have two special remotes: r_dir (type=directory) and
    r_rsync (type=rsync). The rsync remote will be configured with
    --sameas=r_dir, and autoenabled if `autoenabled` is true.
    """
    ...

@optional_args
def with_fake_cookies_db(func, cookies=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """mock original cookies db with a fake one for the duration of the test
    """
    ...

@optional_args
def assert_cwd_unchanged(func, ok_to_chdir=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Decorator to test whether the current working directory remains unchanged

    Parameters
    ----------
    ok_to_chdir: bool, optional
      If True, allow to chdir, so this decorator would not then raise exception
      if chdir'ed but only return to original directory
    """
    ...

@optional_args
def run_under_dir(func, newdir=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), None]:
    """Decorator to run tests under another directory

    It is somewhat ugly since we can't really chdir
    back to a directory which had a symlink in its path.
    So using this decorator has potential to move entire
    testing run under the dereferenced directory name -- sideeffect.

    The only way would be to instruct testing framework (i.e. nose
    in our case ATM) to run a test by creating a new process with
    a new cwd
    """
    ...

def assert_re_in(regex, c, flags=..., match=..., msg=...): # -> None:
    """Assert that container (list, str, etc) contains entry matching the regex
    """
    ...

def assert_dict_equal(d1, d2): # -> None:
    ...

def assert_str_equal(s1, s2): # -> None:
    """Helper to compare two lines"""
    ...

def assert_status(label, results): # -> None:
    """Verify that each status dict in the results has a given status label

    `label` can be a sequence, in which case status must be one of the items
    in this sequence.
    """
    ...

def assert_message(message, results): # -> None:
    """Verify that each status dict in the results has a message

    This only tests the message template string, and not a formatted message
    with args expanded.
    """
    ...

def assert_result_count(results, n, **kwargs): # -> None:
    """Verify specific number of results (matching criteria, if any)"""
    ...

def assert_in_results(results, **kwargs): # -> None:
    """Verify that the particular combination of keys and values is found in
    one of the results"""
    ...

def assert_not_in_results(results, **kwargs): # -> None:
    """Verify that the particular combination of keys and values is not in any
    of the results"""
    ...

def assert_result_values_equal(results, prop, values): # -> None:
    """Verify that the values of all results for a given key in the status dicts
    match the given sequence"""
    ...

def assert_result_values_cond(results, prop, cond): # -> None:
    """Verify that the values of all results for a given key in the status dicts
    fullfill condition `cond`.

    Parameters
    ----------
    results:
    prop: str
    cond: callable
    """
    ...

def ignore_nose_capturing_stdout(func):
    """DEPRECATED and will be removed soon.  Does nothing!

    Originally was intended as a decorator workaround for nose's behaviour
    with redirecting sys.stdout, but now we monkey patch nose now so no test
    should no longer be skipped.

    See issue reported here:
    https://code.google.com/p/python-nose/issues/detail?id=243&can=1&sort=-id&colspec=ID%20Type%20Status%20Priority%20Stars%20Milestone%20Owner%20Summary

    """
    ...

def skip_httpretty_on_problematic_pythons(func): # -> (*args: Unknown, **kwargs: Unknown) -> Unknown:
    """As discovered some httpretty bug causes a side-effect
    on other tests on some Pythons.  So we skip the test if such
    problematic combination detected

    References
    https://travis-ci.org/datalad/datalad/jobs/94464988
    http://stackoverflow.com/a/29603206/1265472
    """
    ...

@optional_args
def with_parametric_batch(t): # -> _Wrapped[(...), Unknown, (), Generator[tuple[Unknown, bool], None, None]]:
    """Helper to run parametric test with possible combinations of batch and direct
    """
    ...

OBSCURE_PREFIX = ...
OBSCURE_FILENAMES = ...
UNICODE_FILENAME = ...
if sys.getfilesystemencoding().lower() == 'utf-8':
    OBSCURE_FILENAMES = ...
@with_tempfile(mkdir=True)
def get_most_obscure_supported_name(tdir): # -> str:
    """Return the most obscure filename that the filesystem would support under TEMPDIR

    TODO: we might want to use it as a function where we would provide tdir
    """
    ...

OBSCURE_FILENAME = ...
@optional_args
def with_testsui(t, responses=..., interactive=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Switch main UI to be 'tests' UI and possibly provide answers to be used"""
    ...

def assert_no_errors_logged(func, skip_re=...): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Decorator around function to assert that no errors logged during its execution"""
    ...

def get_mtimes_and_digests(target_path): # -> tuple[dict[str, dict[str, Any]], dict[str, float]]:
    """Return digests (md5) and mtimes for all the files under target_path"""
    ...

def get_datasets_topdir(): # -> Any | str:
    """Delayed parsing so it could be monkey patched etc"""
    ...

def assert_repo_status(path, annex=..., untracked_mode=..., **kwargs): # -> None:
    """Compare a repo status against (optional) exceptions.

    Anything file/directory that is not explicitly indicated must have
    state 'clean', i.e. no modifications and recorded in Git.

    This is an alternative to the traditional `ok_clean_git` helper.

    Parameters
    ----------
    path: str or Repo
      in case of a str: path to the repository's base dir;
      Note, that passing a Repo instance prevents detecting annex. This might
      be useful in case of a non-initialized annex, a GitRepo is pointing to.
    annex: bool or None
      explicitly set to True or False to indicate, that an annex is (not)
      expected; set to None to autodetect, whether there is an annex.
      Default: None.
    untracked_mode: {'no', 'normal', 'all'}
      If and how untracked content is reported. The specification of untracked
      files that are OK to be found must match this mode. See `Repo.status()`
    **kwargs
      Files/directories that are OK to not be in 'clean' state. Each argument
      must be one of 'added', 'untracked', 'deleted', 'modified' and each
      value must be a list of filenames (relative to the root of the
      repository, in POSIX convention).
    """
    ...

def get_convoluted_situation(path, repocls=...): # -> Any:
    ...

def get_deeply_nested_structure(path): # -> Any:
    """ Here is what this does (assuming UNIX, locked):
    |  .
    |  ├── directory_untracked
    |  │   └── link2dir -> ../subdir
    |  ├── OBSCURE_FILENAME_file_modified
    |  ├── link2dir -> subdir
    |  ├── link2subdsdir -> subds_modified/subdir
    |  ├── link2subdsroot -> subds_modified
    |  ├── subdir
    |  │   ├── annexed_file.txt -> ../.git/annex/objects/...
    |  │   ├── file_modified
    |  │   ├── git_file.txt
    |  │   └── link2annex_files.txt -> annexed_file.txt
    |  └── subds_modified
    |      ├── link2superdsdir -> ../subdir
    |      ├── subdir
    |      │   └── annexed_file.txt -> ../.git/annex/objects/...
    |      └── subds_lvl1_modified
    |          └── OBSCURE_FILENAME_directory_untracked
    |              └── untracked_file

    When a system has no symlink support, the link2... components are not
    included.
    """
    ...

def has_symlink_capability(): # -> bool:
    ...

def skip_wo_symlink_capability(func): # -> _Wrapped[(...), Unknown, (*args: Unknown, **kwargs: Unknown), Unknown]:
    """Skip test when environment does not support symlinks

    Perform a behavioral test instead of top-down logic, as on
    windows this could be on or off on a case-by-case basis.
    """
    ...

def patch_config(vars): # -> _patch_dict:
    """Patch our config with custom settings. Returns mock.patch cm
    """
    ...

@contextmanager
def set_date(timestamp): # -> Generator[None, None, None]:
    """Temporarily override environment variables for git/git-annex dates.

    Parameters
    ----------
    timestamp : int
        Unix timestamp.
    """
    ...

@contextmanager
def set_annex_version(version): # -> Generator[None, None, None]:
    """Override the git-annex version.

    This temporarily masks the git-annex version present in external_versions
    and make AnnexRepo forget its cached version information.
    """
    ...

def integration(f):
    """Mark test as an "integration" test which generally is not needed to be run
    
    Generally tend to be slower
    """
    ...

def slow(f):
    """Mark test as a slow, although not necessarily integration or usecase test
    """
    ...

def usecase(f):
    """Mark test as a usecase user ran into and which (typically) caused bug report
    to be filed/troubleshooted
    """
    ...


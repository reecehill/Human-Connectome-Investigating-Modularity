"""
This type stub file was generated by pyright.
"""

import fasteners
from datalad.utils import auto_repr
from .. import cfg

"""Interface to an ssh connection.

Allows for connecting via ssh and keeping the connection open
(by using a controlmaster), in order to perform several ssh commands or
git calls to a ssh remote without the need to reauthenticate.
"""
lgr = ...
def get_connection_hash(hostname, port=..., username=..., identity_file=..., bundled=..., force_ip=...): # -> str:
    """Generate a hash based on SSH connection properties

    This can be used for generating filenames that are unique
    to a connection from and to a particular machine (with
    port and login username). The hash also contains the local
    host name.

    Identity file corresponds to a file that will be passed via ssh's -i
    option.

    All parameters correspond to the respective properties of an SSH
    connection, except for `bundled`, which is unused.

    .. deprecated:: 0.16
       The ``bundled`` argument is ignored.
    """
    ...

@auto_repr
class BaseSSHConnection:
    """Representation of an SSH connection.
    """
    def __init__(self, sshri, identity_file=..., use_remote_annex_bundle=..., force_ip=...) -> None:
        """Create a connection handler

        The actual opening of the connection is performed on-demand.

        Parameters
        ----------
        sshri: SSHRI
          SSH resource identifier (contains all connection-relevant info),
          or another resource identifier that can be converted into an SSHRI.
        identity_file : str or None
          Value to pass to ssh's -i option.
        use_remote_annex_bundle : bool, optional
          If enabled, look for a git-annex installation on the remote and
          prefer its Git binaries in the search path (i.e. prefer a bundled
          Git over a system package). See also the configuration setting
          datalad.ssh.try-use-annex-bundled-git
        force_ip : {False, 4, 6}
           Force the use of IPv4 or IPv6 addresses with -4 or -6.

        .. versionchanged:: 0.16
           The default for `use_remote_annex_bundle` changed from `True`
           to `None`. Instead of attempting to use a potentially available
           git-annex bundle on the remote host by default, this behavior
           is now conditional on the `datalad.ssh.try-use-annex-bundled-git`
           (off by default).
        """
        ...
    
    def __call__(self, cmd, options=..., stdin=..., log_output=...):
        """Executes a command on the remote.

        It is the callers responsibility to properly quote commands
        for remote execution (e.g. filename with spaces of other special
        characters).

        Parameters
        ----------
        cmd: str
          command to run on the remote
        options : list of str, optional
          Additional options to pass to the `-o` flag of `ssh`. Note: Many
          (probably most) of the available configuration options should not be
          set here because they can critically change the properties of the
          connection. This exists to allow options like SendEnv to be set.
        log_output: bool
          Whether to capture and return stdout+stderr.

        Returns
        -------
        tuple of str
          stdout, stderr of the command run, if `log_output` was `True`
        """
        ...
    
    def open(self):
        """Opens the connection.

        Returns
        -------
        bool
          To return True if connection establishes a control socket successfully.
          Return False otherwise
        """
        ...
    
    def close(self):
        """Closes the connection.
        """
        ...
    
    @property
    def ssh_executable(self):
        """determine which ssh client executable should be used.
        """
        ...
    
    @property
    def runner(self): # -> WitlessRunner:
        ...
    
    @property
    def ssh_version(self): # -> None:
        ...
    
    def put(self, source, destination, recursive=..., preserve_attrs=...): # -> tuple[Any, Any]:
        """Copies source file/folder to destination on the remote.

        Note: this method performs escaping of filenames to an extent that
        moderately weird ones should work (spaces, quotes, pipes, other
        characters with special shell meaning), but more complicated cases
        might require appropriate external preprocessing of filenames.

        Parameters
        ----------
        source : str or list
          file/folder path(s) to copy from on local
        destination : str
          file/folder path to copy to on remote
        recursive : bool
          flag to enable recursive copying of given sources
        preserve_attrs : bool
          preserve modification times, access times, and modes from the
          original file

        Returns
        -------
        str
          stdout, stderr of the copy operation.
        """
        ...
    
    def get(self, source, destination, recursive=..., preserve_attrs=...): # -> tuple[Any, Any]:
        """Copies source file/folder from remote to a local destination.

        Note: this method performs escaping of filenames to an extent that
        moderately weird ones should work (spaces, quotes, pipes, other
        characters with special shell meaning), but more complicated cases
        might require appropriate external preprocessing of filenames.

        Parameters
        ----------
        source : str or list
          file/folder path(s) to copy from the remote host
        destination : str
          file/folder path to copy to on the local host
        recursive : bool
          flag to enable recursive copying of given sources
        preserve_attrs : bool
          preserve modification times, access times, and modes from the
          original file

        Returns
        -------
        str
          stdout, stderr of the copy operation.
        """
        ...
    
    def get_annex_installdir(self): # -> None:
        ...
    
    def get_annex_version(self): # -> None:
        ...
    
    def get_git_version(self): # -> None:
        ...
    


@auto_repr
class NoMultiplexSSHConnection(BaseSSHConnection):
    """Representation of an SSH connection.

    The connection is opened for execution of a single process, and closed
    as soon as the process end.
    """
    def __call__(self, cmd, options=..., stdin=..., log_output=...): # -> tuple[Any, Any]:
        ...
    
    def is_open(self): # -> Literal[False]:
        ...
    
    def open(self): # -> Literal[False]:
        ...
    
    def close(self): # -> None:
        ...
    


@auto_repr
class MultiplexSSHConnection(BaseSSHConnection):
    """Representation of a (shared) ssh connection.
    """
    def __init__(self, ctrl_path, sshri, **kwargs) -> None:
        """Create a connection handler

        The actual opening of the connection is performed on-demand.

        Parameters
        ----------
        ctrl_path: str
          path to SSH controlmaster
        sshri: SSHRI
          SSH resource identifier (contains all connection-relevant info),
          or another resource identifier that can be converted into an SSHRI.
        **kwargs
          Pass on to BaseSSHConnection
        """
        ...
    
    def __call__(self, cmd, options=..., stdin=..., log_output=...): # -> tuple[Any, Any]:
        ...
    
    def is_open(self): # -> bool:
        ...
    
    @fasteners.locked
    def open(self): # -> bool:
        """Opens the connection.

        In other words: Creates the SSH ControlMaster to be used by this
        connection, if it is not there already.

        Returns
        -------
        bool
          True when SSH reports success opening the connection, False when
          a ControlMaster for an open connection already exists.

        Raises
        ------
        ConnectionOpenFailedError
          When starting the SSH ControlMaster process failed.
        """
        ...
    
    def close(self): # -> None:
        ...
    


@auto_repr
class BaseSSHManager:
    """Interface for an SSHManager
    """
    def ensure_initialized(self): # -> None:
        """Ensures that manager is initialized"""
        ...
    
    assure_initialized = ...
    def get_connection(self, url, use_remote_annex_bundle=..., force_ip=...):
        """Get an SSH connection handler

        Parameters
        ----------
        url: str
          ssh url
        use_remote_annex_bundle : bool, optional
          If enabled, look for a git-annex installation on the remote and
          prefer its Git binaries in the search path (i.e. prefer a bundled
          Git over a system package). See also the configuration setting
          datalad.ssh.try-use-annex-bundled-git
        force_ip : {False, 4, 6}
          Force the use of IPv4 or IPv6 addresses.

        Returns
        -------
        BaseSSHConnection

        .. versionchanged:: 0.16
           The default for `use_remote_annex_bundle` changed from `True`
           to `None`. Instead of attempting to use a potentially available
           git-annex bundle on the remote host by default, this behavior
           is now conditional on the `datalad.ssh.try-use-annex-bundled-git`
           (off by default).
        """
        ...
    
    def close(self, allow_fail=...): # -> None:
        """Closes all connections, known to this instance.

        Parameters
        ----------
        allow_fail: bool, optional
          If True, swallow exceptions which might be thrown during
          connection.close, and just log them at DEBUG level
        """
        ...
    


@auto_repr
class NoMultiplexSSHManager(BaseSSHManager):
    """Does not "manage" and just returns a new connection
    """
    def get_connection(self, url, use_remote_annex_bundle=..., force_ip=...): # -> NoMultiplexSSHConnection:
        ...
    


@auto_repr
class MultiplexSSHManager(BaseSSHManager):
    """Keeps ssh connections to share. Serves singleton representation
    per connection.

    A custom identity file can be specified via `datalad.ssh.identityfile`.
    Callers are responsible for reloading `datalad.cfg` if they have changed
    this value since loading datalad.
    """
    def __init__(self) -> None:
        ...
    
    @property
    def socket_dir(self): # -> Path | None:
        """Return socket_dir, and if was not defined before,
        and also pick up all previous connections (if any)
        """
        ...
    
    def ensure_initialized(self): # -> None:
        """Assures that manager is initialized - knows socket_dir, previous connections
        """
        ...
    
    assure_initialized = ...
    def get_connection(self, url, use_remote_annex_bundle=..., force_ip=...): # -> MultiplexSSHConnection:
        ...
    
    def close(self, allow_fail=..., ctrl_path=...): # -> None:
        """Closes all connections, known to this instance.

        Parameters
        ----------
        allow_fail: bool, optional
          If True, swallow exceptions which might be thrown during
          connection.close, and just log them at DEBUG level
        ctrl_path: str, Path, or list of str or Path, optional
          If specified, only the path(s) provided would be considered
        """
        ...
    


if cfg.obtain('datalad.ssh.multiplex-connections'):
    SSHManager = ...
    SSHConnection = ...
else:
    SSHManager = ...
    SSHConnection = ...

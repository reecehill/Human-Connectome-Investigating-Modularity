"""
This type stub file was generated by pyright.
"""

from ..base import CommandLine, CommandLineInputSpec, File, OutputMultiPath, TraitedSpec
from .base import FSCommand, FSCommandOpenMP, FSScriptCommand, FSScriptOutputSpec, FSSurfaceCommand, FSTraitedSpec, FSTraitedSpecOpenMP

"""Interfaces to assorted Freesurfer utility programs.
"""
__docformat__ = ...
filemap = ...
filetypes = ...
implicit_filetypes = ...
logger = ...
def copy2subjdir(cls, in_file, folder=..., basename=..., subject_id=...): # -> str:
    """Method to copy an input to the subjects directory"""
    ...

def createoutputdirs(outputs): # -> None:
    """create all output directories. If not created, some freesurfer interfaces fail"""
    ...

class SampleToSurfaceInputSpec(FSTraitedSpec):
    source_file = ...
    reference_file = ...
    hemi = ...
    surface = ...
    reg_xors = ...
    reg_file = ...
    reg_header = ...
    mni152reg = ...
    apply_rot = ...
    apply_trans = ...
    override_reg_subj = ...
    sampling_method = ...
    sampling_range = ...
    sampling_units = ...
    projection_stem = ...
    smooth_vol = ...
    smooth_surf = ...
    interp_method = ...
    cortex_mask = ...
    mask_label = ...
    float2int_method = ...
    fix_tk_reg = ...
    subject_id = ...
    target_subject = ...
    surf_reg = ...
    ico_order = ...
    reshape = ...
    no_reshape = ...
    reshape_slices = ...
    scale_input = ...
    frame = ...
    out_file = ...
    out_type = ...
    hits_file = ...
    hits_type = ...
    vox_file = ...


class SampleToSurfaceOutputSpec(TraitedSpec):
    out_file = ...
    hits_file = ...
    vox_file = ...


class SampleToSurface(FSCommand):
    """Sample a volume to the cortical surface using Freesurfer's mri_vol2surf.

    You must supply a sampling method, range, and units.  You can project
    either a given distance (in mm) or a given fraction of the cortical
    thickness at that vertex along the surface normal from the target surface,
    and then set the value of that vertex to be either the value at that point
    or the average or maximum value found along the projection vector.

    By default, the surface will be saved as a vector with a length equal to the
    number of vertices on the target surface.  This is not a problem for Freesurfer
    programs, but if you intend to use the file with interfaces to another package,
    you must set the ``reshape`` input to True, which will factor the surface vector
    into a matrix with dimensions compatible with proper Nifti files.

    Examples
    --------

    >>> import nipype.interfaces.freesurfer as fs
    >>> sampler = fs.SampleToSurface(hemi="lh")
    >>> sampler.inputs.source_file = "cope1.nii.gz"
    >>> sampler.inputs.reg_file = "register.dat"
    >>> sampler.inputs.sampling_method = "average"
    >>> sampler.inputs.sampling_range = 1
    >>> sampler.inputs.sampling_units = "frac"
    >>> sampler.cmdline  # doctest: +ELLIPSIS
    'mri_vol2surf --hemi lh --o ...lh.cope1.mgz --reg register.dat --projfrac-avg 1.000 --mov cope1.nii.gz'
    >>> res = sampler.run() # doctest: +SKIP

    """
    _cmd = ...
    input_spec = SampleToSurfaceInputSpec
    output_spec = SampleToSurfaceOutputSpec


class SurfaceSmoothInputSpec(FSTraitedSpec):
    in_file = ...
    subject_id = ...
    hemi = ...
    fwhm = ...
    smooth_iters = ...
    cortex = ...
    reshape = ...
    out_file = ...


class SurfaceSmoothOutputSpec(TraitedSpec):
    out_file = ...


class SurfaceSmooth(FSCommand):
    """Smooth a surface image with mri_surf2surf.

    The surface is smoothed by an iterative process of averaging the
    value at each vertex with those of its adjacent neighbors. You may supply
    either the number of iterations to run or a desired effective FWHM of the
    smoothing process.  If the latter, the underlying program will calculate
    the correct number of iterations internally.

    See Also
    --------
    `nipype.interfaces.freesurfer.utils.SmoothTessellation`_ interface for
    smoothing a tessellated surface (e.g. in gifti or .stl)

    Examples
    --------
    >>> import nipype.interfaces.freesurfer as fs
    >>> smoother = fs.SurfaceSmooth()
    >>> smoother.inputs.in_file = "lh.cope1.mgz"
    >>> smoother.inputs.subject_id = "subj_1"
    >>> smoother.inputs.hemi = "lh"
    >>> smoother.inputs.fwhm = 5
    >>> smoother.cmdline # doctest: +ELLIPSIS
    'mri_surf2surf --cortex --fwhm 5.0000 --hemi lh --sval lh.cope1.mgz --tval ...lh.cope1_smooth5.mgz --s subj_1'
    >>> smoother.run() # doctest: +SKIP

    """
    _cmd = ...
    input_spec = SurfaceSmoothInputSpec
    output_spec = SurfaceSmoothOutputSpec


class SurfaceTransformInputSpec(FSTraitedSpec):
    source_file = ...
    source_annot_file = ...
    source_subject = ...
    hemi = ...
    target_subject = ...
    target_ico_order = ...
    source_type = ...
    target_type = ...
    reshape = ...
    reshape_factor = ...
    out_file = ...


class SurfaceTransformOutputSpec(TraitedSpec):
    out_file = ...


class SurfaceTransform(FSCommand):
    """Transform a surface file from one subject to another via a spherical registration.

    Both the source and target subject must reside in your Subjects Directory,
    and they must have been processed with recon-all, unless you are transforming
    to one of the icosahedron meshes.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import SurfaceTransform
    >>> sxfm = SurfaceTransform()
    >>> sxfm.inputs.source_file = "lh.cope1.nii.gz"
    >>> sxfm.inputs.source_subject = "my_subject"
    >>> sxfm.inputs.target_subject = "fsaverage"
    >>> sxfm.inputs.hemi = "lh"
    >>> sxfm.run() # doctest: +SKIP

    """
    _cmd = ...
    input_spec = SurfaceTransformInputSpec
    output_spec = SurfaceTransformOutputSpec


class Surface2VolTransformInputSpec(FSTraitedSpec):
    source_file = ...
    hemi = ...
    transformed_file = ...
    reg_file = ...
    template_file = ...
    mkmask = ...
    vertexvol_file = ...
    surf_name = ...
    projfrac = ...
    subjects_dir = ...
    subject_id = ...


class Surface2VolTransformOutputSpec(TraitedSpec):
    transformed_file = ...
    vertexvol_file = ...


class Surface2VolTransform(FSCommand):
    """Use FreeSurfer mri_surf2vol to apply a transform.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import Surface2VolTransform
    >>> xfm2vol = Surface2VolTransform()
    >>> xfm2vol.inputs.source_file = 'lh.cope1.mgz'
    >>> xfm2vol.inputs.reg_file = 'register.mat'
    >>> xfm2vol.inputs.hemi = 'lh'
    >>> xfm2vol.inputs.template_file = 'cope1.nii.gz'
    >>> xfm2vol.inputs.subjects_dir = '.'
    >>> xfm2vol.cmdline
    'mri_surf2vol --hemi lh --volreg register.mat --surfval lh.cope1.mgz --sd . --template cope1.nii.gz --outvol lh.cope1_asVol.nii --vtxvol lh.cope1_asVol_vertex.nii'
    >>> res = xfm2vol.run()# doctest: +SKIP

    """
    _cmd = ...
    input_spec = Surface2VolTransformInputSpec
    output_spec = Surface2VolTransformOutputSpec


class ApplyMaskInputSpec(FSTraitedSpec):
    in_file = ...
    mask_file = ...
    out_file = ...
    xfm_file = ...
    invert_xfm = ...
    xfm_source = ...
    xfm_target = ...
    use_abs = ...
    mask_thresh = ...
    keep_mask_deletion_edits = ...
    transfer = ...


class ApplyMaskOutputSpec(TraitedSpec):
    out_file = ...


class ApplyMask(FSCommand):
    """Use Freesurfer's mri_mask to apply a mask to an image.

    The mask file need not be binarized; it can be thresholded above a given
    value before application. It can also optionally be transformed into input
    space with an LTA matrix.

    """
    _cmd = ...
    input_spec = ApplyMaskInputSpec
    output_spec = ApplyMaskOutputSpec


class SurfaceSnapshotsInputSpec(FSTraitedSpec):
    subject_id = ...
    hemi = ...
    surface = ...
    show_curv = ...
    show_gray_curv = ...
    overlay = ...
    reg_xors = ...
    overlay_reg = ...
    identity_reg = ...
    mni152_reg = ...
    overlay_range = ...
    overlay_range_offset = ...
    truncate_overlay = ...
    reverse_overlay = ...
    invert_overlay = ...
    demean_overlay = ...
    annot_file = ...
    annot_name = ...
    label_file = ...
    label_name = ...
    colortable = ...
    label_under = ...
    label_outline = ...
    patch_file = ...
    orig_suffix = ...
    sphere_suffix = ...
    show_color_scale = ...
    show_color_text = ...
    six_images = ...
    screenshot_stem = ...
    stem_template_args = ...
    tcl_script = ...


class SurfaceSnapshotsOutputSpec(TraitedSpec):
    snapshots = OutputMultiPath(File(exists=True), desc="tiff images of the surface from different perspectives")


class SurfaceSnapshots(FSCommand):
    """Use Tksurfer to save pictures of the cortical surface.

    By default, this takes snapshots of the lateral, medial, ventral,
    and dorsal surfaces.  See the ``six_images`` option to add the
    anterior and posterior surfaces.

    You may also supply your own tcl script (see the Freesurfer wiki for
    information on scripting tksurfer). The screenshot stem is set as the
    environment variable "_SNAPSHOT_STEM", which you can use in your
    own scripts.

    Node that this interface will not run if you do not have graphics
    enabled on your system.

    Examples
    --------

    >>> import nipype.interfaces.freesurfer as fs
    >>> shots = fs.SurfaceSnapshots(subject_id="fsaverage", hemi="lh", surface="pial")
    >>> shots.inputs.overlay = "zstat1.nii.gz"
    >>> shots.inputs.overlay_range = (2.3, 6)
    >>> shots.inputs.overlay_reg = "register.dat"
    >>> res = shots.run() # doctest: +SKIP

    """
    _cmd = ...
    input_spec = SurfaceSnapshotsInputSpec
    output_spec = SurfaceSnapshotsOutputSpec


class ImageInfoInputSpec(FSTraitedSpec):
    in_file = ...


class ImageInfoOutputSpec(TraitedSpec):
    info = ...
    out_file = ...
    data_type = ...
    file_format = ...
    TE = ...
    TR = ...
    TI = ...
    dimensions = ...
    vox_sizes = ...
    orientation = ...
    ph_enc_dir = ...


class ImageInfo(FSCommand):
    _cmd = ...
    input_spec = ImageInfoInputSpec
    output_spec = ImageInfoOutputSpec
    def info_regexp(self, info, field, delim=...): # -> str | Any | None:
        ...
    
    def aggregate_outputs(self, runtime=..., needed_outputs=...): # -> None:
        ...
    


class MRIsConvertInputSpec(FSTraitedSpec):
    """
    Uses Freesurfer's mris_convert to convert surface files to various formats
    """
    annot_file = ...
    parcstats_file = ...
    label_file = ...
    scalarcurv_file = ...
    functional_file = ...
    labelstats_outfile = ...
    patch = ...
    rescale = ...
    normal = ...
    xyz_ascii = ...
    vertex = ...
    scale = ...
    dataarray_num = ...
    talairachxfm_subjid = ...
    origname = ...
    in_file = ...
    out_file = ...
    out_datatype = ...
    to_scanner = ...
    to_tkr = ...


class MRIsConvertOutputSpec(TraitedSpec):
    """
    Uses Freesurfer's mris_convert to convert surface files to various formats
    """
    converted = ...


class MRIsConvert(FSCommand):
    """
    Uses Freesurfer's mris_convert to convert surface files to various formats

    Example
    -------

    >>> import nipype.interfaces.freesurfer as fs
    >>> mris = fs.MRIsConvert()
    >>> mris.inputs.in_file = 'lh.pial'
    >>> mris.inputs.out_datatype = 'gii'
    >>> mris.run() # doctest: +SKIP
    """
    _cmd = ...
    input_spec = MRIsConvertInputSpec
    output_spec = MRIsConvertOutputSpec


class MRIsCombineInputSpec(FSTraitedSpec):
    """
    Uses Freesurfer's mris_convert to combine two surface files into one.
    """
    in_files = ...
    out_file = ...


class MRIsCombineOutputSpec(TraitedSpec):
    """
    Uses Freesurfer's mris_convert to combine two surface files into one.
    """
    out_file = ...


class MRIsCombine(FSSurfaceCommand):
    """
    Uses Freesurfer's ``mris_convert`` to combine two surface files into one.

    For complete details, see the `mris_convert Documentation.
    <https://surfer.nmr.mgh.harvard.edu/fswiki/mris_convert>`_

    If given an ``out_file`` that does not begin with ``'lh.'`` or ``'rh.'``,
    ``mris_convert`` will prepend ``'lh.'`` to the file name.
    To avoid this behavior, consider setting ``out_file = './<filename>'``, or
    leaving out_file blank.

    In a Node/Workflow, ``out_file`` is interpreted literally.

    Example
    -------

    >>> import nipype.interfaces.freesurfer as fs
    >>> mris = fs.MRIsCombine()
    >>> mris.inputs.in_files = ['lh.pial', 'rh.pial']
    >>> mris.inputs.out_file = 'bh.pial'
    >>> mris.cmdline
    'mris_convert --combinesurfs lh.pial rh.pial bh.pial'
    >>> mris.run()  # doctest: +SKIP
    """
    _cmd = ...
    input_spec = MRIsCombineInputSpec
    output_spec = MRIsCombineOutputSpec
    def normalize_filenames(self): # -> None:
        """
        Filename normalization routine to perform only when run in Node
        context.
        Interpret out_file as a literal path to reduce surprise.
        """
        ...
    


class MRITessellateInputSpec(FSTraitedSpec):
    """
    Uses Freesurfer's mri_tessellate to create surfaces by tessellating a given input volume
    """
    in_file = ...
    label_value = ...
    out_file = ...
    tesselate_all_voxels = ...
    use_real_RAS_coordinates = ...


class MRITessellateOutputSpec(TraitedSpec):
    """
    Uses Freesurfer's mri_tessellate to create surfaces by tessellating a given input volume
    """
    surface = ...


class MRITessellate(FSCommand):
    """
    Uses Freesurfer's mri_tessellate to create surfaces by tessellating a given input volume

    Example
    -------

    >>> import nipype.interfaces.freesurfer as fs
    >>> tess = fs.MRITessellate()
    >>> tess.inputs.in_file = 'aseg.mgz'
    >>> tess.inputs.label_value = 17
    >>> tess.inputs.out_file = 'lh.hippocampus'
    >>> tess.run() # doctest: +SKIP
    """
    _cmd = ...
    input_spec = MRITessellateInputSpec
    output_spec = MRITessellateOutputSpec


class MRIPretessInputSpec(FSTraitedSpec):
    in_filled = ...
    label = ...
    in_norm = ...
    out_file = ...
    nocorners = ...
    keep = ...
    test = ...


class MRIPretessOutputSpec(TraitedSpec):
    out_file = ...


class MRIPretess(FSCommand):
    """
    Uses Freesurfer's mri_pretess to prepare volumes to be tessellated.

    Changes white matter (WM) segmentation so that the neighbors of all
    voxels labeled as WM have a face in common - no edges or corners
    allowed.

    Example
    -------
    >>> import nipype.interfaces.freesurfer as fs
    >>> pretess = fs.MRIPretess()
    >>> pretess.inputs.in_filled = 'wm.mgz'
    >>> pretess.inputs.in_norm = 'norm.mgz'
    >>> pretess.inputs.nocorners = True
    >>> pretess.cmdline
    'mri_pretess -nocorners wm.mgz wm norm.mgz wm_pretesswm.mgz'
    >>> pretess.run() # doctest: +SKIP

    """
    _cmd = ...
    input_spec = MRIPretessInputSpec
    output_spec = MRIPretessOutputSpec


class MRIMarchingCubesInputSpec(FSTraitedSpec):
    """
    Uses Freesurfer's mri_mc to create surfaces by tessellating a given input volume
    """
    in_file = ...
    label_value = ...
    connectivity_value = ...
    out_file = ...


class MRIMarchingCubesOutputSpec(TraitedSpec):
    """
    Uses Freesurfer's mri_mc to create surfaces by tessellating a given input volume
    """
    surface = ...


class MRIMarchingCubes(FSCommand):
    """
    Uses Freesurfer's mri_mc to create surfaces by tessellating a given input volume

    Example
    -------

    >>> import nipype.interfaces.freesurfer as fs
    >>> mc = fs.MRIMarchingCubes()
    >>> mc.inputs.in_file = 'aseg.mgz'
    >>> mc.inputs.label_value = 17
    >>> mc.inputs.out_file = 'lh.hippocampus'
    >>> mc.run() # doctest: +SKIP
    """
    _cmd = ...
    input_spec = MRIMarchingCubesInputSpec
    output_spec = MRIMarchingCubesOutputSpec


class SmoothTessellationInputSpec(FSTraitedSpec):
    in_file = ...
    curvature_averaging_iterations = ...
    smoothing_iterations = ...
    snapshot_writing_iterations = ...
    use_gaussian_curvature_smoothing = ...
    gaussian_curvature_norm_steps = ...
    gaussian_curvature_smoothing_steps = ...
    disable_estimates = ...
    normalize_area = ...
    use_momentum = ...
    out_file = ...
    out_curvature_file = ...
    out_area_file = ...
    seed = ...


class SmoothTessellationOutputSpec(TraitedSpec):
    """
    This program smooths the tessellation of a surface using 'mris_smooth'
    """
    surface = ...


class SmoothTessellation(FSCommand):
    """
    Smooth a tessellated surface.

    See Also
    --------
    `nipype.interfaces.freesurfer.utils.SurfaceSmooth`_ interface for smoothing a scalar field
    along a surface manifold

    Example
    -------
    >>> import nipype.interfaces.freesurfer as fs
    >>> smooth = fs.SmoothTessellation()
    >>> smooth.inputs.in_file = 'lh.hippocampus.stl'
    >>> smooth.run() # doctest: +SKIP

    """
    _cmd = ...
    input_spec = SmoothTessellationInputSpec
    output_spec = SmoothTessellationOutputSpec


class MakeAverageSubjectInputSpec(FSTraitedSpec):
    subjects_ids = ...
    out_name = ...


class MakeAverageSubjectOutputSpec(TraitedSpec):
    average_subject_name = ...


class MakeAverageSubject(FSCommand):
    """Make an average freesurfer subject

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import MakeAverageSubject
    >>> avg = MakeAverageSubject(subjects_ids=['s1', 's2'])
    >>> avg.cmdline
    'make_average_subject --out average --subjects s1 s2'

    """
    _cmd = ...
    input_spec = MakeAverageSubjectInputSpec
    output_spec = MakeAverageSubjectOutputSpec


class ExtractMainComponentInputSpec(CommandLineInputSpec):
    in_file = ...
    out_file = ...


class ExtractMainComponentOutputSpec(TraitedSpec):
    out_file = ...


class ExtractMainComponent(CommandLine):
    """Extract the main component of a tessellated surface

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import ExtractMainComponent
    >>> mcmp = ExtractMainComponent(in_file='lh.pial')
    >>> mcmp.cmdline
    'mris_extract_main_component lh.pial lh.maincmp'

    """
    _cmd = ...
    input_spec = ExtractMainComponentInputSpec
    output_spec = ExtractMainComponentOutputSpec


class Tkregister2InputSpec(FSTraitedSpec):
    target_image = ...
    fstarg = ...
    moving_image = ...
    fsl_in_matrix = ...
    xfm = ...
    lta_in = ...
    invert_lta_in = ...
    fsl_out = ...
    lta_out = ...
    invert_lta_out = ...
    subject_id = ...
    noedit = ...
    reg_file = ...
    reg_header = ...
    fstal = ...
    movscale = ...


class Tkregister2OutputSpec(TraitedSpec):
    reg_file = ...
    fsl_file = ...
    lta_file = ...


class Tkregister2(FSCommand):
    """

    Examples
    --------
    Get transform matrix between orig (*tkRAS*) and native (*scannerRAS*)
    coordinates in Freesurfer. Implements the first step of mapping surfaces
    to native space in `this guide
    <http://surfer.nmr.mgh.harvard.edu/fswiki/FsAnat-to-NativeAnat>`__.

    >>> from nipype.interfaces.freesurfer import Tkregister2
    >>> tk2 = Tkregister2(reg_file='T1_to_native.dat')
    >>> tk2.inputs.moving_image = 'T1.mgz'
    >>> tk2.inputs.target_image = 'structural.nii'
    >>> tk2.inputs.reg_header = True
    >>> tk2.cmdline
    'tkregister2 --mov T1.mgz --noedit --reg T1_to_native.dat --regheader \
--targ structural.nii'
    >>> tk2.run() # doctest: +SKIP

    The example below uses tkregister2 without the manual editing
    stage to convert FSL-style registration matrix (.mat) to
    FreeSurfer-style registration matrix (.dat)

    >>> from nipype.interfaces.freesurfer import Tkregister2
    >>> tk2 = Tkregister2()
    >>> tk2.inputs.moving_image = 'epi.nii'
    >>> tk2.inputs.fsl_in_matrix = 'flirt.mat'
    >>> tk2.cmdline
    'tkregister2 --fsl flirt.mat --mov epi.nii --noedit --reg register.dat'
    >>> tk2.run() # doctest: +SKIP
    """
    _cmd = ...
    input_spec = Tkregister2InputSpec
    output_spec = Tkregister2OutputSpec


class AddXFormToHeaderInputSpec(FSTraitedSpec):
    in_file = ...
    transform = ...
    out_file = ...
    copy_name = ...
    verbose = ...


class AddXFormToHeaderOutputSpec(TraitedSpec):
    out_file = ...


class AddXFormToHeader(FSCommand):
    """
    Just adds specified xform to the volume header.

    .. danger ::

        Input transform **MUST** be an absolute path to a DataSink'ed transform or
        the output will reference a transform in the workflow cache directory!

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import AddXFormToHeader
    >>> adder = AddXFormToHeader()
    >>> adder.inputs.in_file = 'norm.mgz'
    >>> adder.inputs.transform = 'trans.mat'
    >>> adder.cmdline
    'mri_add_xform_to_header trans.mat norm.mgz output.mgz'

    >>> adder.inputs.copy_name = True
    >>> adder.cmdline
    'mri_add_xform_to_header -c trans.mat norm.mgz output.mgz'
    >>> adder.run()   # doctest: +SKIP

    References
    ----------
    [https://surfer.nmr.mgh.harvard.edu/fswiki/mri_add_xform_to_header]

    """
    _cmd = ...
    input_spec = AddXFormToHeaderInputSpec
    output_spec = AddXFormToHeaderOutputSpec


class CheckTalairachAlignmentInputSpec(FSTraitedSpec):
    in_file = ...
    subject = ...
    threshold = ...


class CheckTalairachAlignmentOutputSpec(TraitedSpec):
    out_file = ...


class CheckTalairachAlignment(FSCommand):
    """
    This program detects Talairach alignment failures

    Examples
    ========

    >>> from nipype.interfaces.freesurfer import CheckTalairachAlignment
    >>> checker = CheckTalairachAlignment()

    >>> checker.inputs.in_file = 'trans.mat'
    >>> checker.inputs.threshold = 0.005
    >>> checker.cmdline
    'talairach_afd -T 0.005 -xfm trans.mat'

    >>> checker.run() # doctest: +SKIP
    """
    _cmd = ...
    input_spec = CheckTalairachAlignmentInputSpec
    output_spec = CheckTalairachAlignmentOutputSpec


class TalairachAVIInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    atlas = ...


class TalairachAVIOutputSpec(TraitedSpec):
    out_file = ...
    out_log = ...
    out_txt = ...


class TalairachAVI(FSCommand):
    """
    Front-end for Avi Snyders image registration tool. Computes the
    talairach transform that maps the input volume to the MNI average_305.
    This does not add the xfm to the header of the input file. When called
    by recon-all, the xfm is added to the header after the transform is
    computed.

    Examples
    ========

    >>> from nipype.interfaces.freesurfer import TalairachAVI
    >>> example = TalairachAVI()
    >>> example.inputs.in_file = 'norm.mgz'
    >>> example.inputs.out_file = 'trans.mat'
    >>> example.cmdline
    'talairach_avi --i norm.mgz --xfm trans.mat'

    >>> example.run() # doctest: +SKIP
    """
    _cmd = ...
    input_spec = TalairachAVIInputSpec
    output_spec = TalairachAVIOutputSpec


class TalairachQCInputSpec(FSTraitedSpec):
    log_file = ...


class TalairachQC(FSScriptCommand):
    """
    Examples
    ========

    >>> from nipype.interfaces.freesurfer import TalairachQC
    >>> qc = TalairachQC()
    >>> qc.inputs.log_file = 'dirs.txt'
    >>> qc.cmdline
    'tal_QC_AZS dirs.txt'
    """
    _cmd = ...
    input_spec = TalairachQCInputSpec
    output_spec = FSScriptOutputSpec


class RemoveNeckInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    transform = ...
    template = ...
    radius = ...


class RemoveNeckOutputSpec(TraitedSpec):
    out_file = ...


class RemoveNeck(FSCommand):
    """
    Crops the neck out of the mri image

    Examples
    ========

    >>> from nipype.interfaces.freesurfer import TalairachQC
    >>> remove_neck = RemoveNeck()
    >>> remove_neck.inputs.in_file = 'norm.mgz'
    >>> remove_neck.inputs.transform = 'trans.mat'
    >>> remove_neck.inputs.template = 'trans.mat'
    >>> remove_neck.cmdline
    'mri_remove_neck norm.mgz trans.mat trans.mat norm_noneck.mgz'
    """
    _cmd = ...
    input_spec = RemoveNeckInputSpec
    output_spec = RemoveNeckOutputSpec


class MRIFillInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    segmentation = ...
    transform = ...
    log_file = ...


class MRIFillOutputSpec(TraitedSpec):
    out_file = ...
    log_file = ...


class MRIFill(FSCommand):
    """
    This program creates hemispheric cutting planes and fills white matter
    with specific values for subsequent surface tessellation.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import MRIFill
    >>> fill = MRIFill()
    >>> fill.inputs.in_file = 'wm.mgz' # doctest: +SKIP
    >>> fill.inputs.out_file = 'filled.mgz' # doctest: +SKIP
    >>> fill.cmdline # doctest: +SKIP
    'mri_fill wm.mgz filled.mgz'
    """
    _cmd = ...
    input_spec = MRIFillInputSpec
    output_spec = MRIFillOutputSpec


class MRIsInflateInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    out_sulc = ...
    no_save_sulc = ...


class MRIsInflateOutputSpec(TraitedSpec):
    out_file = ...
    out_sulc = ...


class MRIsInflate(FSCommand):
    """
    This program will inflate a cortical surface.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import MRIsInflate
    >>> inflate = MRIsInflate()
    >>> inflate.inputs.in_file = 'lh.pial'
    >>> inflate.inputs.no_save_sulc = True
    >>> inflate.cmdline # doctest: +SKIP
    'mris_inflate -no-save-sulc lh.pial lh.inflated'
    """
    _cmd = ...
    input_spec = MRIsInflateInputSpec
    output_spec = MRIsInflateOutputSpec


class SphereInputSpec(FSTraitedSpecOpenMP):
    in_file = ...
    out_file = ...
    seed = ...
    magic = ...
    in_smoothwm = ...


class SphereOutputSpec(TraitedSpec):
    out_file = ...


class Sphere(FSCommandOpenMP):
    """
    This program will add a template into an average surface

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import Sphere
    >>> sphere = Sphere()
    >>> sphere.inputs.in_file = 'lh.pial'
    >>> sphere.cmdline
    'mris_sphere lh.pial lh.sphere'
    """
    _cmd = ...
    input_spec = SphereInputSpec
    output_spec = SphereOutputSpec


class FixTopologyInputSpec(FSTraitedSpec):
    in_orig = ...
    in_inflated = ...
    in_brain = ...
    in_wm = ...
    hemisphere = ...
    subject_id = ...
    copy_inputs = ...
    seed = ...
    ga = ...
    mgz = ...
    sphere = ...


class FixTopologyOutputSpec(TraitedSpec):
    out_file = ...


class FixTopology(FSCommand):
    """
    This program computes a mapping from the unit sphere onto the surface
    of the cortex from a previously generated approximation of the
    cortical surface, thus guaranteeing a topologically correct surface.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import FixTopology
    >>> ft = FixTopology()
    >>> ft.inputs.in_orig = 'lh.orig' # doctest: +SKIP
    >>> ft.inputs.in_inflated = 'lh.inflated' # doctest: +SKIP
    >>> ft.inputs.sphere = 'lh.qsphere.nofix' # doctest: +SKIP
    >>> ft.inputs.hemisphere = 'lh'
    >>> ft.inputs.subject_id = '10335'
    >>> ft.inputs.mgz = True
    >>> ft.inputs.ga = True
    >>> ft.cmdline # doctest: +SKIP
    'mris_fix_topology -ga -mgz -sphere qsphere.nofix 10335 lh'
    """
    _cmd = ...
    input_spec = FixTopologyInputSpec
    output_spec = FixTopologyOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class EulerNumberInputSpec(FSTraitedSpec):
    in_file = ...


class EulerNumberOutputSpec(TraitedSpec):
    euler = ...
    defects = ...


class EulerNumber(FSCommand):
    """
    This program computes EulerNumber for a cortical surface

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import EulerNumber
    >>> ft = EulerNumber()
    >>> ft.inputs.in_file = 'lh.pial'
    >>> ft.cmdline
    'mris_euler_number lh.pial'
    """
    _cmd = ...
    input_spec = EulerNumberInputSpec
    output_spec = EulerNumberOutputSpec


class RemoveIntersectionInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...


class RemoveIntersectionOutputSpec(TraitedSpec):
    out_file = ...


class RemoveIntersection(FSCommand):
    """
    This program removes the intersection of the given MRI

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import RemoveIntersection
    >>> ri = RemoveIntersection()
    >>> ri.inputs.in_file = 'lh.pial'
    >>> ri.cmdline
    'mris_remove_intersection lh.pial lh.pial'
    """
    _cmd = ...
    input_spec = RemoveIntersectionInputSpec
    output_spec = RemoveIntersectionOutputSpec


class MakeSurfacesInputSpec(FSTraitedSpec):
    hemisphere = ...
    subject_id = ...
    in_orig = ...
    in_wm = ...
    in_filled = ...
    in_white = ...
    in_label = ...
    orig_white = ...
    orig_pial = ...
    fix_mtl = ...
    no_white = ...
    white_only = ...
    in_aseg = ...
    in_T1 = ...
    mgz = ...
    noaparc = ...
    maximum = ...
    longitudinal = ...
    white = ...
    copy_inputs = ...


class MakeSurfacesOutputSpec(TraitedSpec):
    out_white = ...
    out_curv = ...
    out_area = ...
    out_cortex = ...
    out_pial = ...
    out_thickness = ...


class MakeSurfaces(FSCommand):
    """
    This program positions the tessellation of the cortical surface at the
    white matter surface, then the gray matter surface and generate
    surface files for these surfaces as well as a 'curvature' file for the
    cortical thickness, and a surface file which approximates layer IV of
    the cortical sheet.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import MakeSurfaces
    >>> makesurfaces = MakeSurfaces()
    >>> makesurfaces.inputs.hemisphere = 'lh'
    >>> makesurfaces.inputs.subject_id = '10335'
    >>> makesurfaces.inputs.in_orig = 'lh.pial'
    >>> makesurfaces.inputs.in_wm = 'wm.mgz'
    >>> makesurfaces.inputs.in_filled = 'norm.mgz'
    >>> makesurfaces.inputs.in_label = 'aparc+aseg.nii'
    >>> makesurfaces.inputs.in_T1 = 'T1.mgz'
    >>> makesurfaces.inputs.orig_pial = 'lh.pial'
    >>> makesurfaces.cmdline
    'mris_make_surfaces -T1 T1.mgz -orig pial -orig_pial pial 10335 lh'
    """
    _cmd = ...
    input_spec = MakeSurfacesInputSpec
    output_spec = MakeSurfacesOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class CurvatureInputSpec(FSTraitedSpec):
    in_file = ...
    threshold = ...
    n = ...
    averages = ...
    save = ...
    distances = ...
    copy_input = ...


class CurvatureOutputSpec(TraitedSpec):
    out_mean = ...
    out_gauss = ...


class Curvature(FSCommand):
    """
    This program will compute the second fundamental form of a cortical
    surface. It will create two new files <hemi>.<surface>.H and
    <hemi>.<surface>.K with the mean and Gaussian curvature respectively.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import Curvature
    >>> curv = Curvature()
    >>> curv.inputs.in_file = 'lh.pial'
    >>> curv.inputs.save = True
    >>> curv.cmdline
    'mris_curvature -w lh.pial'
    """
    _cmd = ...
    input_spec = CurvatureInputSpec
    output_spec = CurvatureOutputSpec


class CurvatureStatsInputSpec(FSTraitedSpec):
    surface = ...
    curvfile1 = ...
    curvfile2 = ...
    hemisphere = ...
    subject_id = ...
    out_file = ...
    min_max = ...
    values = ...
    write = ...
    copy_inputs = ...


class CurvatureStatsOutputSpec(TraitedSpec):
    out_file = ...


class CurvatureStats(FSCommand):
    """
    In its simplest usage, 'mris_curvature_stats' will compute a set
    of statistics on its input <curvFile>. These statistics are the
    mean and standard deviation of the particular curvature on the
    surface, as well as the results from several surface-based
    integrals.

    Additionally, 'mris_curvature_stats' can report the max/min
    curvature values, and compute a simple histogram based on
    all curvature values.

    Curvatures can also be normalised and constrained to a given
    range before computation.

    Principal curvature (K, H, k1 and k2) calculations on a surface
    structure can also be performed, as well as several functions
    derived from k1 and k2.

    Finally, all output to the console, as well as any new
    curvatures that result from the above calculations can be
    saved to a series of text and binary-curvature files.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import CurvatureStats
    >>> curvstats = CurvatureStats()
    >>> curvstats.inputs.hemisphere = 'lh'
    >>> curvstats.inputs.curvfile1 = 'lh.pial'
    >>> curvstats.inputs.curvfile2 = 'lh.pial'
    >>> curvstats.inputs.surface = 'lh.pial'
    >>> curvstats.inputs.out_file = 'lh.curv.stats'
    >>> curvstats.inputs.values = True
    >>> curvstats.inputs.min_max = True
    >>> curvstats.inputs.write = True
    >>> curvstats.cmdline
    'mris_curvature_stats -m -o lh.curv.stats -F pial -G --writeCurvatureFiles subject_id lh pial pial'
    """
    _cmd = ...
    input_spec = CurvatureStatsInputSpec
    output_spec = CurvatureStatsOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class JacobianInputSpec(FSTraitedSpec):
    in_origsurf = ...
    in_mappedsurf = ...
    out_file = ...


class JacobianOutputSpec(TraitedSpec):
    out_file = ...


class Jacobian(FSCommand):
    """
    This program computes the Jacobian of a surface mapping.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import Jacobian
    >>> jacobian = Jacobian()
    >>> jacobian.inputs.in_origsurf = 'lh.pial'
    >>> jacobian.inputs.in_mappedsurf = 'lh.pial'
    >>> jacobian.cmdline
    'mris_jacobian lh.pial lh.pial lh.jacobian'
    """
    _cmd = ...
    input_spec = JacobianInputSpec
    output_spec = JacobianOutputSpec


class MRIsCalcInputSpec(FSTraitedSpec):
    in_file1 = ...
    action = ...
    out_file = ...
    in_file2 = ...
    in_float = ...
    in_int = ...


class MRIsCalcOutputSpec(TraitedSpec):
    out_file = ...


class MRIsCalc(FSCommand):
    """
    'mris_calc' is a simple calculator that operates on FreeSurfer
    curvatures and volumes. In most cases, the calculator functions with
    three arguments: two inputs and an <ACTION> linking them. Some
    actions, however, operate with only one input <file1>. In all cases,
    the first input <file1> is the name of a FreeSurfer curvature overlay
    (e.g. rh.curv) or volume file (e.g. orig.mgz). For two inputs, the
    calculator first assumes that the second input is a file. If, however,
    this second input file doesn't exist, the calculator assumes it refers
    to a float number, which is then processed according to <ACTION>.Note:
    <file1> and <file2> should typically be generated on the same subject.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import MRIsCalc
    >>> example = MRIsCalc()
    >>> example.inputs.in_file1 = 'lh.area' # doctest: +SKIP
    >>> example.inputs.in_file2 = 'lh.area.pial' # doctest: +SKIP
    >>> example.inputs.action = 'add'
    >>> example.inputs.out_file = 'area.mid'
    >>> example.cmdline # doctest: +SKIP
    'mris_calc -o lh.area.mid lh.area add lh.area.pial'
    """
    _cmd = ...
    input_spec = MRIsCalcInputSpec
    output_spec = MRIsCalcOutputSpec


class VolumeMaskInputSpec(FSTraitedSpec):
    left_whitelabel = ...
    left_ribbonlabel = ...
    right_whitelabel = ...
    right_ribbonlabel = ...
    lh_pial = ...
    rh_pial = ...
    lh_white = ...
    rh_white = ...
    aseg = ...
    subject_id = ...
    in_aseg = ...
    save_ribbon = ...
    copy_inputs = ...


class VolumeMaskOutputSpec(TraitedSpec):
    out_ribbon = ...
    lh_ribbon = ...
    rh_ribbon = ...


class VolumeMask(FSCommand):
    """
    Computes a volume mask, at the same resolution as the
    <subject>/mri/brain.mgz.  The volume mask contains 4 values: LH_WM
    (default 10), LH_GM (default 100), RH_WM (default 20), RH_GM (default
    200).
    The algorithm uses the 4 surfaces situated in <subject>/surf/
    [lh|rh].[white|pial] and labels voxels based on the
    signed-distance function from the surface.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import VolumeMask
    >>> volmask = VolumeMask()
    >>> volmask.inputs.left_whitelabel = 2
    >>> volmask.inputs.left_ribbonlabel = 3
    >>> volmask.inputs.right_whitelabel = 41
    >>> volmask.inputs.right_ribbonlabel = 42
    >>> volmask.inputs.lh_pial = 'lh.pial'
    >>> volmask.inputs.rh_pial = 'lh.pial'
    >>> volmask.inputs.lh_white = 'lh.pial'
    >>> volmask.inputs.rh_white = 'lh.pial'
    >>> volmask.inputs.subject_id = '10335'
    >>> volmask.inputs.save_ribbon = True
    >>> volmask.cmdline
    'mris_volmask --label_left_ribbon 3 --label_left_white 2 --label_right_ribbon 42 --label_right_white 41 --save_ribbon 10335'
    """
    _cmd = ...
    input_spec = VolumeMaskInputSpec
    output_spec = VolumeMaskOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class ParcellationStatsInputSpec(FSTraitedSpec):
    subject_id = ...
    hemisphere = ...
    wm = ...
    lh_white = ...
    rh_white = ...
    lh_pial = ...
    rh_pial = ...
    transform = ...
    thickness = ...
    brainmask = ...
    aseg = ...
    ribbon = ...
    cortex_label = ...
    surface = ...
    mgz = ...
    in_cortex = ...
    in_annotation = ...
    in_label = ...
    tabular_output = ...
    out_table = ...
    out_color = ...
    copy_inputs = ...
    th3 = ...


class ParcellationStatsOutputSpec(TraitedSpec):
    out_table = ...
    out_color = ...


class ParcellationStats(FSCommand):
    """
    This program computes a number of anatomical properties.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import ParcellationStats
    >>> import os
    >>> parcstats = ParcellationStats()
    >>> parcstats.inputs.subject_id = '10335'
    >>> parcstats.inputs.hemisphere = 'lh'
    >>> parcstats.inputs.wm = './../mri/wm.mgz' # doctest: +SKIP
    >>> parcstats.inputs.transform = './../mri/transforms/talairach.xfm' # doctest: +SKIP
    >>> parcstats.inputs.brainmask = './../mri/brainmask.mgz' # doctest: +SKIP
    >>> parcstats.inputs.aseg = './../mri/aseg.presurf.mgz' # doctest: +SKIP
    >>> parcstats.inputs.ribbon = './../mri/ribbon.mgz' # doctest: +SKIP
    >>> parcstats.inputs.lh_pial = 'lh.pial' # doctest: +SKIP
    >>> parcstats.inputs.rh_pial = 'lh.pial' # doctest: +SKIP
    >>> parcstats.inputs.lh_white = 'lh.white' # doctest: +SKIP
    >>> parcstats.inputs.rh_white = 'rh.white' # doctest: +SKIP
    >>> parcstats.inputs.thickness = 'lh.thickness' # doctest: +SKIP
    >>> parcstats.inputs.surface = 'white'
    >>> parcstats.inputs.out_table = 'lh.test.stats'
    >>> parcstats.inputs.out_color = 'test.ctab'
    >>> parcstats.cmdline # doctest: +SKIP
    'mris_anatomical_stats -c test.ctab -f lh.test.stats 10335 lh white'
    """
    _cmd = ...
    input_spec = ParcellationStatsInputSpec
    output_spec = ParcellationStatsOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class ContrastInputSpec(FSTraitedSpec):
    subject_id = ...
    hemisphere = ...
    thickness = ...
    white = ...
    annotation = ...
    cortex = ...
    orig = ...
    rawavg = ...
    copy_inputs = ...


class ContrastOutputSpec(TraitedSpec):
    out_contrast = ...
    out_stats = ...
    out_log = ...


class Contrast(FSCommand):
    """
    Compute surface-wise gray/white contrast

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import Contrast
    >>> contrast = Contrast()
    >>> contrast.inputs.subject_id = '10335'
    >>> contrast.inputs.hemisphere = 'lh'
    >>> contrast.inputs.white = 'lh.white' # doctest: +SKIP
    >>> contrast.inputs.thickness = 'lh.thickness' # doctest: +SKIP
    >>> contrast.inputs.annotation = '../label/lh.aparc.annot' # doctest: +SKIP
    >>> contrast.inputs.cortex = '../label/lh.cortex.label' # doctest: +SKIP
    >>> contrast.inputs.rawavg = '../mri/rawavg.mgz' # doctest: +SKIP
    >>> contrast.inputs.orig = '../mri/orig.mgz' # doctest: +SKIP
    >>> contrast.cmdline # doctest: +SKIP
    'pctsurfcon --lh-only --s 10335'
    """
    _cmd = ...
    input_spec = ContrastInputSpec
    output_spec = ContrastOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class RelabelHypointensitiesInputSpec(FSTraitedSpec):
    lh_white = ...
    rh_white = ...
    aseg = ...
    surf_directory = ...
    out_file = ...


class RelabelHypointensitiesOutputSpec(TraitedSpec):
    out_file = ...


class RelabelHypointensities(FSCommand):
    """
    Relabel Hypointensities

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import RelabelHypointensities
    >>> relabelhypos = RelabelHypointensities()
    >>> relabelhypos.inputs.lh_white = 'lh.pial'
    >>> relabelhypos.inputs.rh_white = 'lh.pial'
    >>> relabelhypos.inputs.surf_directory = '.'
    >>> relabelhypos.inputs.aseg = 'aseg.mgz'
    >>> relabelhypos.cmdline
    'mri_relabel_hypointensities aseg.mgz . aseg.hypos.mgz'
    """
    _cmd = ...
    input_spec = RelabelHypointensitiesInputSpec
    output_spec = RelabelHypointensitiesOutputSpec


class Aparc2AsegInputSpec(FSTraitedSpec):
    subject_id = ...
    out_file = ...
    lh_white = ...
    rh_white = ...
    lh_pial = ...
    rh_pial = ...
    lh_ribbon = ...
    rh_ribbon = ...
    ribbon = ...
    lh_annotation = ...
    rh_annotation = ...
    filled = ...
    aseg = ...
    volmask = ...
    ctxseg = ...
    label_wm = ...
    hypo_wm = ...
    rip_unknown = ...
    a2009s = ...
    copy_inputs = ...


class Aparc2AsegOutputSpec(TraitedSpec):
    out_file = ...


class Aparc2Aseg(FSCommand):
    """
    Maps the cortical labels from the automatic cortical parcellation
    (aparc) to the automatic segmentation volume (aseg). The result can be
    used as the aseg would. The algorithm is to find each aseg voxel
    labeled as cortex (3 and 42) and assign it the label of the closest
    cortical vertex. If the voxel is not in the ribbon (as defined by mri/
    lh.ribbon and rh.ribbon), then the voxel is marked as unknown (0).
    This can be turned off with ``--noribbon``. The cortical parcellation is
    obtained from subject/label/hemi.aparc.annot which should be based on
    the curvature.buckner40.filled.desikan_killiany.gcs atlas. The aseg is
    obtained from subject/mri/aseg.mgz and should be based on the
    RB40_talairach_2005-07-20.gca atlas. If these atlases are used, then the
    segmentations can be viewed with tkmedit and the
    FreeSurferColorLUT.txt color table found in ``$FREESURFER_HOME``. These
    are the default atlases used by ``recon-all``.

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import Aparc2Aseg
    >>> aparc2aseg = Aparc2Aseg()
    >>> aparc2aseg.inputs.lh_white = 'lh.pial'
    >>> aparc2aseg.inputs.rh_white = 'lh.pial'
    >>> aparc2aseg.inputs.lh_pial = 'lh.pial'
    >>> aparc2aseg.inputs.rh_pial = 'lh.pial'
    >>> aparc2aseg.inputs.lh_ribbon = 'label.mgz'
    >>> aparc2aseg.inputs.rh_ribbon = 'label.mgz'
    >>> aparc2aseg.inputs.ribbon = 'label.mgz'
    >>> aparc2aseg.inputs.lh_annotation = 'lh.pial'
    >>> aparc2aseg.inputs.rh_annotation = 'lh.pial'
    >>> aparc2aseg.inputs.out_file = 'aparc+aseg.mgz'
    >>> aparc2aseg.inputs.label_wm = True
    >>> aparc2aseg.inputs.rip_unknown = True
    >>> aparc2aseg.cmdline # doctest: +SKIP
    'mri_aparc2aseg --labelwm  --o aparc+aseg.mgz --rip-unknown --s subject_id'

    """
    _cmd = ...
    input_spec = Aparc2AsegInputSpec
    output_spec = Aparc2AsegOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class Apas2AsegInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...


class Apas2AsegOutputSpec(TraitedSpec):
    out_file = ...


class Apas2Aseg(FSCommand):
    """
    Converts aparc+aseg.mgz into something like aseg.mgz by replacing the
    cortical segmentations 1000-1035 with 3 and 2000-2035 with 42. The
    advantage of this output is that the cortical label conforms to the
    actual surface (this is not the case with aseg.mgz).

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import Apas2Aseg
    >>> apas2aseg = Apas2Aseg()
    >>> apas2aseg.inputs.in_file = 'aseg.mgz'
    >>> apas2aseg.inputs.out_file = 'output.mgz'
    >>> apas2aseg.cmdline
    'apas2aseg --i aseg.mgz --o output.mgz'

    """
    _cmd = ...
    input_spec = Apas2AsegInputSpec
    output_spec = Apas2AsegOutputSpec


class MRIsExpandInputSpec(FSTraitedSpec):
    in_file = ...
    distance = ...
    out_name = ...
    thickness = ...
    thickness_name = ...
    pial = ...
    sphere = ...
    spring = ...
    dt = ...
    write_iterations = ...
    smooth_averages = ...
    nsurfaces = ...


class MRIsExpandOutputSpec(TraitedSpec):
    out_file = ...


class MRIsExpand(FSSurfaceCommand):
    """
    Expands a surface (typically ?h.white) outwards while maintaining
    smoothness and self-intersection constraints.

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import MRIsExpand
    >>> mris_expand = MRIsExpand(thickness=True, distance=0.5)
    >>> mris_expand.inputs.in_file = 'lh.white'
    >>> mris_expand.cmdline
    'mris_expand -thickness lh.white 0.5 expanded'
    >>> mris_expand.inputs.out_name = 'graymid'
    >>> mris_expand.cmdline
    'mris_expand -thickness lh.white 0.5 graymid'
    """
    _cmd = ...
    input_spec = MRIsExpandInputSpec
    output_spec = MRIsExpandOutputSpec
    def normalize_filenames(self): # -> None:
        """
        Filename normalization routine to perform only when run in Node
        context.
        Find full paths for pial, thickness and sphere files for copying.
        """
        ...
    


class LTAConvertInputSpec(CommandLineInputSpec):
    _in_xor = ...
    in_lta = ...
    in_fsl = ...
    in_mni = ...
    in_reg = ...
    in_niftyreg = ...
    in_itk = ...
    out_lta = ...
    out_fsl = ...
    out_mni = ...
    out_reg = ...
    out_itk = ...
    invert = ...
    ltavox2vox = ...
    source_file = ...
    target_file = ...
    target_conform = ...


class LTAConvertOutputSpec(TraitedSpec):
    out_lta = ...
    out_fsl = ...
    out_mni = ...
    out_reg = ...
    out_itk = ...


class LTAConvert(CommandLine):
    """Convert different transformation formats.
    Some formats may require you to pass an image if the geometry information
    is missing form the transform file format.

    For complete details, see the `lta_convert documentation.
    <https://ftp.nmr.mgh.harvard.edu/pub/docs/html/lta_convert.help.xml.html>`_
    """
    input_spec = LTAConvertInputSpec
    output_spec = LTAConvertOutputSpec
    _cmd = ...



function [trkEP_full,trk_len_full,trk_type_full]=conversion_tt(pathToFile, type)
% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS

% load tt file generated by dsi studio
close all;
restoredefaultpath;
gcp;
addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));
addpath('toolboxes/FieldTrip');
ft_defaults;
ft_hastoolbox('gifti',1);
ft_hastoolbox('iso2mesh',1);
ft_hastoolbox('freesurfer',1);
disp('step1: performing conversion from .trk to surface and atlas')
disp(['Type: ' num2str(type) ' (' class(type) ')'])


%atlas image generated by FreeSurfer.
atlas=ft_read_mri([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);


if(exist([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz'],'file'))
    % trackImg generated by DSI Studio (.tt.nii.gz) - saved in aparc+aseg.nii.gz
    % space. Note there is also a .trk file that this file relies on for
    % computations. trackImg is optional for visualisation purposes.
    trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);
end

if type==1
    atlasCRSToTkRAS = atlas.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
elseif type==2
    atlasCRSToTkRAS = atlas.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
else
    disp('wrong type of surface')
end


% To generate register.dat
% tkregister2 --mov [dsi-studio root]/atlas/ICBM152_adult/ICBM152_adult.T1W.nii.gz --targ [subjectRoot]/MNINonLinear/T1w.nii.gz --reg [subjectRoot]/MNINonLinear/register.dat --regheader --noedit
tkregister_matrix    = importdata([pathToFile '/MNINonLinear/register.dat']);
tkregister_matrix    = reshape(tkregister_matrix.data(4:end), [4 4])';


trk_len_full=[];
trk_type_full=[];
trkEP_full=[];

%% Loop through track files
for i=1:1
    nNotInAtlas = 0;

    %Read .trk meta and coordinates.
    [rawTrkHeader, rawtrkCoords_tkReg] = trk_read([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'.trk']);

    rawTrkLen=length(rawtrkCoords_tkReg);
    trk_len=zeros(rawTrkLen,1,'single');
    trk_type=zeros(rawTrkLen,3,'single');
    trkEP=zeros(rawTrkLen,6,'single');%
    storeTrkStartP = zeros([4,rawTrkLen]);
    storeTrkEndP = zeros([4,rawTrkLen]);
    storeTrkStartCoords = zeros([4,rawTrkLen]);
    voxel_size = rawTrkHeader.voxel_size;
    atlasDim = atlas.dim;
    milestones = round(rawTrkLen * (0:0.1:1));
    tic;
    disp("Looping through each track and converting into endpoints.");
    parfor k=1:rawTrkLen
        if ismember(k,milestones)
            disp((k/rawTrkLen)*100+"%");
        end
        trkMatrix_crs = rawtrkCoords_tkReg(k).matrix ./ voxel_size;

        % Flip Y [LPS (.trk) -> LAS (.anat)]
        trkMatrix_crs(:,2) = (-1 * trkMatrix_crs(:,2)) + atlasDim(2); %flip Y.
        % Define the endpoints of the track.
        trkMatrix_crs_terminals = [trkMatrix_crs(1,:)'  trkMatrix_crs(end,:)'; 1 1;];

        % Get track coordinates from CRS into TkReg space.
        trkMatrix_tkreg = atlasCRSToTkRAS * [trkMatrix_crs'; ones(1,size(trkMatrix_crs,1))];
        % Get track endpoints from CRS into TkReg space.
        trkMatrix_tkreg_terminals = atlasCRSToTkRAS * trkMatrix_crs_terminals;
        % Register TkReg track coordinates from DSIStudio default to
        % subject.
        trkMatrix_registered_tkreg = tkregister_matrix * trkMatrix_tkreg;
        % Register TkReg track endpoints from DSIStudio default to
        % subject.
        trkMatrix_registered_tkreg_terminals = tkregister_matrix * trkMatrix_tkreg_terminals;

        trkstartp = round(trkMatrix_crs_terminals(1:3,1)); %rename for readability
        trkendp = round(trkMatrix_crs_terminals(1:3,end)); %rename for readability
        trkstartp = correctForRounding(trkstartp, atlasDim);
        trkendp = correctForRounding(trkendp, atlasDim);
        
        storeTrkStartP(:, k) = [trkstartp; 1]; % store endpoint in matrix for visualisation.
        storeTrkStartCoords(:, k) = [trkMatrix_registered_tkreg(1:3,1); 1]; % store endpoint in matrix for visualisation.
        %storeTrkEndP(:, k) = [trkendp; 1];

        %% TODO: Insert validation check. Are points being moved inconsiderable
        %% distances?
        
        %Compute track length along each vertex
        trkPoints_notLast=trkMatrix_crs(1:end-1,:);
        trkPoints_notFirst=trkMatrix_crs(2:end,:);
        distBetweenTrkPoints=sqrt( (trkPoints_notLast(:,1)-trkPoints_notFirst(:,1)).^2 +(trkPoints_notLast(:,2)-trkPoints_notFirst(:,2)).^2 +(trkPoints_notLast(:,3)-trkPoints_notFirst(:,3)).^2);
        trk_len(k,1)=sum(distBetweenTrkPoints);

        % for the track to pial surface space
        trkEP(k,:)=[single(trkMatrix_registered_tkreg_terminals(1:3,1)') single(trkMatrix_registered_tkreg_terminals(1:3,end)')];

        % tmp information:
        % 1: trkstartp anatomical label ID
        % 2: trkendp anatomical label ID
        % 3: anatomical label ID as per neighbouring voxels.
        tmp=zeros(1,3);
        try
            tmp(1:2)=[atlas.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            %scatter3(trkMatrix(1,1),trkMatrix(1,2),trkMatrix(1,3));
            %scatter3(trkMatrix(end,1),trkMatrix(end,2),trkMatrix(end,3));
            nNotInAtlas = nNotInAtlas +1;
        end

        if(sum(tmp) == 0)
            nNotInAtlas = nNotInAtlas +1;
        end

        %for info on the choice of these numbers (1000, 3000 etc) check the
        %freesurfer lookup table.

        % add subcortical regions
        if  ( (tmp(1)<7 && tmp(1)>0) || (tmp(1)>26 && tmp(1)<47) || (tmp(1)<1000 && tmp(1)>58) || (tmp(1)>=3000) ) &&  ( (tmp(2)<7 && tmp(2)>0) || (tmp(2)>26 && tmp(2)<47) || (tmp(2)<1000 && tmp(2)>58) || (tmp(2)>=3000) )
            tmp(1,3)=0;
        elseif ( (tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000) ) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24 && ( (tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000) ) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24
            tmp(1,3)=1;
        elseif tmp(1)==0 && tmp(2)==0
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp)*checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                pause
            end
        elseif tmp(1)==0 && ( ((tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000)) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                pause
            end
        elseif tmp(2)==0 && ( ((tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000)) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;
    end
    disp("Done looping converting tracks to endpoints.")
    toc;
    disp(["Number of tracts not in atlas:", num2str(nNotInAtlas)]);
    trk_len_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen) =trk_len;
    trk_type_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trk_type;
    trkEP_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trkEP;

end


%% Visualisations
if(exist("trackImg", "var"))
    figure;
    title("Slices of atlas and trackImg nifti files")
    slice(double(atlas.anatomy),size(atlas.anatomy,2)/2,size(atlas.anatomy,1)/2,size(atlas.anatomy,3)/2);
    figure;
    trackImg.anatomy = flip(trackImg.anatomy,2);
    slice(double(trackImg.anatomy),size(trackImg.anatomy,2)/2,size(trackImg.anatomy,1)/2,size(trackImg.anatomy,3)/2);
end


trkCoords_tkReg = storeTrkStartCoords';

% Convert: trkCoords_tkReg (tkReg) -> atlas CRS
atlasCRS = (round(inv(atlasCRSToTkRAS)*trkCoords_tkReg'))';
atlasCoords_tkReg = (atlasCRSToTkRAS*atlasCRS')';

figure;
title("Tracts and Aparc in coordinates (xyz)")
hold on;
legend;
scatter3(atlasCoords_tkReg(1:1:end,1),atlasCoords_tkReg(1:1:end,2),atlasCoords_tkReg(1:1:end,3), 'DisplayName', "atlasCoords_{tkReg}");
scatter3(trkCoords_tkReg(1:1:end,1),(trkCoords_tkReg(1:1:end,2)),trkCoords_tkReg(1:1:end,3), 'DisplayName', "trkCoords_{tkReg}");
savefig('../../data/subjects/100610/tracts_aparc_xyz.fig');
saveas(gcf,'../../data/subjects/100610/tracts_aparc_xyz.png');
hold on;

mycifti = ft_read_cifti('../../data/subjects/100610/MNINonLinear/Results/tfMRI_MOTOR/tfMRI_MOTOR_hp200_s2_level2.feat/100610_tfMRI_MOTOR_level2_hp200_s2.dscalar.nii');
mygifti_L = gifti('../../data/subjects/100610/MNINonLinear/fsaverage_LR32k/100610.L.pial.32k_fs_LR.surf.gii');
mygifti_R = gifti('../../data/subjects/100610/MNINonLinear/fsaverage_LR32k/100610.R.pial.32k_fs_LR.surf.gii');

figure;
title("Tracts and Aparc and fmri in coordinates (xyz)")
hold on;
legend;
xlabel('x');
ylabel('y');
zlabel('z');
temp_ones_L = ones(size(mygifti_L.vertices,1),1);
temp_ones_R = ones(size(mygifti_R.vertices,1),1);
mygifti_L_vertices_transformed = [mygifti_L.vertices temp_ones_L];
mygifti_R_vertices_transformed = [mygifti_R.vertices temp_ones_R];

% NB: vertices coords are in SurfaceRAS. Therefore, to go from aparc (CRS)
% to this, we must use "type 1".
mygifti_L.faces(mygifti_L.faces>1) = 1;
plotsurf(mygifti_L_vertices_transformed(:,1:3), mygifti_L.faces, mycifti.x100610_tfmri_motor_level2_lf_hp200_s2(mycifti.brainstructure==1));
plotsurf(mygifti_R_vertices_transformed(:,1:3), mygifti_R.faces, mycifti.x100610_tfmri_motor_level2_lf_hp200_s2(mycifti.brainstructure==2));
scatter3(atlasCoords_tkReg(1:1:end,1),atlasCoords_tkReg(1:1:end,2),atlasCoords_tkReg(1:1:end,3), 'DisplayName', "atlasCoords_{tkReg}");
scatter3(trkCoords_tkReg(1:1:end,1),(trkCoords_tkReg(1:1:end,2)),trkCoords_tkReg(1:1:end,3), 'DisplayName', "trkCoords_{tkReg}");
savefig('../../data/subjects/100610/tracts_aparc_fmri_xyz.fig');
saveas(gcf,'../../data/subjects/100610/tracts_aparc_fmri_xyz.png');

figure;
title("Tracts and Aparc in voxels (ijk)")
% Build: take atlas.nii.gz and binarize it to approximate volume (CRS)
atlasCRSIndices = find(atlas.anatomy > mean(atlas.anatomy,'ALL'));
[atlasX, atlasY, atlasZ] = ind2sub(atlas.dim, atlasCRSIndices);
atlasCRS = [atlasX atlasY atlasZ];
trkCRS = storeTrkStartP;
hold on;
legend;
scatter3(atlasCRS(1:1:end,1),atlasCRS(1:1:end,2),atlasCRS(1:1:end,3), 'DisplayName', "atlasCRS");
scatter3(trkCRS(1,1:1:end),trkCRS(2,1:1:end),trkCRS(3,1:1:end), 'DisplayName', "trkCRS");
savefig('../../data/subjects/100610/tracts_aparc_ijk.fig');
saveas(gcf, '../../data/subjects/100610/tracts_aparc_ijk.png');
end
function [trackCoords] = correctForRounding(trackCoords, atlasDim)
% Where a voxel is now marginally outside atlasDim due to
% rounding, bring it back in.
voxelsAboveRange = (trackCoords'-atlasDim==1);
trackCoords(voxelsAboveRange) = atlasDim(voxelsAboveRange)';
voxelsBelowRange = (atlasDim-trackCoords'==1);
trackCoords(voxelsBelowRange) = 1;
end
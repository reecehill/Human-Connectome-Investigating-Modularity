"""
This type stub file was generated by pyright.
"""

from .dochelpers import borrowdoc
from .utils import auto_repr

"""
Wrapper for command and function calls, allowing for dry runs and output handling

"""
lgr = ...
linesep_bytes = ...
_TEMP_std = ...
_MAGICAL_OUTPUT_MARKER = ...
class Runner:
    """Provides a wrapper for calling functions and commands.

    An object of this class provides a methods that calls shell commands or
    python functions, allowing for protocolling the calls and output handling.

    Outputs (stdout and stderr) can be either logged or streamed to system's
    stdout/stderr during execution.
    This can be enabled or disabled for both of them independently.
    Additionally, a protocol object can be a used with the Runner. Such a
    protocol has to implement datalad.support.protocol.ProtocolInterface, is
    able to record calls and allows for dry runs.
    """
    __slots__ = ...
    def __init__(self, cwd=..., env=..., protocol=..., log_outputs=...) -> None:
        """
        Parameters
        ----------
        cwd: string, optional
             Base current working directory for commands.  Could be overridden
             per run call via cwd option
        env: dict, optional
             Custom environment to use for calls. Could be overridden per run
             call via env option
        protocol: ProtocolInterface
             Protocol object to write to.
        log_outputs : bool, optional
             Switch to instruct whether outputs should be logged or not.  If not
             set (default), config 'datalad.log.outputs' would be consulted
        """
        ...
    
    def __call__(self, cmd, *args, **kwargs): # -> None:
        """Convenience method

        This will call run() or call() depending on the kind of `cmd`.
        If `cmd` is a string it is interpreted as the to be executed command.
        Otherwise it is expected to be a callable.
        Any other argument is passed to the respective method.

        Parameters
        ----------
        cmd: str or callable
           command string to be executed via shell or callable to be called.

        `*args`:
        `**kwargs`:
           see Runner.run() and Runner.call() for available arguments.

        Raises
        ------
        TypeError
          if cmd is neither a string nor a callable.
        """
        ...
    
    _LOG_OPTS_ADAPTERS = ...
    @property
    def log_outputs(self): # -> Literal[False]:
        ...
    
    @property
    def log_cwd(self): # -> Literal[False]:
        ...
    
    @property
    def log_stdin(self): # -> Literal[False]:
        ...
    
    @property
    def log_env(self): # -> Literal[False]:
        ...
    
    def run(self, cmd, log_stdout=..., log_stderr=..., log_online=..., expect_stderr=..., expect_fail=..., cwd=..., env=..., shell=..., stdin=...):
        """Runs the command `cmd` using shell.

        In case of dry-mode `cmd` is just added to `commands` and it is
        actually executed otherwise.
        Allows for separately logging stdout and stderr  or streaming it to
        system's stdout or stderr respectively.

        Note: Using a string as `cmd` and shell=True allows for piping,
              multiple commands, etc., but that implies split_cmdline() is not
              used. This is considered to be a security hazard.
              So be careful with input.

        Parameters
        ----------
        cmd : str, list
          String (or list) defining the command call.  No shell is used if cmd
          is specified as a list

        log_stdout: bool, optional
            If True, stdout is logged. Goes to sys.stdout otherwise.

        log_stderr: bool, optional
            If True, stderr is logged. Goes to sys.stderr otherwise.

        log_online: bool, optional
            Whether to log as output comes in.  Setting to True is preferable
            for running user-invoked actions to provide timely output

        expect_stderr: bool, optional
            Normally, having stderr output is a signal of a problem and thus it
            gets logged at level 11.  But some utilities, e.g. wget, use
            stderr for their progress output.  Whenever such output is expected,
            set it to True and output will be logged at level 9 unless
            exit status is non-0 (in non-online mode only, in online -- would
            log at 9)

        expect_fail: bool, optional
            Normally, if command exits with non-0 status, it is considered an
            error and logged at level 11 (above DEBUG). But if the call intended
            for checking routine, such messages are usually not needed, thus
            it will be logged at level 9.

        cwd : string, optional
            Directory under which run the command (passed to Popen)

        env : string, optional
            Custom environment to pass

        shell: bool, optional
            Run command in a shell.  If not specified, then it runs in a shell
            only if command is specified as a string (not a list)

        stdin: file descriptor
            input stream to connect to stdin of the process.

        Returns
        -------
        (stdout, stderr) - bytes!

        Raises
        ------
        CommandError
           if command's exitcode wasn't 0 or None. exitcode is passed to
           CommandError's `code`-field. Command's stdout and stderr are stored
           in CommandError's `stdout` and `stderr` fields respectively.
        """
        ...
    
    def call(self, f, *args, **kwargs): # -> None:
        """Helper to unify collection of logging all "dry" actions.

        Calls `f` if `Runner`-object is not in dry-mode. Adds `f` along with
        its arguments to `commands` otherwise.

        Parameters
        ----------
        f: callable
        """
        ...
    
    def log(self, msg, *args, **kwargs): # -> None:
        """log helper

        Logs at level 9 by default and adds "Protocol:"-prefix in order to
        log the used protocol.
        """
        ...
    


class GitRunner(Runner):
    """
    Runner to be used to run git and git annex commands

    Overloads the runner class to check & update GIT_DIR and
    GIT_WORK_TREE environment variables set to the absolute path
    if is defined and is relative path
    """
    _GIT_PATH = ...
    @borrowdoc(Runner)
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def get_git_environ_adjusted(env=...): # -> dict[str, str]:
        """
        Replaces GIT_DIR and GIT_WORK_TREE with absolute paths if relative path and defined
        """
        ...
    
    def run(self, cmd, env=..., *args, **kwargs): # -> tuple[Unknown | str, Unknown | str]:
        ...
    


def readline_rstripped(stdout):
    ...

class SafeDelCloseMixin:
    """A helper class to use where __del__ would call .close() which might
    fail if "too late in GC game"
    """
    def __del__(self): # -> None:
        ...
    


@auto_repr
class BatchedCommand(SafeDelCloseMixin):
    """Container for a process which would allow for persistent communication
    """
    def __init__(self, cmd, path=..., output_proc=...) -> None:
        ...
    
    def __call__(self, cmds): # -> list[Unknown | str | None] | str | None:
        """

        Parameters
        ----------
        cmds : str or tuple or list of (str or tuple)

        Returns
        -------
        str or list
          Output received from process.  list in case if cmds was a list
        """
        ...
    
    def yield_(self, cmds): # -> Generator[Unknown | str | None, None, None]:
        """Same as __call__, but requires `cmds` to be an iterable

        and yields results for each item."""
        ...
    
    def proc1(self, arg): # -> str | None:
        """Same as __call__, but only takes a single command argument

        and returns a single result.
        """
        ...
    
    def close(self, return_stderr=...): # -> str | None:
        """Close communication and wait for process to terminate

        Returns
        -------
        str
          stderr output if return_stderr and stderr file was there.
          None otherwise
        """
        ...
    



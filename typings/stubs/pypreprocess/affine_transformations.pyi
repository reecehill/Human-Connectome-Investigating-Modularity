"""
This type stub file was generated by pyright.
"""

"""
:Module: affine_transformations
:Synopsis: routine functions for doing affine transformation-related business
:Author: DOHMATOB Elvis Dopgima

References
----------
[1] Rigid Body Registration, by J. Ashburner and K. Friston

"""
MOTION_PARAMS_NAMES = ...
def get_initial_motion_params(): # -> NDArray[float64]:
    """Returns an array of length 12 (3 translations, 3 rotations, 3 zooms,
    and 3 shears) corresponding to the identity transformation eye(4).

    Thus this is precisely made of: no zeto translation, zero rotation,
    a unit zoom of in each coordinate direction, and zero shear.
    """
    ...

def spm_matrix(p): # -> Any:
    """spm_matrix returns a matrix defining a rigid-body transformation.

    The transformation can be a translation, rotation, scaling and/or shear
    (well the shears and scalings are not rigid, but it's customary to include
    them in the model) transformation given a vector of parameters (p).
    By default, the transformations are applied in the following order (i.e.,
    the opposite to which they are specified):

    1) shear
    2) scale (zoom)
    3) rotation - yaw, roll & pitch
    4) translation

    Parameters
    ----------
    p: array_like of length 12
        vector of parameters
        p(0)  - x translation
        p(1)  - y translation
        p(2)  - z translation
        p(3)  - x rotation about - {pitch} (radians)
        p(4)  - y rotation about - {roll}  (radians)
        p(5)  - z rotation about - {yaw}   (radians)
        p(6)  - x scaling
        p(7)  - y scaling
        p(8)  - z scaling
        p(9) - x shear
        p(10) - y shear
        p(11) - z shear

    Returns
    -------
    A: 2D array of shape (4, 4)
        orthogonal transformation matrix

    """
    ...

def spm_imatrix(M): # -> NDArray[Any]:
    """Returns parameters the 12 parameters for a given affine
    transformation.

    This function does the inverse operation of the `spm_matrix`
    function.

    Parameters
    ----------
    M: array_like of shape (4, 4)
        affine transformation matrix

   Returns
   -------
   p: 1D array of length 12
       parameters for creating the afine transformation M

   """
    ...

def transform_coords(p, M1, M2, coords): # -> Any:
    """Rigidly transforms the current set of coordinates (working grid)
    according to current motion estimates, p, from one native space M1
    to another M2

    Parameters
    ----------
    p: 1D array_like of length at most 12
       current motion estimates
    M1: 2D array_like of shape (4, 4)
        affine definining the source space
    M2: 2D array_like of shape (4, 4)
        affine definining the destination space
    coords: 2D array_like of shape (3, n_voxels)
        the coordinates of the voxel(s) being transformed

    Returns
    -------
    array of same shape as the input coords:
        the transformed coordinates

    """
    ...

def get_physical_coords(M, voxel): # -> Any:
    """Get the scanner (world) coordinates of a voxel (or set of voxels) in
    the brain.

    Parameters
    ----------
    M: 2D array of shape (4, 4)
        affine transformation describing voxel-to-world mapping
    voxel: array_like of shape (3, n_voxels)
        voxel(s) under consideration

    Returns
    -------
    array of same shape as voxel input

    """
    ...

def nibabel2spm_affine(affine):
    """
    SPM uses MATLAB indexing convention, so affine zero in 3D is [1, 1, 1, 1].
    Nibabel uses python indexing convention and so [0, 0, 0, 1] is affine zero.
    Thus to work in SPM algebra, we need to cast

        [0, 0, 0, 1] -> [-1, -1, -1, 1],

    that is, we need to dope the (nibabel) affine matrix accordingly. This
    function does just that.

    Notes
    -----
    This function should be used to prepare nifti affine matrices prior
    to python out python implementations of the SPM registration algorithms.
    This is done back-end, and the front-end user shouldn't see this.
    In fact, this function is low-level, and should be shealded from the user.

    """
    ...

def apply_realignment_to_vol(vol, q, inverse=...): # -> Nifti1Image:
    """
    Modifies the affine headers of the given volume according to
    the realignment parameters (q).

    Parameters
    ----------
    vol: `nibabel.Nifti1Image`
        image to be transformed
    q: 1D array of length <= 12
        realignment parameters representing the rigid transformation
    inverse: boolean, optional (default False)
        indicates the direction in which the transformation is to be performed;
        if set then, it is assumed q actually represents the inverse of the
        transformation to be applied

    Returns
    -------
    `nibabel.Nifti1Image` object
        the realigned volume

    Notes
    -----
    Input is not modified.

    """
    ...

def apply_realignment(vols, rp, inverse=...): # -> list[Nifti1Image]:
    """
    Modifies  according to
    the realignment parameters (rp).

    vols: `nibabel.Nifti1Image`
        volumes to be transformed

    rp: 2D array of shape (n_vols, k) or (1, k), where k <=12
        realignment parameters representing the rigid transformations to be
        applied to the respective volumes.

    inverse: boolean, optional (default False)
        indicates the direction in which the transformation is to be performed;
        if set then, it is assumed q actually represents the inverse of the
        transformation to be applied

    Returns
    -------
    generator of `nibabel.Nifti1Image` objects
        the realigned volumes

    Notes
    -----
    Input is not modified.

    """
    ...

def extract_realignment_matrix(coregistered, original, inverse=...): # -> Any:
    """
    Extracts realignment matrix for "original -> coregistered" rigid body
    registration.

    Parameters
    ----------
    original: 3d volume (filename of nifti image object)
        The original source image.

    coregistered: 3d volume (filename of nifti image object)
        The coregistered output image.

    inverse: bool (optional, default False)
        If True, then the matrix for the inverse transformation is
    """
    ...

def extract_realignment_params(coregistered, original, inverse=...): # -> NDArray[Any]:
    """
    Extracts realignment params for "original -> coregistered" rigid body
    registration.

    Parameters
    ----------
    original: 3d volume (filename of nifti image object)
        The original source image.

    coregistered: 3d volume (filename of nifti image object)
        The coregistered output image.

    inverse: bool (optional, default False)
        If True, then the matrix for the inverse transformation is
    """
    ...


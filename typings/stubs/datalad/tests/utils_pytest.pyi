"""
This type stub file was generated by pyright.
"""

from functools import lru_cache
from http.server import SimpleHTTPRequestHandler
from datalad.dochelpers import borrowkwargs
from datalad.support.external_versions import external_versions
from datalad.support.vcr_ import *
from datalad.utils import *

"""Miscellaneous utilities to assist with testing"""
_TEMP_PATHS_CLONES = ...
on_travis = ...
on_appveyor = ...
on_github = ...
on_nfs = ...
if external_versions["cmd:git"] >= "2.28":
    DEFAULT_BRANCH = ...
else:
    DEFAULT_BRANCH = ...
if external_versions["cmd:git"] >= "2.30.0":
    DEFAULT_REMOTE = ...
else:
    DEFAULT_REMOTE = ...
def attr(name): # -> Any:
    ...

def assert_equal(first, second, msg=...): # -> None:
    ...

def assert_false(expr, msg=...): # -> None:
    ...

def assert_greater(first, second, msg=...): # -> None:
    ...

def assert_greater_equal(first, second, msg=...): # -> None:
    ...

def assert_in(first, second, msg=...): # -> None:
    ...

in_ = ...
def assert_is(first, second, msg=...): # -> None:
    ...

def assert_is_instance(first, second, msg=...): # -> None:
    ...

def assert_is_none(expr, msg=...): # -> None:
    ...

def assert_is_not(first, second, msg=...): # -> None:
    ...

def assert_is_not_none(expr, msg=...): # -> None:
    ...

def assert_not_equal(first, second, msg=...): # -> None:
    ...

def assert_not_in(first, second, msg=...): # -> None:
    ...

def assert_not_is_instance(first, second, msg=...): # -> None:
    ...

assert_raises = ...
assert_set_equal = ...
def assert_true(expr, msg=...): # -> None:
    ...

eq_ = ...
ok_ = ...
neq_ = ...
nok_ = ...
lgr = ...
def skip_if_no_module(module): # -> None:
    ...

def skip_if_scrapy_without_selector(): # -> None:
    """A little helper to skip some tests which require recent scrapy"""
    ...

def skip_if_url_is_not_available(url, regex=...): # -> None:
    ...

def check_not_generatorfunction(func): # -> None:
    """Internal helper to verify that we are not decorating generator tests"""
    ...

def skip_if_no_network(func=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any] | None:
    """Skip test completely in NONETWORK settings

    If not used as a decorator, and just a function, could be used at the module level
    """
    ...

def skip_if_on_windows(func=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any] | None:
    """Skip test completely under Windows
    """
    ...

def skip_if_root(func=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any] | None:
    """Skip test if uid == 0.

    Note that on Windows (or anywhere else `os.geteuid` is not available) the
    test is _not_ skipped.
    """
    ...

@optional_args
def skip_if(func, cond=..., msg=..., method=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any | None]:
    """Skip test for specific condition

    Parameters
    ----------
    cond: bool
      condition on which to skip
    msg: str
      message to print if skipping
    method: str
      either 'raise' or 'pass'. Whether to skip by raising `SkipTest` or by
      just proceeding and simply not calling the decorated function.
      This is particularly meant to be used, when decorating single assertions
      in a test with method='pass' in order to not skip the entire test, but
      just that assertion.
    """
    ...

def skip_ssh(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Skips SSH tests if on windows or if environment variable
    DATALAD_TESTS_SSH was not set
    """
    ...

def skip_nomultiplex_ssh(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Skips SSH tests if default connection/manager does not support multiplexing

    e.g. currently on windows or if set via datalad.ssh.multiplex-connections config variable
    """
    ...

def ok_clean_git(path, annex=..., index_modified=..., untracked=...): # -> None:
    """Obsolete test helper. Use assert_repo_status() instead.

    Still maps a few common cases to the new helper, to ease transition
    in extensions.
    """
    ...

def ok_file_under_git(path, filename=..., annexed=...): # -> None:
    """Test if file is present and under git/annex control

    If relative path provided, then test from current directory
    """
    ...

def put_file_under_git(path, filename=..., content=..., annexed=...): # -> AnnexRepo | GitRepo | None:
    """Place file under git/annex and return used Repo
    """
    ...

def get_annexstatus(ds, paths=...):
    """Report a status for annexed contents.
    Assembles states for git content info, amended with annex info on 'HEAD'
    (to get the last committed stage and with it possibly vanished content),
    and lastly annex info wrt to the present worktree, to also get info on
    added/staged content this fuses the info reported from
    - git ls-files
    - git annex findref HEAD
    - git annex find --include '*'"""
    ...

def ok_symlink(path): # -> None:
    """Checks whether path is either a working or broken symlink"""
    ...

def ok_good_symlink(path): # -> None:
    ...

def ok_broken_symlink(path): # -> None:
    ...

def ok_startswith(s, prefix): # -> None:
    ...

def ok_endswith(s, suffix): # -> None:
    ...

def nok_startswith(s, prefix): # -> None:
    ...

def ok_git_config_not_empty(ar): # -> None:
    """Helper to verify that nothing rewritten the config file"""
    ...

def ok_annex_get(ar, files, network=...): # -> None:
    """Helper to run .get decorated checking for correct operation

    get passes through stderr from the ar to the user, which pollutes
    screen while running tests

    Note: Currently not true anymore, since usage of --json disables
    progressbars
    """
    ...

def ok_generator(gen): # -> None:
    ...

assert_is_generator = ...
def ok_archives_caches(repopath, n=..., persistent=...): # -> None:
    """Given a path to repository verify number of archives

    Parameters
    ----------
    repopath : str
      Path to the repository
    n : int, optional
      Number of archives directories to expect
    persistent: bool or None, optional
      If None -- both persistent and not count.
    """
    ...

def ok_exists(path): # -> None:
    ...

def ok_file_has_content(path, content, strip=..., re_=..., decompress=..., **kwargs): # -> None:
    """Verify that file exists and has expected content"""
    ...

@optional_args
def with_tree(t, tree=..., archives_leading_dir=..., delete=..., **tkwargs): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    ...

lgr = ...
class SilentHTTPHandler(SimpleHTTPRequestHandler):
    """A little adapter to silence the handler
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def log_message(self, format, *args): # -> None:
        ...
    


class HTTPPath:
    """Serve the content of a path via an HTTP URL.

    This class can be used as a context manager, in which case it returns the
    URL.

    Alternatively, the `start` and `stop` methods can be called directly.

    Parameters
    ----------
    path : str
        Directory with content to serve.
    use_ssl : bool
    auth : tuple
        Username, password
    """
    def __init__(self, path, use_ssl=..., auth=...) -> None:
        ...
    
    def __enter__(self): # -> str | None:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    
    def start(self): # -> None:
        """Start serving `path` via HTTP.
        """
        ...
    
    def stop(self): # -> None:
        """Stop serving `path`.
        """
        ...
    


@optional_args
def serve_path_via_http(tfunc, *targs, use_ssl=..., auth=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Decorator which serves content of a directory via http url

    Parameters
    ----------
    path : str
        Directory with content to serve.
    use_ssl : bool
        Flag whether to set up SSL encryption and return a HTTPS
        URL. This require a valid certificate setup (which is tested
        for proper function) or it will cause a SkipTest to be raised.
    auth : tuple or None
        If a (username, password) tuple is given, the server access will
        be protected via HTTP basic auth.
    """
    ...

@optional_args
def with_memory_keyring(t): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Decorator to use non-persistent MemoryKeyring instance
    """
    ...

@optional_args
def without_http_proxy(tfunc): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Decorator to remove http*_proxy env variables for the duration of the test
    """
    ...

@borrowkwargs(methodname=make_tempfile)
@optional_args
def with_tempfile(t, **tkwargs): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Decorator function to provide a temporary file name and remove it at the end

    Parameters
    ----------

    To change the used directory without providing keyword argument 'dir' set
    DATALAD_TESTS_TEMP_DIR.

    Examples
    --------

    ::

        @with_tempfile
        def test_write(tfile=None):
            open(tfile, 'w').write('silly test')
    """
    ...

def probe_known_failure(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator allowing the test to pass when it fails and vice versa

    Setting config datalad.tests.knownfailures.probe to True tests, whether or
    not the test is still failing. If it's not, an AssertionError is raised in
    order to indicate that the reason for failure seems to be gone.
    """
    ...

@optional_args
def skip_known_failure(func, method=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator allowing to skip a test that is known to fail

    Setting config datalad.tests.knownfailures.skip to a bool enables/disables
    skipping.
    """
    ...

def known_failure(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator marking a test as known to fail

    This combines `probe_known_failure` and `skip_known_failure` giving the
    skipping precedence over the probing.
    """
    ...

def known_failure_direct_mode(func):
    """DEPRECATED.  Stop using.  Does nothing

    Test decorator marking a test as known to fail in a direct mode test run

    If datalad.repo.direct is set to True behaves like `known_failure`.
    Otherwise the original (undecorated) function is returned.
    """
    ...

def known_failure_windows(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator marking a test as known to fail on windows

    On Windows behaves like `known_failure`.
    Otherwise the original (undecorated) function is returned.
    """
    ...

def known_failure_githubci_win(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator for a known test failure on Github's Windows CI
    """
    ...

def known_failure_githubci_osx(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator for a known test failure on Github's macOS CI
    """
    ...

def known_failure_osx(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Test decorator for a known test failure on macOS
    """
    ...

xfail_buggy_annex_info = ...
local_testrepo_flavors = ...
_TESTREPOS = ...
@optional_args
def with_sameas_remote(func, autoenabled=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Provide a repository with a git-annex sameas remote configured.

    The repository will have two special remotes: r_dir (type=directory) and
    r_rsync (type=rsync). The rsync remote will be configured with
    --sameas=r_dir, and autoenabled if `autoenabled` is true.
    """
    ...

@optional_args
def with_fake_cookies_db(func, cookies=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """mock original cookies db with a fake one for the duration of the test
    """
    ...

@optional_args
def assert_cwd_unchanged(func, ok_to_chdir=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Decorator to test whether the current working directory remains unchanged

    Parameters
    ----------
    ok_to_chdir: bool, optional
      If True, allow to chdir, so this decorator would not then raise exception
      if chdir'ed but only return to original directory
    """
    ...

@optional_args
def run_under_dir(func, newdir=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], None]:
    """Decorator to run tests under another directory

    It is somewhat ugly since we can't really chdir
    back to a directory which had a symlink in its path.
    So using this decorator has potential to move entire
    testing run under the dereferenced directory name -- sideeffect.

    The only way would be to instruct testing framework (i.e. nose
    in our case ATM) to run a test by creating a new process with
    a new cwd
    """
    ...

def assert_re_in(regex, c, flags=..., match=..., msg=...): # -> None:
    """Assert that container (list, str, etc) contains entry matching the regex
    """
    ...

def assert_dict_equal(d1, d2): # -> None:
    ...

def assert_str_equal(s1, s2): # -> None:
    """Helper to compare two lines"""
    ...

def assert_status(label, results): # -> None:
    """Verify that each status dict in the results has a given status label

    `label` can be a sequence, in which case status must be one of the items
    in this sequence.
    """
    ...

def assert_message(message, results): # -> None:
    """Verify that each status dict in the results has a message

    This only tests the message template string, and not a formatted message
    with args expanded.
    """
    ...

def assert_result_count(results, n, **kwargs): # -> None:
    """Verify specific number of results (matching criteria, if any)"""
    ...

def assert_in_results(results, **kwargs): # -> None:
    """Verify that the particular combination of keys and values is found in
    one of the results"""
    ...

def assert_not_in_results(results, **kwargs): # -> None:
    """Verify that the particular combination of keys and values is not in any
    of the results"""
    ...

def assert_result_values_equal(results, prop, values): # -> None:
    """Verify that the values of all results for a given key in the status dicts
    match the given sequence"""
    ...

def assert_result_values_cond(results, prop, cond): # -> None:
    """Verify that the values of all results for a given key in the status dicts
    fulfill condition `cond`.

    Parameters
    ----------
    results:
    prop: str
    cond: callable
    """
    ...

def ignore_nose_capturing_stdout(func):
    """DEPRECATED and will be removed soon.  Does nothing!

    Originally was intended as a decorator workaround for nose's behaviour
    with redirecting sys.stdout, but now we monkey patch nose now so no test
    should no longer be skipped.

    See issue reported here:
    https://code.google.com/p/python-nose/issues/detail?id=243&can=1&sort=-id&colspec=ID%20Type%20Status%20Priority%20Stars%20Milestone%20Owner%20Summary

    """
    ...

with_parametric_batch = ...
OBSCURE_PREFIX = ...
OBSCURE_FILENAME_PARTS = ...
UNICODE_FILENAME = ...
if sys.getfilesystemencoding().lower() == 'utf-8':
    ...
@with_tempfile(mkdir=True)
def get_most_obscure_supported_name(tdir, return_candidates=...): # -> tuple[str, list[Any]] | str:
    """Return the most obscure filename that the filesystem would support under TEMPDIR

    Parameters
    ----------
    return_candidates: bool, optional
      if True, return a tuple of (good, candidates) where candidates are "partially"
      sorted from trickiest considered
    TODO: we might want to use it as a function where we would provide tdir
    """
    ...

@optional_args
def with_testsui(t, responses=..., interactive=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Switch main UI to be 'tests' UI and possibly provide answers to be used"""
    ...

def assert_no_errors_logged(func, skip_re=...): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Decorator around function to assert that no errors logged during its execution"""
    ...

def get_mtimes_and_digests(target_path): # -> tuple[dict[str, dict[str, str]], dict[str, float]]:
    """Return digests (md5) and mtimes for all the files under target_path"""
    ...

def get_datasets_topdir(): # -> Any:
    """Delayed parsing so it could be monkey patched etc"""
    ...

def assert_repo_status(path, annex=..., untracked_mode=..., **kwargs): # -> None:
    """Compare a repo status against (optional) exceptions.

    Anything file/directory that is not explicitly indicated must have
    state 'clean', i.e. no modifications and recorded in Git.

    Parameters
    ----------
    path: str or Repo
      in case of a str: path to the repository's base dir;
      Note, that passing a Repo instance prevents detecting annex. This might
      be useful in case of a non-initialized annex, a GitRepo is pointing to.
    annex: bool or None
      explicitly set to True or False to indicate, that an annex is (not)
      expected; set to None to autodetect, whether there is an annex.
      Default: None.
    untracked_mode: {'no', 'normal', 'all'}
      If and how untracked content is reported. The specification of untracked
      files that are OK to be found must match this mode. See `Repo.status()`
    **kwargs
      Files/directories that are OK to not be in 'clean' state. Each argument
      must be one of 'added', 'untracked', 'deleted', 'modified' and each
      value must be a list of filenames (relative to the root of the
      repository, in POSIX convention).
    """
    ...

def get_convoluted_situation(path, repocls=...): # -> Any:
    ...

def get_deeply_nested_structure(path): # -> Any:
    """ Here is what this does (assuming UNIX, locked):
    |  .
    |  ├── directory_untracked
    |  │  └── link2dir -> ../subdir
    |  ├── OBSCURE_FILENAME_file_modified
    |  ├── link2dir -> subdir
    |  ├── link2subdsdir -> subds_modified/subdir
    |  ├── link2subdsroot -> subds_modified
    |  ├── subdir
    |  │   ├── annexed_file.txt -> ../.git/annex/objects/...
    |  │   ├── file_modified
    |  │   ├── git_file.txt
    |  │   └── link2annex_files.txt -> annexed_file.txt
    |  └── subds_modified
    |      ├── link2superdsdir -> ../subdir
    |      ├── subdir
    |      │   └── annexed_file.txt -> ../.git/annex/objects/...
    |      └── subds_lvl1_modified
    |          └── OBSCURE_FILENAME_directory_untracked
    |              └── untracked_file

    When a system has no symlink support, the link2... components are not
    included.
    """
    ...

def maybe_adjust_repo(repo): # -> None:
    """Put repo into an adjusted branch if it is not already.
    """
    ...

@lru_cache()
@with_tempfile
@with_tempfile
def has_symlink_capability(p1, p2): # -> bool:
    ...

def skip_wo_symlink_capability(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Skip test when environment does not support symlinks

    Perform a behavioral test instead of top-down logic, as on
    windows this could be on or off on a case-by-case basis.
    """
    ...

_TESTS_ADJUSTED_TMPDIR = ...
def skip_if_adjusted_branch(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Skip test if adjusted branch is used by default on TMPDIR file system.
    """
    ...

def get_ssh_port(host): # -> int | None:
    """Get port of `host` in ssh_config.

    Our tests depend on the host being defined in ssh_config, including its
    port. This method can be used by tests that want to check handling of an
    explicitly specified

    Note that if `host` does not match a host in ssh_config, the default value
    of 22 is returned.

    Skips test if port cannot be found.

    Parameters
    ----------
    host : str

    Returns
    -------
    port (int)
    """
    ...

def patch_config(vars): # -> _patch_dict:
    """Patch our config with custom settings. Returns mock.patch cm

    Only the merged configuration from all sources (global, local, dataset)
    will be patched. Source-constrained patches (e.g. only committed dataset
    configuration) are not supported.
    """
    ...

@contextmanager
def set_date(timestamp): # -> Generator[None, Any, None]:
    """Temporarily override environment variables for git/git-annex dates.

    Parameters
    ----------
    timestamp : int
        Unix timestamp.
    """
    ...

@contextmanager
def set_annex_version(version): # -> Generator[None, Any, None]:
    """Override the git-annex version.

    This temporarily masks the git-annex version present in external_versions
    and make AnnexRepo forget its cached version information.
    """
    ...

def integration(f): # -> Any:
    """Mark test as an "integration" test which generally is not needed to be run
    
    Generally tend to be slower.
    Should be used in combination with @slow and @turtle if that is the case.
    """
    ...

def slow(f): # -> Any:
    """Mark test as a slow, although not necessarily integration or usecase test

    Rule of thumb cut-off to mark as slow is 10 sec
    """
    ...

def turtle(f): # -> Any:
    """Mark test as very slow, meaning to not run it on Travis due to its
    time limit

    Rule of thumb cut-off to mark as turtle is 2 minutes
    """
    ...

def usecase(f): # -> Any:
    """Mark test as a usecase user ran into and which (typically) caused bug report
    to be filed/troubleshooted

    Should be used in combination with @slow and @turtle if slow.
    """
    ...


"""
This type stub file was generated by pyright.
"""

from datalad.dochelpers import borrowdoc, borrowkwargs
from datalad.utils import auto_repr
from datalad.cmd import BatchedCommand, SafeDelCloseMixin
from .repo import RepoInterface
from .gitrepo import GitRepo, normalize_path, normalize_paths

"""Interface to git-annex by Joey Hess.

For further information on git-annex see https://git-annex.branchable.com/.

"""
lgr = ...
N_AUTO_JOBS = ...
class AnnexRepo(GitRepo, RepoInterface):
    """Representation of an git-annex repository.

    Paths given to any of the class methods will be interpreted as relative
    to PWD, in case this is currently beneath AnnexRepo's base dir
    (`self.path`). If PWD is outside of the repository, relative paths
    will be interpreted as relative to `self.path`. Absolute paths will be
    accepted either way.
    """
    _unique_instances = ...
    WEB_UUID = ...
    GIT_ANNEX_MIN_VERSION = ...
    git_annex_version = ...
    supports_direct_mode = ...
    repository_versions = ...
    _version_kludges = ...
    _ALLOW_LOCAL_URLS = ...
    def __init__(self, path, url=..., runner=..., backend=..., always_commit=..., create=..., create_sanity_checks=..., init=..., batch_size=..., version=..., description=..., git_opts=..., annex_opts=..., annex_init_opts=..., repo=..., fake_dates=...) -> None:
        """Creates representation of git-annex repository at `path`.

        AnnexRepo is initialized by giving a path to the annex.
        If no annex exists at that location, a new one is created.
        Optionally give url to clone from.

        Parameters
        ----------
        path: str
          Path to git-annex repository. In case it's not an absolute path, it's
          relative to PWD
        url: str, optional
          url to the to-be-cloned repository. Requires valid git url
          according to
          http://www.kernel.org/pub/software/scm/git/docs/git-clone.html#URLS .
        runner: Runner, optional
          Provide a Runner in case AnnexRepo shall not create it's own.
          This is especially needed in case of desired dry runs.
        backend: str, optional
          Set default backend used by this annex. This does NOT affect files,
          that are already annexed nor will it automatically migrate files,
          hat are 'getted' afterwards.
        create: bool, optional
          Create and initialize an annex repository at path, in case
          there is none. If set to False, and this repository is not an annex
          repository (initialized or not), an exception is raised.
        create_sanity_checks: bool, optional
          Passed to GitRepo.
        init: bool, optional
          Initialize git-annex repository (run "git annex init") if path is an
          annex repository which just was not yet initialized by annex (e.g. a
          fresh git clone). Note that if `create=True`, then initialization
          would happen
        batch_size: int, optional
          If specified and >0, instructs annex to batch this many commands before
          annex adds acts on git repository (e.g. adds them them to index for addurl).
        version: int, optional
          If given, pass as --version to `git annex init`
        description: str, optional
          Short description that humans can use to identify the
          repository/location, e.g. "Precious data on my laptop"
        """
        ...
    
    def set_default_backend(self, backend, persistent=..., commit=...): # -> None:
        """Set default backend

        Parameters
        ----------
        backend : str
        persistent : bool, optional
          If persistent, would add/commit to .gitattributes. If not -- would
          set within .git/config
        """
        ...
    
    def __del__(self): # -> None:
        ...
    
    def is_managed_branch(self, branch=...): # -> bool:
        """Whether `branch` is managed by git-annex.

        ATM this returns true in direct mode (branch 'annex/direct/my_branch')
        and if on an adjusted branch (annex v6+ repository:
        either 'adjusted/my_branch(unlocked)' or 'adjusted/my_branch(fixed)'

        Note: The term 'managed branch' is used to make clear it's meant to be
        more general than the v6+ 'adjusted branch'.

        Parameters
        ----------
        branch: str
          name of the branch; default: active branch

        Returns
        -------
        bool
          True if on a managed branch, False otherwise
        """
        ...
    
    def get_corresponding_branch(self, branch=...): # -> str | None:
        """In case of a managed branch, get the corresponding one.

        If `branch` is not a managed branch, return that branch without any
        changes.

        Note: Since default for `branch` is the active branch,
        `get_corresponding_branch()` is equivalent to `get_active_branch()` if
        the active branch is not a managed branch.

        Parameters
        ----------
        branch: str
          name of the branch; defaults to active branch

        Returns
        -------
        str
          name of the corresponding branch if there is any, name of the queried
          branch otherwise.
        """
        ...
    
    def get_tracking_branch(self, branch=..., corresponding=...): # -> tuple[None, None] | tuple[Unknown | None, Unknown | None]:
        """Get the tracking branch for `branch` if there is any.

        By default returns the tracking branch of the corresponding branch if
        `branch` is a managed branch.

        Parameters
        ----------
        branch: str
          local branch to look up. If none is given, active branch is used.
        corresponding: bool
          If True actually look up the corresponding branch of `branch` (also if
          `branch` isn't explicitly given)

        Returns
        -------
        tuple
            (remote or None, refspec or None) of the tracking branch
        """
        ...
    
    @classmethod
    def check_direct_mode_support(cls):
        """Does git-annex version support direct mode?

        The result is cached at `cls.supports_direct_mode`.

        Returns
        -------
        bool
        """
        ...
    
    @classmethod
    def check_repository_versions(cls): # -> dict[str, list[int]]:
        """Get information on supported and upgradable repository versions.

        The result is cached at `cls.repository_versions`.

        Returns
        -------
        dict
          supported -> list of supported versions (int)
          upgradable -> list of upgradable versions (int)
        """
        ...
    
    @staticmethod
    def get_size_from_key(key): # -> int | None:
        """A little helper to obtain size encoded in a key"""
        ...
    
    @normalize_path
    def get_file_size(self, path): # -> int:
        ...
    
    @classmethod
    def get_toppath(cls, path, follow_up=..., git_options=...): # -> str | None:
        """Return top-level of a repository given the path.

        Parameters
        -----------
        follow_up : bool
          If path has symlinks -- they get resolved by git.  If follow_up is
          True, we will follow original path up until we hit the same resolved
          path.  If no such path found, resolved one would be returned.
        git_options: list of str
          options to be passed to the git rev-parse call

        Return None if no parent directory contains a git repository.
        """
        ...
    
    def is_initialized(self): # -> bool:
        """quick check whether this appears to be an annex-init'ed repo
        """
        ...
    
    @borrowdoc(GitRepo, 'is_valid_git')
    def is_valid_annex(self, allow_noninitialized=..., check_git=...): # -> bool:
        ...
    
    @classmethod
    def is_valid_repo(cls, path, allow_noninitialized=...): # -> bool:
        """Return True if given path points to an annex repository
        """
        ...
    
    def add_remote(self, name, url, options=...): # -> None:
        """Overrides method from GitRepo in order to set
        remote.<name>.annex-ssh-options in case of a SSH remote."""
        ...
    
    def set_remote_url(self, name, url, push=...): # -> None:
        """Set the URL a remote is pointing to

        Sets the URL of the remote `name`. Requires the remote to already exist.

        Parameters
        ----------
        name: str
          name of the remote
        url: str
        push: bool
          if True, set the push URL, otherwise the fetch URL;
          if True, additionally set annexurl to `url`, to make sure annex uses
          it to talk to the remote, since access via fetch URL might be
          restricted.
        """
        ...
    
    def set_remote_dead(self, name): # -> tuple[Unknown | str, Unknown | str]:
        """Announce to annex that remote is "dead"
        """
        ...
    
    def is_remote_annex_ignored(self, remote): # -> bool:
        """Return True if remote is explicitly ignored"""
        ...
    
    def is_special_annex_remote(self, remote, check_if_known=...): # -> bool:
        """Return whether remote is a special annex remote

        Decides based on the presence of an annex- option and lack of a
        configured URL for the remote.
        """
        ...
    
    @borrowkwargs(GitRepo)
    def get_remotes(self, with_urls_only=..., exclude_special_remotes=...): # -> list[Unknown]:
        """Get known (special-) remotes of the repository

        Parameters
        ----------
        exclude_special_remotes: bool, optional
          if True, don't return annex special remotes

        Returns
        -------
        remotes : list of str
          List of names of the remotes
        """
        ...
    
    def get_special_remotes(self): # -> dict[Unknown, Unknown]:
        """Get info about all known (not just enabled) special remotes.

        Returns
        -------
        dict
          Keys are special remote UUIDs. Each value is a dictionary with
          configuration information git-annex has for the remote. This should
          include the 'type' and 'name' as well as any `initremote` parameters
          that git-annex stores.

          Note: This is a faithful translation of git-annex:remote.log with one
          exception. For a special remote initialized with the --sameas flag,
          git-annex stores the special remote name under the "sameas-name" key,
          we copy this value under the "name" key so that callers don't have to
          check two places for the name. If you need to detect whether you're
          working with a sameas remote, the presence of either "sameas-name" or
          "sameas-uuid" is a reliable indicator.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def is_direct_mode(self): # -> bool:
        """Return True if annex is in direct mode

        Returns
        -------
        True if in direct mode, False otherwise.
        """
        ...
    
    def is_crippled_fs(self): # -> bool:
        """Return True if git-annex considers current filesystem 'crippled'.

        Returns
        -------
        True if on crippled filesystem, False otherwise
        """
        ...
    
    @property
    def supports_unlocked_pointers(self): # -> bool:
        """Return True if repository version supports unlocked pointers.
        """
        ...
    
    @normalize_paths
    def get(self, files, remote=..., options=..., jobs=..., key=...): # -> list[Unknown]:
        """Get the actual content of files

        Parameters
        ----------
        files : list of str
            paths to get
        remote : str, optional
            from which remote to fetch content
        options : list of str, optional
            commandline options for the git annex get command
        jobs : int or None, optional
            how many jobs to run in parallel (passed to git-annex call).
            If not specified (None), then
        key : bool, optional
            If provided file value is actually a key

        Returns
        -------
        files : list of dict
        """
        ...
    
    @normalize_paths
    def add(self, files, git=..., backend=..., options=..., jobs=..., git_options=..., annex_options=..., update=...): # -> list[dict[str, Any | bool] | Unknown]:
        """Add file(s) to the repository.

        Parameters
        ----------
        files: list of str
          list of paths to add to the annex
        git: bool
          if True, add to git instead of annex.
        backend:
        options:
        update: bool
          --update option for git-add. From git's manpage:
           Update the index just where it already has an entry matching
           <pathspec>. This removes as well as modifies index entries to match
           the working tree, but adds no new files.

           If no <pathspec> is given when --update option is used, all tracked
           files in the entire working tree are updated (old versions of Git
           used to limit the update to the current directory and its
           subdirectories).

           Note: Used only, if a call to git-add instead of git-annex-add is
           performed

        Returns
        -------
        list of dict or dict
        """
        ...
    
    def add_(self, files, git=..., backend=..., options=..., jobs=..., git_options=..., annex_options=..., update=...): # -> Generator[dict[str, Any | bool] | Unknown, None, None]:
        """Like `add`, but returns a generator"""
        ...
    
    @normalize_paths
    def get_file_key(self, files, batch=...): # -> str:
        """Get key of an annexed file.

        Parameters
        ----------
        files: str or list
            file(s) to look up
        batch: None or bool, optional
            If True, `lookupkey --batch` process will be used, which would
            not crash even if provided file is not under annex (but directly
            under git), but rather just return an empty string. If False,
            invokes without --batch. If None, use batch mode if more than a
            single file is provided.

        Returns
        -------
        str or list
            keys used by git-annex for each of the files;
            in case of a list an empty string is returned if there was no key
            for that file

        Raises
        ------
        FileInGitError
             If running in non-batch mode and a file is under git, not annex
        FileNotInAnnexError
             If running in non-batch mode and a file is not under git at all
        """
        ...
    
    @normalize_paths
    def unlock(self, files): # -> list[Unknown] | None:
        """unlock files for modification

        Note: This method is silent about errors in unlocking a file (e.g, the
        file has not content). Use the higher-level interface.unlock to get
        more informative reporting.

        Parameters
        ----------
        files: list of str

        Returns
        -------
        list of str
          successfully unlocked files
        """
        ...
    
    def adjust(self, options=...): # -> None:
        """enter an adjusted branch

        This command is only available in a v6+ git-annex repository.

        Parameters
        ----------
        options: list of str
          currently requires '--unlock' or '--fix';
          default: --unlock
        """
        ...
    
    @normalize_paths
    def unannex(self, files, options=...): # -> list[Unknown | str]:
        """undo accidental add command

        Use this to undo an accidental git annex add command. Note that for
        safety, the content of the file remains in the annex, until you use git
        annex unused and git annex dropunused.

        Parameters
        ----------
        files: list of str
        options: list of str

        Returns
        -------
        list of str
          successfully unannexed files
        """
        ...
    
    @normalize_paths(map_filenames_back=True)
    def find(self, files, batch=...): # -> dict[Unknown, Unknown]:
        """Run `git annex find` on file(s).

        Parameters
        ----------
        files: list of str
            files to find under annex
        batch: bool, optional
            initiate or continue with a batched run of annex find, instead of just
            calling a single git annex find command. If any items in `files`
            are directories, this value is treated as False.

        Returns
        -------
        A dictionary the maps each item in `files` to its `git annex find`
        result. Items without a successful result will be an empty string, and
        multi-item results (which can occur for if `files` includes a
        directory) will be returned as a list.
        """
        ...
    
    @normalize_paths
    def file_has_content(self, files, allow_quick=..., batch=...): # -> list[bool] | list[Unknown]:
        """Check whether files have their content present under annex.

        Parameters
        ----------
        files: list of str
            file(s) to check for being actually present.
        allow_quick: bool, optional
            allow quick check, based on having a symlink into .git/annex/objects.
            Works only in non-direct mode (TODO: thin mode)

        Returns
        -------
        list of bool
            For each input file states whether file has content locally
        """
        ...
    
    @normalize_paths
    def is_under_annex(self, files, allow_quick=..., batch=...): # -> list[bool] | list[Unknown]:
        """Check whether files are under annex control

        Parameters
        ----------
        files: list of str
            file(s) to check for being under annex
        allow_quick: bool, optional
            allow quick check, based on having a symlink into .git/annex/objects.
            Works only in non-direct mode (TODO: thin mode)

        Returns
        -------
        list of bool
            For each input file states whether file is under annex
        """
        ...
    
    def init_remote(self, name, options): # -> None:
        """Creates a new special remote

        Parameters
        ----------
        name: str
            name of the special remote
        """
        ...
    
    def enable_remote(self, name, env=...): # -> None:
        """Enables use of an existing special remote

        Parameters
        ----------
        name: str
            name, the special remote was created with
        """
        ...
    
    def merge_annex(self, remote=...): # -> None:
        """Merge git-annex branch

        Merely calls `sync` with the appropriate arguments.

        Parameters
        ----------
        remote: str, optional
          Name of a remote to be "merged".
        """
        ...
    
    def sync(self, remotes=..., push=..., pull=..., commit=..., content=..., all=..., fast=...): # -> None:
        """Synchronize local repository with remotes

        Use  this  command  when you want to synchronize the local repository
        with one or more of its remotes. You can specify the remotes (or
        remote groups) to sync with by name; the default if none are specified
        is to sync with all remotes.

        Parameters
        ----------
        remotes: str, list(str), optional
          Name of one or more remotes to be sync'ed.
        push : bool
          By default, git pushes to remotes.
        pull : bool
          By default, git pulls from remotes
        commit : bool
          A commit is done by default. Disable to avoid  committing local
          changes.
        content : bool
          Normally, syncing does not transfer the contents of annexed
          files.  This option causes the content of files in the work tree
          to also be uploaded and downloaded as necessary.
        all : bool
          This option, when combined with `content`, makes all available
          versions of all files be synced, when preferred content settings
          allow
        fast : bool
          Only sync with the remotes with the lowest annex-cost value
          configured
        """
        ...
    
    @normalize_path
    def add_url_to_file(self, file_, url, options=..., backend=..., batch=..., git_options=..., annex_options=..., unlink_existing=...):
        """Add file from url to the annex.

        Downloads `file` from `url` and add it to the annex.
        If annex knows `file` already,
        records that it can be downloaded from `url`.

        Note: Consider using the higher-level `download_url` instead.

        Parameters
        ----------
        file_: str

        url: str

        options: list
            options to the annex command

        batch: bool, optional
            initiate or continue with a batched run of annex addurl, instead of just
            calling a single git annex addurl command

        unlink_existing: bool, optional
            by default crashes if file already exists and is under git.
            With this flag set to True would first remove it.

        Returns
        -------
        dict
          In batch mode only ATM returns dict representation of json output returned
          by annex
        """
        ...
    
    def add_urls(self, urls, options=..., backend=..., cwd=..., jobs=..., git_options=..., annex_options=...): # -> list[dict[str, Unknown | bool]]:
        """Downloads each url to its own file, which is added to the annex.

        Parameters
        ----------
        urls: list of str

        options: list, optional
            options to the annex command

        cwd: string, optional
            working directory from within which to invoke git-annex
        """
        ...
    
    @normalize_path
    def rm_url(self, file_, url): # -> None:
        """Record that the file is no longer available at the url.

        Parameters
        ----------
        file_: str

        url: str
        """
        ...
    
    @normalize_path
    def get_urls(self, file_, key=..., batch=...): # -> dict[str, Unknown] | list[Unknown]:
        """Get URLs for a file/key

        Parameters
        ----------
        file_: str
        key: bool, optional
            Whether provided files are actually annex keys

        Returns
        -------
        A list of URLs
        """
        ...
    
    @normalize_paths
    def drop(self, files, options=..., key=..., jobs=...): # -> list[Unknown]:
        """Drops the content of annexed files from this repository.

        Drops only if possible with respect to required minimal number of
        available copies.

        Parameters
        ----------
        files: list of str
            paths to drop
        options : list of str, optional
            commandline options for the git annex drop command
        jobs : int, optional
            how many jobs to run in parallel (passed to git-annex call)

        Returns
        -------
        list(JSON objects)
          'success' item in each object indicates failure/success per file
          path.
        """
        ...
    
    def drop_key(self, keys, options=..., batch=...): # -> None:
        """Drops the content of annexed files from this repository referenced by keys

        Dangerous: it drops without checking for required minimal number of
        available copies.

        Parameters
        ----------
        keys: list of str, str

        batch: bool, optional
            initiate or continue with a batched run of annex dropkey, instead of just
            calling a single git annex dropkey command
        """
        ...
    
    @normalize_paths
    def whereis(self, files, output=..., key=..., options=..., batch=...): # -> list[list[Unknown]] | dict[Unknown, dict[Unknown, dict[str, Unknown]]] | None:
        """Lists repositories that have actual content of file(s).

        Parameters
        ----------
        files: list of str
            files to look for
        output: {'descriptions', 'uuids', 'full'}, optional
            If 'descriptions', a list of remotes descriptions returned is per
            each file. If 'full', for each file a dictionary of all fields
            is returned as returned by annex
        key: bool, optional
            Whether provided files are actually annex keys
        options: list, optional
            Options to pass into git-annex call

        Returns
        -------
        list of list of unicode  or dict
            if output == 'descriptions', contains a list of descriptions of remotes
            for each input file, describing the remote for each remote, which
            was found by git-annex whereis, like::

                u'me@mycomputer:~/where/my/repo/is [origin]' or
                u'web' or
                u'me@mycomputer:~/some/other/clone'

            if output == 'uuids', returns a list of uuids.
            if output == 'full', returns a dictionary with filenames as keys
            and values a detailed record, e.g.::

                {'00000000-0000-0000-0000-000000000001': {
                  'description': 'web',
                  'here': False,
                  'urls': ['http://127.0.0.1:43442/about.txt', 'http://example.com/someurl']
                }}
        """
        ...
    
    @normalize_paths(map_filenames_back=True)
    def info(self, files, batch=..., fast=...): # -> dict[Unknown, Unknown]:
        """Provide annex info for file(s).

        Parameters
        ----------
        files: list of str
            files to look for

        Returns
        -------
        dict
          Info for each file
        """
        ...
    
    def repo_info(self, fast=..., merge_annex_branches=...):
        """Provide annex info for the entire repository.

        Parameters
        ----------
        fast : bool, optional
          Pass `--fast` to `git annex info`.
        merge_annex_branches : bool, optional
          Whether to allow git-annex if needed to merge annex branches, e.g. to
          make sure up to date descriptions for git annex remotes

        Returns
        -------
        dict
          Info for the repository, with keys matching the ones returned by annex
        """
        ...
    
    def get_annexed_files(self, with_content_only=..., patterns=...): # -> list[str]:
        """Get a list of files in annex

        Parameters
        ----------
        with_content_only : bool, optional
            Only list files whose content is present.
        patterns : list, optional
            Globs to pass to annex's `--include=`. Files that match any of
            these will be returned (i.e., they'll be separated by `--or`).

        Returns
        -------
        A list of file names
        """
        ...
    
    def get_preferred_content(self, property, remote=...): # -> str | None:
        """Get preferred content configuration of a repository or remote

        Parameters
        ----------
        property : {'wanted', 'required', 'group'}
          Type of property to query
        remote : str, optional
          If not specified (None), returns the property for the local
          repository.

        Returns
        -------
        str
          Whether the setting is returned, or an empty string if there
          is none.

        Raises
        ------
        ValueError
          If an unknown property label is given.

        CommandError
          If the annex call errors.
        """
        ...
    
    def set_preferred_content(self, property, expr, remote=...): # -> str | None:
        """Set preferred content configuration of a repository or remote

        Parameters
        ----------
        property : {'wanted', 'required', 'group'}
          Type of property to query
        expr : str
          Any expression or label supported by git-annex for the
          given property.
        remote : str, optional
          If not specified (None), sets the property for the local
          repository.

        Returns
        -------
        str
          Raw git-annex output in response to the set command.

        Raises
        ------
        ValueError
          If an unknown property label is given.

        CommandError
          If the annex call errors.
        """
        ...
    
    def get_groupwanted(self, name): # -> str | None:
        """Get `groupwanted` expression for a group `name`

        Parameters
        ----------
        name : str
           Name of the groupwanted group
        """
        ...
    
    def set_groupwanted(self, name, expr): # -> str | None:
        """Set `expr` for the `name` groupwanted"""
        ...
    
    def precommit(self): # -> None:
        """Perform pre-commit maintenance tasks, such as closing all batched annexes
        since they might still need to flush their changes into index
        """
        ...
    
    @borrowdoc(GitRepo)
    def commit(self, msg=..., options=..., _datalad_msg=..., careless=..., files=...): # -> None:
        ...
    
    @normalize_paths(match_return_type=False)
    def remove(self, files, force=..., **kwargs): # -> list[Unknown | str]:
        """Remove files from git/annex

        Parameters
        ----------
        files
        force: bool, optional
        """
        ...
    
    def get_contentlocation(self, key, batch=...): # -> str:
        """Get location of the key content

        Normally under .git/annex objects in indirect mode and within file
        tree in direct mode.

        Unfortunately there is no (easy) way to discriminate situations
        when given key is simply incorrect (not known to annex) or its content
        not currently present -- in both cases annex just silently exits with -1


        Parameters
        ----------
        key: str
            key
        batch: bool, optional
            initiate or continue with a batched run of annex contentlocation

        Returns
        -------
        str
            path relative to the top directory of the repository. If no content
            is present, empty string is returned
        """
        ...
    
    @normalize_paths(serialize=True)
    def is_available(self, file_, remote=..., key=..., batch=...): # -> bool:
        """Check if file or key is available (from a remote)

        In case if key or remote is misspecified, it wouldn't fail but just keep
        returning False, although possibly also complaining out loud ;)

        Parameters
        ----------
        file_: str
            Filename or a key
        remote: str, optional
            Remote which to check.  If None, possibly multiple remotes are checked
            before positive result is reported
        key: bool, optional
            Whether provided files are actually annex keys
        batch: bool, optional
            Initiate or continue with a batched run of annex checkpresentkey

        Returns
        -------
        bool
            with True indicating that file/key is available from (the) remote
        """
        ...
    
    @normalize_paths
    def migrate_backend(self, files, backend=...): # -> None:
        """Changes the backend used for `file`.

        The backend used for the key-value of `files`. Only files currently
        present are migrated.
        Note: There will be no notification if migrating fails due to the
        absence of a file's content!

        Parameters
        ----------
        files: list
            files to migrate.
        backend: str
            specify the backend to migrate to. If none is given, the
            default backend of this instance will be used.
        """
        ...
    
    @classmethod
    def get_key_backend(cls, key):
        """Get the backend from a given key"""
        ...
    
    @normalize_paths
    def get_file_backend(self, files): # -> list[Unknown | str]:
        """Get the backend currently used for file(s).

        Parameters
        ----------
        files: list of str

        Returns
        -------
        list of str
            For each file in input list indicates the used backend by a str
            like "SHA256E" or "MD5".
        """
        ...
    
    @property
    def default_backends(self): # -> None:
        ...
    
    def fsck(self, paths=..., remote=..., fast=..., annex_options=..., git_options=...):
        """Front-end for git-annex fsck

        Parameters
        ----------
        paths : list
          Limit operation to specific paths.
        remote : str
          If given, the identified remote will be fsck'ed instead of the
          local repository.
        fast : bool
          If True, typically means that no actual content is being verified,
          but tests are limited to the presence of files.
        """
        ...
    
    @normalize_paths(match_return_type=False)
    def copy_to(self, files, remote, options=..., jobs=...): # -> list[Unknown]:
        """Copy the actual content of `files` to `remote`

        Parameters
        ----------
        files: str or list of str
            path(s) to copy
        remote: str
            name of remote to copy `files` to

        Returns
        -------
        list of str
           files successfully copied
        """
        ...
    
    @property
    def uuid(self): # -> None:
        """Annex UUID

        Returns
        -------
        str
          Returns a the annex UUID, if there is any, or `None` otherwise.
        """
        ...
    
    def get_description(self, uuid=...): # -> None:
        """Get annex repository description

        Parameters
        ----------
        uuid : str, optional
          For which remote (based on uuid) to report description for

        Returns
        -------
        str or None
          None returned if not found
        """
        ...
    
    def get_metadata(self, files, timestamps=..., batch=...): # -> Generator[tuple[Unknown, Unknown | dict[Unknown, Unknown]], None, None]:
        """Query git-annex file metadata

        Parameters
        ----------
        files : str or iterable(str)
          One or more paths for which metadata is to be queried. If one
          or more paths could be directories, `batch=False` must be given
          to prevent git-annex given an error. Due to technical limitations,
          such error will lead to a hanging process.
        timestamps: bool, optional
          If True, the output contains a '<metadatakey>-lastchanged'
          key for every metadata item, reflecting the modification
          time, as well as a 'lastchanged' key with the most recent
          modification time of any metadata item.
        batch: bool, optional
          If True, a `metadata --batch` process will be used, and only
          confirmed annex'ed files can be queried (else query will hang
          indefinitely). If False, invokes without --batch, and gives all files
          as arguments (this can be problematic with a large number of files).

        Returns
        -------
        generator
          One tuple per file (could be more items than input arguments
          when directories are given). First tuple item is the filename,
          second item is a dictionary with metadata key/value pairs. Note that annex
          metadata tags are stored under the key 'tag', which is a
          regular metadata item that can be manipulated like any other.
        """
        ...
    
    def set_metadata(self, files, reset=..., add=..., init=..., remove=..., purge=..., recursive=...): # -> list[Unknown]:
        """Manipulate git-annex file-metadata

        Parameters
        ----------
        files : str or list(str)
          One or more paths for which metadata is to be manipulated.
          The changes applied to each file item are uniform. However,
          the result may not be uniform across files, depending on the
          actual operation.
        reset : dict, optional
          Metadata items matching keys in the given dict are (re)set
          to the respective values.
        add : dict, optional
          The values of matching keys in the given dict appended to
          any possibly existing values. The metadata keys need not
          necessarily exist before.
        init : dict, optional
          Metadata items for the keys in the given dict are set
          to the respective values, if the key is not yet present
          in a file's metadata.
        remove : dict, optional
          Values in the given dict are removed from the metadata items
          matching the respective key, if they exist in a file's metadata.
          Non-existing values, or keys do not lead to failure.
        purge : list, optional
          Any metadata item with a key matching an entry in the given
          list is removed from the metadata.
        recursive : bool, optional
          If False, fail (with CommandError) when directory paths
          are given as `files`.

        Returns
        -------
        list
          JSON obj per modified file
        """
        ...
    
    def set_metadata_(self, files, reset=..., add=..., init=..., remove=..., purge=..., recursive=...): # -> Generator[Unknown, None, None]:
        """Like set_metadata() but returns a generator"""
        ...
    
    def get_content_annexinfo(self, paths=..., init=..., ref=..., eval_availability=..., key_prefix=..., **kwargs): # -> OrderedDict[Unknown, Unknown] | str:
        """
        Parameters
        ----------
        paths : list
          Specific paths to query info for. In none are given, info is
          reported for all content.
        init : 'git' or dict-like or None
          If set to 'git' annex content info will amend the output of
          GitRepo.get_content_info(), otherwise the dict-like object
          supplied will receive this information and the present keys will
          limit the report of annex properties. Alternatively, if `None`
          is given, no initialization is done, and no limit is in effect.
        ref : gitref or None
          If not None, annex content info for this Git reference will be
          produced, otherwise for the content of the present worktree.
        eval_availability : bool
          If this flag is given, evaluate whether the content of any annex'ed
          file is present in the local annex.
        **kwargs :
          Additional arguments for GitRepo.get_content_info(), if `init` is
          set to 'git'.

        Returns
        -------
        dict
          Each content item has an entry under its relative path within
          the repository. Each value is a dictionary with properties:

          `type`
            Can be 'file', 'symlink', 'dataset', 'directory'
          `revision`
            SHASUM is last commit affecting the item, or None, if not
            tracked.
          `key`
            Annex key of a file (if an annex'ed file)
          `bytesize`
            Size of an annexed file in bytes.
          `has_content`
            Bool whether a content object for this key exists in the local
            annex (with `eval_availability`)
          `objloc`
            pathlib.Path of the content object in the local annex, if one
            is available (with `eval_availability`)
        """
        ...
    
    def annexstatus(self, paths=..., untracked=...): # -> OrderedDict[Unknown, Unknown] | str:
        ...
    


class BatchedAnnexes(SafeDelCloseMixin, dict):
    """Class to contain the registry of active batch'ed instances of annex for
    a repository
    """
    def __init__(self, batch_size=..., git_options=...) -> None:
        ...
    
    def get(self, codename, annex_cmd=..., **kwargs):
        ...
    
    def clear(self): # -> None:
        """Override just to make sure we don't rely on __del__ to close all
        the pipes"""
        ...
    
    def close(self): # -> None:
        """Close communication to all the batched annexes

        It does not remove them from the dictionary though
        """
        ...
    


def readlines_until_ok_or_failed(stdout, maxlines=...): # -> LiteralString:
    """Read stdout until line ends with ok or failed"""
    ...

def readline_json(stdout): # -> Any | dict[Unknown, Unknown]:
    ...

@auto_repr
class BatchedAnnex(BatchedCommand):
    """Container for an annex process which would allow for persistent communication
    """
    def __init__(self, annex_cmd, git_options=..., annex_options=..., path=..., json=..., output_proc=...) -> None:
        ...
    


class ProcessAnnexProgressIndicators:
    """'Filter' for annex --json output to react to progress indicators

    Instance of this beast should be passed into log_stdout option
    for git-annex commands runner
    """
    def __init__(self, expected=...) -> None:
        """

        Parameters
        ----------
        expected: dict, optional
           key -> size, expected entries (e.g. downloads)
        """
        ...
    
    def start(self): # -> None:
        ...
    
    def __getitem__(self, id_):
        ...
    
    def __call__(self, line):
        ...
    
    def finish(self, partial=...): # -> None:
        ...
    



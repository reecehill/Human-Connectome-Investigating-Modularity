"""
This type stub file was generated by pyright.
"""

def nepusz_modularity(G, cover):
    ...

def zhang_modularity(G, cover):
    ...

def nicosia_modularity(G, cover):
    ...

def count_communities(G, cover): # -> dict[Any, int]:
    """
    Helper for lazar_modularity.
    Returns a dict {v:count} where v is a vertex id and
    count is the number of different communities it is
    assigned to.
    """
    ...

def get_weights(G): # -> list[int]:
    """
    Given a graph G, returns a list of weights. If the graph is unweighted,
    returns a list of 1s the same length as the number of edges.
    """
    ...

def get_single_lazar_modularity(G, community, weights, counts): # -> float | Literal[0]:
    """
    Returns the lazar modularity of a single algorithms.
    """
    ...

def lazar_modularity(G, cover): # -> float:
    """
    Returns the crisp modularity measure as defined by Lazar et al. 2009
    Defined as the average edge density times normalized difference
    between inter and intracommunity edges for each algorithms.
    See CONGA 2010 or Lazar's paper for a precise definition.
    """
    ...

class CrispOverlap:
    """
    TODO
    """
    def __init__(self, graph, covers, modularities=..., optimal_count=..., modularity_measure=...) -> None:
        """
        Initializes a CrispOverlap object with the given parameters.
            Graph: The graph to which the object refers
            covers: a dict of VertexCovers, also referring to this graph, of the form {k : v}
                where k is the number of clusters and v is the vertexCluste
            modularities (optional): a dict of modularities of the form {c:m} where c is
                the number of clusters and m is the modularity.
            optimal_count (optional): A hint for the number of clusters to use.
            modularity_measure (optional): The name of the modularity function to use.
                Right now, the only choice is "lazar."
        """
        ...
    
    def __getitem__(self, numClusters):
        """
        Returns the cover with the given number of clusters.
        """
        ...
    
    def __iter__(self): # -> Generator[Any, None, None]:
        """
        Iterates over the covers in the list.
        """
        ...
    
    def __len__(self): # -> int:
        """
        Returns the number of covers in the list.
        """
        ...
    
    def __bool__(self): # -> bool:
        """
        Returns True when there is at least one cover in the list.
        """
        ...
    
    def __str__(self) -> str:
        """
        Returns a string representation of the list of covers.
        """
        ...
    
    def as_cover(self):
        """
        Returns the optimal cover (by modularity) from the object.
        """
        ...
    
    def recalculate_modularities(self): # -> dict[Any, Any]:
        """
        Recalculates the modularities and optimal count using the modularity_measure.
        """
        ...
    
    @property
    def modularities(self): # -> dict[Any, Any]:
        """
        Returns the a dict {c : m} where c is the number of clusters
        in the cover and m is the modularity. If modularity has not
        been calculated, it recalculates it for all covers. Otherwise,
        it returns the stored dict.
        Note: Call recalculate_modularities to recalculate the modularity.
        """
        ...
    
    @property
    def optimal_count(self):
        """Returns the optimal number of clusters for this dendrogram.
        If an optimal count hint was given at construction time and
        recalculate_modularities has not been called, this property simply returns the
        hint. If such a count was not given, this method calculates the optimal cover
        by maximizing the modularity along all possible covers in the object.
        Note: Call recalculate_modularities to recalculate the optimal count.
        """
        ...
    
    def pretty_print_cover(self, numClusters, label=...): # -> None:
        """
        Takes a cover in vertex-id form and prints it nicely
        using label as each vertex's name.
        """
        ...
    
    def make_fuzzy(self): # -> None:
        """
        TODO. see CONGA 2010
        """
        ...
    


def congo(OG, h=...): # -> CrispOverlap:
    """
    Provides an Implementation of the CONGO algorithm defined by Steve Gregory
    in his 2010 paper "A Fast Algorithm to Find Overlapping Communities in Networks."
    The parameters are OG, the graph on which the analysis is to be performed, and h,
    the length of the longest shortest path that Congo is to consider.
    """
    ...

def delete_edge(G, edge, h): # -> bool:
    """
    Given a graph G and one of its edges in tuple form, checks if the deletion
    splits the graph.
    """
    ...

def fix_pair_betweennesses(G): # -> None:
    """
    Given a graph G, makes sure that all of the pair betweennesses
    listed as attributes remain possible, and removes those that are not.
    Also adds new attributes where new edges have been added.
    """
    ...

def fix_edge_betweennesses(G): # -> None:
    """
    Given a graph G, makes sure that every edge has a betweenness
    score assigned to it.
    """
    ...

def fix_betweennesses(G): # -> None:
    """
    Fixes the pair and edge betweennesses such that every attribute is up to date.
    """
    ...

def split_vertex(G, vToSplit, instr, h): # -> bool:
    """
    Splits the vertex v into two new vertices, each with
    edges depending on s. Returns True if the split
    divided the graph, else False.
    """
    ...

def max_split_betweenness(G, vInteresting): # -> tuple[Any | Literal[0], Any, Any | list[list[Any]]] | None:
    """
    Performs the greedy algorithm discussed in the 2007 CONGA paper
    to approximate the maximum split betweenness. Returns a tuple
    (a, b, c) where a is the maximum score, b the vertex to split
    to acheive the score, and c a list of the instructions for which
    neighbors to connect to each side of the split.
    """
    ...

def do_initial_betweenness(G, h): # -> None:
    """
    Given a graph G and a depth h, calculates all edge and pair betweennesses
    and updates G's attributes to reflect the new scores.
    """
    ...

def do_local_betweenness(G, neighborhood, h, op=...): # -> None:
    """
    Given a neighborhood and depth h, recalculates all betweennesses
    confined to the neighborhood. If op is operator.neg, it subtracts these
    betweennesses from the current ones. Otherwise, it adds them.
    """
    ...

def update_betweenness(G, path, count, op): # -> None:
    """
    Given a shortest path in G, along with a count of paths
    that length, to determine weight, updates the edge and
    pair betweenness dicts with the path's new information.
    """
    ...

def get_cover(G, OG, comm):
    """
    Given the graph, the original graph, and a algorithms
    membership list, returns a vertex cover of the communities
    referring back to the original algorithms.
    """
    ...

def vertex_betweeenness_from_eb(G, eb): # -> list[Any]:
    """
    Calculates the vertex betweenness scores in G. Returns a list
    in which the indices are the vertex indices and the values are
    their betweeennesses. The same as G.betweenness(), but faster because
    it uses the edge betweenness scores.
    (CONGA, page 4, equation 1)
    """
    ...

def get_neighborhood_vertex(G, v, h):
    """
    Given a vertex and a height/depth to
    traverse, find the neighborhood as defined in the CONGA
    paper.
    """
    ...

def get_neighborhood_edge(G, e, h): # -> list[Any]:
    """
    Given an edge and a height/depth to
    traverse, find the neighborhood as defined in the CONGA
    paper.
    """
    ...

def order_tuple(toOrder): # -> tuple[Any, Any]:
    ...

def create_clique(G, v, pb): # -> NDArray[float64]:
    """
    Given a vertex and its pair betweennesses, returns a k-clique
    representing all of its neighbors, with edge weights determined by the pair
    betweenness scores. Algorithm discussed on page 5 of the CONGA paper.
    """
    ...

def reduce_matrix(M): # -> tuple[Any, Any, NDArray[Any]]:
    """
    Given a matrix M, collapses the row and column of the minimum value. This is just
    an adjacency matrix way of implementing the greedy "collapse" discussed in CONGA.
    Returns the new matrix and the collapsed indices.
    """
    ...

def check_for_split(G, edge): # -> bool:
    """
    Given an edge in tuple form, check if it splits the
    graph into two disjoint clusters. If so, it returns
    True. Otherwise, False.
    """
    ...

def mat_min(M): # -> tuple[Any, Any]:
    """
    Given a matrix, find an index of the minimum value (not including the
    diagonal).
    """
    ...

def matrix_min(mat): # -> tuple[int, Any]:
    """
    Given a symmetric matrix, find an index of the minimum value
    in the upper triangle (not including the diagonal.)
    """
    ...

def Congo_(graph, number_communities=..., height=...): # -> list[Any]:
    """

    :param graph:
    :param number_communities:
    :param height:The lengh of the longest shortest paths that CONGO considers
    :return:
    """
    ...


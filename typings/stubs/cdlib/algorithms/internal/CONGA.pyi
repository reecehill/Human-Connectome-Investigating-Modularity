"""
This type stub file was generated by pyright.
"""

def nepusz_modularity(G, cover):
    ...

def zhang_modularity(G, cover):
    ...

def nicosia_modularity(G, cover):
    ...

def count_communities(G, cover): # -> dict[Any, int]:
    """
    Helper for lazar_modularity.
    Returns a dict {v:count} where v is a vertex id and
    count is the number of different communities it is
    assigned to.
    """
    ...

def get_weights(G): # -> list[int]:
    """
    Given a graph G, returns a list of weights. If the graph is unweighted,
    returns a list of 1s the same length as the number of edges.
    """
    ...

def get_single_lazar_modularity(G, community, weights, counts): # -> float | Literal[0]:
    """
    Returns the lazar modularity of a single algorithms.
    """
    ...

def lazar_modularity(G, cover): # -> float:
    """
    Returns the crisp modularity measure as defined by Lazar et al. 2009
    Defined as the average edge density times normalized difference
    between inter and intracommunity edges for each algorithms.
    See CONGA 2010 or Lazar's paper for a precise definition.
    """
    ...

class CrispOverlap:
    """
    TODO
    """
    def __init__(self, graph, covers, modularities=..., optimal_count=..., modularity_measure=...) -> None:
        """
        Initializes a CrispOverlap object with the given parameters.
            Graph: The graph to which the object refers
            covers: a dict of VertexCovers, also referring to this graph, of the form {k : v}
                where k is the number of clusters and v is the vertexCluste
            modularities (optional): a dict of modularities of the form {c:m} where c is
                the number of clusters and m is the modularity.
            optimal_count (optional): A hint for the number of clusters to use.
            modularity_measure (optional): The name of the modularity function to use.
                Right now, the only choice is "lazar."
        """
        ...
    
    def __getitem__(self, numClusters):
        """
        Returns the cover with the given number of clusters.
        """
        ...
    
    def __iter__(self): # -> Generator[Any, None, None]:
        """
        Iterates over the covers in the list.
        """
        ...
    
    def __len__(self): # -> int:
        """
        Returns the number of covers in the list.
        """
        ...
    
    def __bool__(self): # -> bool:
        """
        Returns True when there is at least one cover in the list.
        """
        ...
    
    def __str__(self) -> str:
        """
        Returns a string representation of the list of covers.
        """
        ...
    
    def as_cover(self):
        """
        Returns the optimal cover (by modularity) from the object.
        """
        ...
    
    def recalculate_modularities(self): # -> dict[Any, Any]:
        """
        Recalculates the modularities and optimal count using the modularity_measure.
        """
        ...
    
    @property
    def modularities(self): # -> dict[Any, Any]:
        """
        Returns the a dict {c : m} where c is the number of clusters
        in the cover and m is the modularity. If modularity has not
        been calculated, it recalculates it for all covers. Otherwise,
        it returns the stored dict.
        Note: Call recalculate_modularities to recalculate the modularity.
        """
        ...
    
    @property
    def optimal_count(self):
        """Returns the optimal number of clusters for this dendrogram.
        If an optimal count hint was given at construction time and
        recalculate_modularities has not been called, this property simply returns the
        hint. If such a count was not given, this method calculates the optimal cover
        by maximizing the modularity along all possible covers in the object.
        Note: Call recalculate_modularities to recalculate the optimal count.
        """
        ...
    
    def pretty_print_cover(self, numClusters, label=...): # -> None:
        """
        Takes a cover in vertex-id form and prints it nicely
        using label as each vertex's name.
        """
        ...
    
    def make_fuzzy(self): # -> None:
        """
        TODO. see CONGA 2010
        """
        ...
    


def conga(OG, calculate_modularities=..., optimal_count=...): # -> CrispOverlap:
    """
    Defines the CONGA algorithm outlined in the Gregory 2007 paper
    (An Algorithm to Find Overlapping Community Structure in Networks)
    Returns a CrispOverlap object of all of the covers.
    """
    ...

def remove_edge_or_split_vertex(G): # -> bool:
    """
    The heart of the CONGA algorithm. Decides which edge should be
    removed or which vertex should be split. Returns True if the
    modification split the graph.
    """
    ...

def get_cover(G, OG, comm):
    """
    Given the graph, the original graph, and a algorithms
    membership list, returns a vertex cover of the communities
    referring back to the original algorithms.
    """
    ...

def delete_edge(G, edge): # -> bool:
    """
    Given a graph G and one of its edges in tuple form, checks if the deletion
    splits the graph.
    """
    ...

def check_for_split(G, edge): # -> bool:
    """
    Given an edge in tuple form, check if it splits the
    graph into two disjoint clusters. If so, it returns
    True. Otherwise, False.
    """
    ...

def split_vertex(G, v, splitInstructions): # -> bool:
    """
    Splits the vertex v into two new vertices, each with
    edges depending on s. Returns True if the split
    divided the graph, else False.
    """
    ...

def order_tuple(toOrder): # -> tuple[Any, Any]:
    """
    Given a tuple (a, b), returns (a, b) if a <= b,
    else (b, a).
    """
    ...

def update_betweenness(G, path, pair, count, relevant): # -> None:
    """
    Given a shortest path in G, along with a count of paths
    that length, to determine weight, updates the edge and
    pair betweenness dicts with the path's new information.
    """
    ...

def pair_betweenness(G, relevant): # -> dict[Any, dict[tuple[Any, Any], int]]:
    """
    Returns a dictionary of the pair betweenness of all vertices in relevant.
    The structure of the returned dictionary is dic[v][(u, w)] = c, where c
    is the number of shortest paths traverse through u, v, w.
    """
    ...

def create_clique(G, v, pb): # -> NDArray[float64]:
    """
    Given a vertex and its pair betweennesses, returns a k-clique
    representing all of its neighbors, with edge weights determined by the pair
    betweenness scores. Algorithm discussed on page 5 of the CONGA paper.
    """
    ...

def max_split_betweenness(G, dic): # -> tuple[Any | Literal[0], Any, Any | list[list[Any]]]:
    """
    Given a dictionary of vertices and their pair betweenness scores, uses the greedy
    algorithm discussed in the CONGA paper to find a (hopefully) near-optimal split.
    Returns a 3-tuple (vMax, vNum, vSpl) where vMax is the max split betweenness,
    vNum is the vertex with said split betweenness, and vSpl is a list of which
    vertices are on each side of the optimal split.
    """
    ...

def matrix_min(mat): # -> tuple[int, Any]:
    """
    Given a symmetric matrix, find an index of the minimum value
    in the upper triangle (not including the diagonal.)
    """
    ...

def mat_min(M): # -> tuple[Any, Any]:
    """
    Given a matrix, find an index of the minimum value (not including the
    diagonal).
    """
    ...

def reduce_matrix(M): # -> tuple[Any, Any, NDArray[Any]]:
    """
    Given a matrix M, collapses the row and column of the minimum value. This is just
    an adjacency matrix way of implementing the greedy "collapse" discussed in CONGA.
    Returns the new matrix and the collapsed indices.
    """
    ...

def pretty_print_cover(G, cover, label=...): # -> None:
    """
    Takes a cover in vertex-id form and prints it nicely
    using label as each vertex's name.
    """
    ...

def run_demo(): # -> None:
    """
    Finds the communities of the Zachary graph and gets the optimal one using
    Lazar's measure of modularity. Finally, pretty-prints the optimal cover.
    """
    ...

def main(): # -> None:
    ...

def Conga_(graph, number_communities=...): # -> list[Any]:
    """

    :param graph:
    :param number_communities:
    :return:
    """
    ...


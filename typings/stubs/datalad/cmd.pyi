"""
This type stub file was generated by pyright.
"""

from subprocess import TimeoutExpired
from typing import Any, Callable, List, Optional, Tuple, Union
from weakref import WeakValueDictionary
from datalad.runner.coreprotocols import StdOutErrCapture
from datalad.runner.protocol import GeneratorMixIn
from datalad.support.exceptions import CommandError
from datalad.utils import auto_repr

"""
Class the starts a subprocess and keeps it around to communicate with it
via stdin. For each instruction send over stdin, a response is read and
returned. The response structure is determined by "output_proc"

"""
__docformat__ = ...
_cfg_var = ...
_cfg_val = ...
class BatchedCommandError(CommandError):
    def __init__(self, cmd=..., last_processed_request=..., msg=..., code=..., stdout=..., stderr=..., cwd=..., **kwargs) -> None:
        """
        This exception extends a CommandError that is raised by the command,
        that is executed by `BatchedCommand`. It extends the `CommandError` by
        `last_processed_request`. This attribute contains the last request, i.e.
        argument to `BatchedCommand.__call__()`, that was successfully
        processed, i.e. for which a result was received from the command (that
        does not imply that the result was positive).

        :param last_processed_request: the last request for which a response was
            received from the underlying command. This could be used to restart
            an interrupted process.

        For all other arguments see `CommandError`.
        """
        ...
    


lgr = ...
linesep_bytes = ...
_TEMP_std = ...
_MAGICAL_OUTPUT_MARKER = ...
def readline_rstripped(stdout):
    ...

class BatchedCommandProtocol(GeneratorMixIn, StdOutErrCapture):
    def __init__(self, batched_command: BatchedCommand, done_future: Any = ..., encoding: Optional[str] = ..., output_proc: Optional[Callable] = ...) -> None:
        ...
    
    def pipe_data_received(self, fd: int, data: bytes): # -> None:
        ...
    
    def pipe_connection_lost(self, fd: int, exc: Optional[BaseException]): # -> None:
        ...
    
    def timeout(self, fd: Optional[int]) -> bool:
        ...
    


class ReadlineEmulator:
    """
    This class implements readline() on the basis of an instance of
    BatchedCommand. Its purpose is to emulate stdout's for output_procs,
    This allows us to provide a BatchedCommand API that is identical
    to the old version, but with an implementation that is based on the
    threaded runner.
    """
    def __init__(self, batched_command: BatchedCommand) -> None:
        ...
    
    def readline(self): # -> str | None:
        """
        Read from the stdout provider until we have a line or None (which
        indicates some error).
        """
        ...
    


class SafeDelCloseMixin:
    """A helper class to use where __del__ would call .close() which might
    fail if "too late in GC game"
    """
    def __del__(self): # -> None:
        ...
    


@auto_repr
class BatchedCommand(SafeDelCloseMixin):
    """
    Container for a running subprocess. Supports communication with the
    subprocess via stdin and stdout.
    """
    _active_instances: WeakValueDictionary[int, BatchedCommand] = ...
    def __init__(self, cmd: Union[str, Tuple, List], path: Optional[str] = ..., output_proc: Optional[Callable] = ..., timeout: Optional[float] = ..., exception_on_timeout: bool = ...) -> None:
        ...
    
    @classmethod
    def clean_inactive(cls): # -> None:
        ...
    
    def process_running(self) -> bool:
        ...
    
    def __call__(self, cmds: Union[str, Tuple, List]): # -> list[Any] | None:
        """
        Send requests to the subprocess and return the responses. We expect one
        response per request. How the response is structured is determined by
        output_proc. If output_proc returns not-None, the responses is
        considered to be a response.

        If output_proc is not provided, we assume that a single response is
        a single line.

        If the subprocess does not exist yet it is started before the first
        command is sent.

        Parameters
        ----------
        cmds : str or tuple or list of (str or tuple)
            request for the subprocess

        Returns
        -------
        (return_type[self.output_proc] | str)
        | list[(return_type[self.output_proc] | str)]

            Responses received from process. Either a single element, or a list
            of elements, if `cmds` was a list.
            The type of the elements is `str`, if `self.output_proc` is `None`.
            If `self.output_proc` is not `None`, the result type of
            `self.output_proc` determines the type of the elements.
        """
        ...
    
    def process_request(self, request: Union[Tuple, str]) -> Any | None:
        ...
    
    def proc1(self, single_command: str): # -> list[Any] | None:
        """
        Simulate the old interface. This method is used only once in
        AnnexRepo.get_metadata()
        """
        ...
    
    def get_one_line(self) -> Optional[str]:
        """
        Get a single stdout line from the generator.

        If timeout was specified, and exception_on_timeout is False,
        and if a timeout occurs, return None. Otherwise, return the
        string that was read from the generator.
        """
        ...
    
    def close(self, return_stderr=...): # -> str | None:
        """
        Close communication and wait for process to terminate. If the "timeout"
        parameter to the constructor was not None, and if the configuration
        setting "datalad.runtime.stalled-external" is set to "abandon",
        the method will return latest after "timeout" seconds. If the subprocess
        did not exit within this time, the attribute "wait_timed_out" will
        be set to "True".

        Parameters
        ----------
        return_stderr: bool
          if set to "True", the call will return all collected stderr content
          as string. In addition, if return_stderr is True and the log level
          is 5 or lower, and the configuration setting "datalad.log.outputs"
          evaluates to "True", the content of stderr will be logged.

        Returns
        -------
        str, optional
          stderr output if return_stderr is True, None otherwise
        """
        ...
    
    def get_requested_error_output(self, return_stderr: bool): # -> str | None:
        ...
    
    def get_timeout_exception(self, fd: Optional[int]) -> Optional[TimeoutExpired]:
        """
        Get a process timeout exception if timeout exceptions should
        be generated for a process that continues longer than timeout
        seconds after self.close() was initiated.
        """
        ...
    



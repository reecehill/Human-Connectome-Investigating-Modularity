%%
%  coordsIn3d = zeros(size(allFunctionalData.modules.threeDimensions),3);
%             % Create matrix where each element is a vector of coordinates.
%             coordsIn3d(sub2ind(size(coordsIn3d),xSubsection,ySubsection,zSubsection))=allFunctionalData.nodes.mni152(activeNodes);
addpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Collections\Iso2Mesh');
try
    addpath(genpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Toolboxes\Brain Connectivity Toolbox'));
    addpath(genpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Collections\SurfStat'));


    % Iterative community finetuning. W is the input connection matrix.
    close all;
    clearvars -except pathToParticipants subject roiStructuralData optimalGamma;
    pathToParticipants = 'D:\Dissertation\Participants';
    subject = 'sub-002';
    roiLabels = ["lh.precentral.label"]; % only supports single values for now.

    showTicksPer = 500;

    adj_matrix = matfile([pathToParticipants '\' subject '\matrices.mat']).adj_matrix;
    load([pathToParticipants '\' subject '\labelSRF.mat'],"nvl","nvr","nfl","nfr","glpfaces","glpvertex","grpfaces","grpvertex","faceROIidL","faceROIidR","subROIid","filenames","subfilenames");
    load([pathToParticipants '\' subject '\edgeList.mat'], "lpcentroids","rpcentroids");
    load([pathToParticipants '\' subject '\MNIcoor.mat'],"Coor_MNI152","Coor_MNI305");
    load([pathToParticipants '\' subject '\1stlevel\fMRIModules_0002.mat']);



    %generated by: 
    % mri_info --vox2ras-tkr ${SUBJECTS_DIR}/sub-002/data/func/task-HcpMotor_acq-ap_bold.nii
    tMov = [  -1.50000    0.00000    0.00000   96.00000;
   0.00000    0.00000    1.50000  -69.75000;
   0.00000   -1.50000    0.00000   96.00000;
   0.00000    0.00000    0.00000    1.00000;]

    Reg = table2array(readtable([pathToParticipants '/' subject ,'/data/func/register6.dat']));
    % To get tkrRAS coordinates from row,col,slice of fmri data:
    %colOfOnes = ones(size(funcXyzCoordinatesmm,1),1);

    
    
    %funcXyzCoordinatesmm = [funcXyzCoordinatesmm colOfOnes];
    %funcXyzCoordinatesmm = transpose(inv(rmmissing(Reg)) * tMov * funcXyzCoordinatesmm');

    % where REG was obtained by:
    %  tkregister2 --mov "${SUBJECTS_DIR}/sub-002/data/func/sartask-HcpMotor_acq-ap_bold.nii" --s sub-002/data/  --noedit --regheader --reg "${SUBJECTS_DIR}/sub-002/data/func/register6.dat" --targ "${SUBJECTS_DIR}/sub-002/data/bert/mri/orig.mgz"


 %Reg = table2array(readtable([pathToParticipants '/' subject ,'/data/func/register.dat']));
%inv(mri.hdr.tkrvox2ras)*rmmissing(Reg)*[-11.47 -8.37 56.88 1]'
    %% Convert label to label's index
    allFilenames = [filenames;transpose(subfilenames)];
    roiLabelIndexes = find(ismember(allFilenames,roiLabels));

    regionNameIds = [faceROIidL; faceROIidR+34; subROIid+34+17];
    allLabels = allFilenames(regionNameIds);


    baseStruct.adjacencyMatrix = [];
    baseStruct.nodes.ids = [];
    baseStruct.nodes.labels = [];
    baseStruct.nodes.moduleIds = []; % for each node, list its module id.
    baseStruct.nodes.mni152 = []; % the 3D coord of each node.
    baseStruct.nodes.threeDimensions = []; % module ids in 3d
    baseStruct.nodes.shape = [];
    baseStruct.modules.nodeIds = []; % the ids of all nodes WITH a module.
    baseStruct.modules.surfaceAreas = [];
    baseStruct.modules.centreOfMasses = [];
    baseStruct.modules.shapes = {};


    tempStoreOfStrucModuleIds = [];
    if(exist("roiStructuralData",'var') && exist("optimalGamma",'var'))
        tempStoreOfStrucModuleIds = roiStructuralData.nodes.moduleIds;
        tempStoreOfOptimalGamma = optimalGamma;
    end

    allStructuralData = baseStruct;
    roiStructuralData = baseStruct;
    allFunctionalData = baseStruct;
    roiFunctionalData = baseStruct;
    allBrainData = baseStruct;
    roiBrainData = baseStruct;


    figure(1);
    hold all;
    
    
    %% All Brain data
    LBrainMesh.faces = nfl;
    LBrainMesh.faces_mni152 = Coor_MNI305(1:1:length(nfl),:);
    RBrainMesh.faces_mni152 = Coor_MNI305(length(nfl):1:length(nfr),:);
    %LBrainMesh.faces = glpfaces;
    LBrainMesh.vertices = nvl;
    %LBrainMesh.vertices = glpvertex;
    [LBrainMesh.nodes, LBrainMesh.elements] = meshcheckrepair(LBrainMesh.vertices,LBrainMesh.faces);
    LBrainMesh.edges = meshedge(LBrainMesh.elements);

    
    RBrainMesh.faces = nfr;
    %RBrainMesh.faces = grpfaces;
    RBrainMesh.vertices = nvr;
    %RBrainMesh.vertices = grpvertex;
    [RBrainMesh.nodes, RBrainMesh.elements] = meshcheckrepair(RBrainMesh.vertices,RBrainMesh.faces);
    RBrainMesh.edges = meshedge(RBrainMesh.elements);

    %% Create mock functional voxel vol.
    intensitiesPerVoxel_mock = ones(2,2,1);
    intensitiesPerVoxel_mock = padarray(intensitiesPerVoxel_mock,[63 63 46],0,'both');
    opt.keepratio = 1;
            %opt(1).maxnode = 5000;
            %opt.autoregion=0;
            %opt.radbound = 0;
            %opt.distbound  =0;

    xSubsection = 1:1:size(intensitiesPerVoxel_mock,1);
    ySubsection = 1:1:size(intensitiesPerVoxel_mock,2);
    zSubsection = 1:1:size(intensitiesPerVoxel_mock,3);
    %opt.radbound = 1;
    [no,el,regions,holes]=vol2surf(intensitiesPerVoxel,xSubsection,ySubsection,zSubsection,opt,1,'simplify',1);
    colOfOnes = ones(size(no,1),1);
    no = [no colOfOnes];
    no = transpose(inv(rmmissing(Reg)) * tMov * no');
    no(:,4) = []; %remove column of ones;
    modulePointCloud = pointCloud(no);
    figure;
    plotsurf(no,el,'FaceAlpha',0.5,'EdgeAlpha',0.5,'FaceColor','g');
    pcshow(modulePointCloud);

    %% ROI Brain data
    RFaceIndexesOfRoi = find(ismember(faceROIidR, roiLabelIndexes));
    RBrainMesh.roi.centroids = rpcentroids(RFaceIndexesOfRoi,:);
    
    LFaceIndexesOfRoi = find(ismember(faceROIidL, roiLabelIndexes));
    LBrainMesh.roi.centroids = lpcentroids(LFaceIndexesOfRoi,:);

    plotsurf(LBrainMesh.nodes,LBrainMesh.faces,'FaceAlpha',0.5,'EdgeAlpha',0.5);
    plotsurf(RBrainMesh.nodes,RBrainMesh.faces);
    plot3(LBrainMesh.roi.centroids(:,1),LBrainMesh.roi.centroids(:,2),LBrainMesh.roi.centroids(:,3),'r.');
    plot3(RBrainMesh.roi.centroids(:,1),RBrainMesh.roi.centroids(:,2),RBrainMesh.roi.centroids(:,3),'r.');
    %[node,elem,face]=vol2mesh(volimage,1:size(volimage,1),1:size(volimage,2),1:size(volimage,3),2,2,1);
[newnode,newface]=surfboolean(LBrainMesh.nodes,LBrainMesh.elements,'union',no,el);
    figure(3);
    
    hold all;
    plotsurf(newnode,newface,'FaceAlpha',0.3,'EdgeAlpha',0.3,'FaceColor','r');


    importedBrainData = spm_vol([pathToParticipants '/' subject '/data/bert/mri/' num2str(roiLabels(1))  '_mask.nii']);
    [threeDimensions, mni152] = spm_read_vols(importedBrainData);
    coordsWithData = mni152(:,find(threeDimensions>0));
    [~,roiBrainData.nodes.mni152] = getMNIFromRasCoords([pathToParticipants '/' subject],transpose(coordsWithData),2);
    %roiBrainData.nodes.mni152 = pcdownsample(pointCloud(transpose(coordsWithData)),"random",0.1).Location;
    roiBrainData.modules.shape = alphaShape(roiBrainData.nodes.mni152);
    [~,boundaryCoordsOfShape] = boundaryFacets(roiBrainData.modules.shape);
    roiBrainData.modules.centreOfMasses(1,:) = mean(roiBrainData.modules.shape.Points);
    clearvars importedBrainData threeDimensions mni152;

    %% Structural data
    % All structure data
    allStructuralData.nodes.ids = 1:1:length(allLabels);
    allStructuralData.nodes.mni152 = Coor_MNI152;
    %TODO: This is not in MNI152 space!
    %allStructuralData.nodes.mni152 = [lpcentroids;rpcentroids;subCoor];
    allStructuralData.modules.shape = alphaShape(allStructuralData.nodes.mni152);
    [~,boundaryCoordsOfShape] = boundaryFacets(allStructuralData.modules.shape);
    allStructuralData.modules.centreOfMasses(1,:) = mean(allStructuralData.modules.shape.Points);

    %% Offset structural data to match mask
    offset = [1.4390   -3.9076   17.9498];
    %offset = [-1.4390    3.9076  -17.9498];
    %offset = [0,0,0];
    %offset = [-0.5668    3.7624  -17.5733].*-1;
    %offset = allStructuralData.modules.centreOfMasses - allBrainData.modules.centreOfMasses;
    
    %allBrainData.modules.shape.Points = allBrainData.modules.shape.Points + repmat(offset(1,:),length(allBrainData.modules.shape.Points),1);
    %allBrainData.nodes.mni152 = allBrainData.nodes.mni152 + repmat(offset(1,:),length(allBrainData.nodes.mni152),1);
    %roiBrainData.modules.shape.Points = roiBrainData.modules.shape.Points + repmat(offset(1,:),length(roiBrainData.modules.shape.Points),1);
    %roiBrainData.nodes.mni152 = roiBrainData.nodes.mni152 + repmat(offset(1,:),length(roiBrainData.nodes.mni152),1);
    %roiBrainData.modules.centreOfMasses = roiBrainData.modules.centreOfMasses + repmat(offset(1,:),length(roiBrainData.modules.centreOfMasses),1);
    %clear Coor_MNI152;
    %allStructuralData.nodes.labels = allLabels;
    %allStructuralData.nodes.threeDimensions =
    %getThreeDimensions(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3));


    % Filtered structure data, of only those from ROI.
    roiStructuralData.nodes.ids = find(ismember(allLabels, roiLabels));
    roiStructuralData.adjacencyMatrix = adj_matrix(roiStructuralData.nodes.ids,roiStructuralData.nodes.ids);
    if(~isempty(tempStoreOfStrucModuleIds))
        roiStructuralData.nodes.moduleIds = tempStoreOfStrucModuleIds;
        optimalGamma = tempStoreOfOptimalGamma;
    else
        disp('Sorting structural data into modules...');
        %[roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, 0.78, 0.80);
        [roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, -0.02, 0);
    end
    roiStructuralData.nodes.labels = allLabels(roiStructuralData.nodes.ids);
    roiStructuralData.nodes.mni152 = allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:);
    clearvars tempStoreOfOptimalGamma tempStoreOfStrucModuleIds;


    %% Functional data
    allFunctionalData.nodes.mni152 = funcXyzCoordinatesmm;
    allFunctionalData.nodes.moduleIds = fmriModules(:); % for each node, list its module id.
    allFunctionalData.nodes.threeDimensions = intensitiesPerVoxel;
    allFunctionalData.modules.threeDimensions = fmriModules; % module ids in 3d
    allFunctionalData.modules.nodeIds = find(allFunctionalData.nodes.moduleIds>0); % the ids of all nodes with a module.
    clearvars fmriModules intensitiesPerVoxel xyzCoordinatesmm;

    % Filtered functional data, on only those from ROI. TO DO: filter
    % functional data to get only specific areas.


    %% Build shapes from coordinates.
    allStructuralData.modules.shape = alphaShape(allStructuralData.nodes.mni152);
    roiStructuralData.nodes.shape = alphaShape(roiStructuralData.nodes.mni152);
    for moduleIndex=1:max(roiStructuralData.nodes.moduleIds)
        activeNodes = find(roiStructuralData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            roiStructuralData.modules.shapes{moduleIndex} = alphaShape(roiStructuralData.nodes.mni152(activeNodes,:));
            shape = roiStructuralData.modules.shapes{moduleIndex};
            roiStructuralData.modules.surfaceAreas(moduleIndex) = surfaceArea(roiStructuralData.modules.shapes{moduleIndex});
            [~,boundaryCoordsOfShape] = boundaryFacets(roiStructuralData.modules.shapes{moduleIndex});
            roiStructuralData.modules.centreOfMasses(moduleIndex,:) = mean(roiStructuralData.modules.shapes{moduleIndex}.Points);
        else
            disp("Not draeing...")
        end
    end

    for moduleIndex=1:max(allFunctionalData.nodes.moduleIds)
        activeNodes = find(allFunctionalData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            [xSubsection,ySubsection,zSubsection] = ind2sub(size(allFunctionalData.modules.threeDimensions),activeNodes);
            
            %[node,elem,face]=vol2mesh(allFunctionalData.modules.threeDimensions==moduleIndex,xSubsection,ySubsection,zSubsection,2,2,1);
            opt.keepratio = 0.1;
            opt(1).maxnode = 5000;
            opt.autoregion=0;
            [no,el,regions,holes]=vol2surf(allFunctionalData.modules.threeDimensions==moduleIndex,xSubsection,ySubsection,zSubsection,opt,1,'simplify',1);
            modulePointCloud = pointCloud(no);

            figure(1);
            pcshow(modulePointCloud.Location);
            %plotsurf(node,face,'FaceColor','g','EdgeColor','k','EdgeAlpha',0.5,'FaceAlpha',0.5);
            coords = allFunctionalData.nodes.mni152(activeNodes,:);
            allFunctionalData.modules.shapes{moduleIndex} = alphaShape(coords);
            allFunctionalData.modules.surfaceAreas(moduleIndex) = surfaceArea(allFunctionalData.modules.shapes{moduleIndex});
            [~,boundaryCoordsOfShape] = boundaryFacets(allFunctionalData.modules.shapes{moduleIndex});
            allFunctionalData.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoordsOfShape);
        end
    end


    overlappingRegions = baseStruct;
    overlappingRegionIndex = 1;
    %% Find the functional modules shapes that overlap with structural modules.
    for strucShape=roiStructuralData.modules.shapes
        for funcShape=allFunctionalData.modules.shapes
            if(~isempty(funcShape{1}) && ~isempty(strucShape{1}))
                coords = inShape(strucShape{1},funcShape{1}.Points);
                overlappingCoordinates = funcShape{1}.Points(coords,:);
                if(~isempty(overlappingCoordinates))
                    % An overlapping area has been found. Build shape of
                    % the overlapping area.
                    overlappingRegions.modules.shapes{overlappingRegionIndex} = alphaShape(overlappingCoordinates);
                    [~,boundaryCoordsOfShape] = boundaryFacets(overlappingRegions.modules.shapes{overlappingRegionIndex});
                    overlappingRegions.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoordsOfShape);
                    overlappingRegions.modules.surfaceAreas(overlappingRegionIndex) = surfaceArea(overlappingRegions.modules.shapes{overlappingRegionIndex});
                    overlappingRegionIndex = overlappingRegionIndex + 1;
                end
            end
        end
    end

    figure
    plot(alphaShape(glpvertex));
    hold on;
    plot(allBrainData.modules.shape,'FaceColor','r');

    totalSurfaceAreaOfAllModules = sum(roiStructuralData.modules.surfaceAreas,'all') + sum(allFunctionalData.modules.surfaceAreas,'all');
    totalSurfaceAreaOfOverlappingRegions = sum(overlappingRegions.modules.surfaceAreas,'all');
    percentageCover = (totalSurfaceAreaOfOverlappingRegions/totalSurfaceAreaOfAllModules)*100;

    figure2 = figure;
    plottedLabels = allStructuralData.nodes.labels(1:showTicksPer:end);
    spy(adj_matrix);
    rectangle('Position',[min(roiStructuralData.nodes.ids) min(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids)], 'EdgeColor','red')
    xticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Global network - connectivity matrix')
    subtitle('Square shows local connectivity (figure 2)')

    figure(2);
    plottedLabels = roiStructuralData.nodes.labels(1:showTicksPer:end);
    spy(roiStructuralData.adjacencyMatrix);
    xticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Local network (lSF-lSP) - connectivity matrix')



    nStrucModulesToPlot = max(roiStructuralData.nodes.moduleIds,[],'all') - unique(roiStructuralData.nodes.moduleIds);
    nFuncModulesToPlot = max(allFunctionalData.nodes.moduleIds,[],'all') - unique(allFunctionalData.nodes.moduleIds);
    nThingsToPlot = length(nStrucModulesToPlot)+length(nFuncModulesToPlot);
    strucColorMap = colormap(jet(nThingsToPlot));
    funcColorMap = flipud(strucColorMap);


    figure('Name',"Shape Map");
    subtitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma) ' | % cover: ' num2str(percentageCover) '%']);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    %plot(allBrainData.nodes.shape,'FaceColor',[0.8 0.15 0.15],'FaceAlpha',0.6,'BackFaceLighting','lit','FaceLighting','gouraud','EdgeColor','none','DisplayName','Brain from mask');
    %plot(allStructuralData.modules.shape,'FaceColor',[0.1 0.8 0.1],'FaceAlpha',0.6,'EdgeColor','none','DisplayName','Brain from structural nodes','AmbientStrength',0.5,'AlignVertexCenters','on','FaceLighting','flat');
    plot(roiBrainData.modules.shape,'FaceColor',[0.1 0.8 0.8],'FaceAlpha',0.6,'EdgeColor','none','DisplayName','ROI from mask','AmbientStrength',0.5,'AlignVertexCenters','on','FaceLighting','flat');
    plot3(roiStructuralData.modules.centreOfMasses(:,1),roiStructuralData.modules.centreOfMasses(:,2),roiStructuralData.modules.centreOfMasses(:,3),'*','MarkerSize',10,'Color','g','DisplayName','Struc COM');

    plot3(roiBrainData.modules.centreOfMasses(:,1),roiBrainData.modules.centreOfMasses(:,2),roiBrainData.modules.centreOfMasses(:,3),'*','MarkerSize',10,'Color','r','DisplayName','ROIMask COM');
    strucModule = 1;
    for shapeToPlot=roiStructuralData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            hold on;
        end
        strucModule = strucModule + 1;

    end

    funcModule = 1;
    for shapeToPlot=allFunctionalData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['fMRI Module #' num2str(funcModule)])
            hold on;
        end
        funcModule = funcModule + 1;
    end

    overlappingRegion = 1;
    for shapeToPlot=overlappingRegions.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(overlappingRegion,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['Overlap #' num2str(overlappingRegion)])
            hold on;
        end
        overlappingRegion = overlappingRegion + 1;
    end

    %% Visualise overlap
    figure(6);
    subtitle(['DWI- and fMRI-derived "modules" in MNI152 space']);
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucModules = find(roiStructuralData.nodes.moduleIds(:)==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucModules,:);
        centrePoint = mean(activeStrucModuleCoords);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            plot3(centrePoint(:,1),centrePoint(:,2),centrePoint(:,3),'*','Color','k','HandleVisibility','off');
        end
        %plot3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'^','DisplayName',['DWI
        %Module #' num2str(strucModule)]);
        hold on;
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no
        % activation).
        if(funcModule>0)
            roiFunctionalData.modules.byId = find(allFunctionalData.nodes.moduleIds(:)==funcModule);
            activeFmriModuleCoords = allFunctionalData.nodes.mni152(roiFunctionalData.modules.byId,:);
            plot3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','Color',funcColorMap(funcModule,:),'DisplayName',['fMRI Module #' num2str(funcModule)]);
            hold on;
        end
    end


    figure(7);
    %suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on; legend on;
    %circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    %roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1).* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4,.4, .4]);
    boundaryOfBrain = boundary(allStructuralData.nodes.mni152,1);
    trisurf(boundaryOfBrain,allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),'FaceColor',[0.1,0.1,0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area') %hold on;
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            %surf(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',cmap(strucModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation).
        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);

        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end



    figure(8);
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]); subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on;
    legend on;
    circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1) .* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4, .4, .4]);
    plot(allStructuralData.modules.shape,'FaceColor',[0.1 0.1 0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    %boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area')
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        activeStrucModuleShape = alphaShape(activeStrucModuleCoords);
        activeStrucModuleCentre = mean(activeStrucModuleCoords);
        activeStrucModuleSurfaceArea = surfaceArea(activeStrucModuleShape);

        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(activeStrucModuleShape))
            plot(activeStrucModuleShape,'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation). if(funcModule>0)

        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);
        activeFuncModuleShape = alphaShape(activeFmriModuleCoords);
        if(~isempty(boundaryOfModule))
            plot(activeFuncModuleShape,'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end


    %% Visualise strucModules
    %     figure1 = figure;
    %     hold on;
    %     moduleIndex = min(roiStructuralData.nodes.moduleIds); % For each module
    %     cmap = hsv(length(roiStructuralData.nodes.moduleIds));
    %     for i = transpose(roiStructuralData.nodes.moduleIds)
    %         % Get ids of nodes that are in this module.
    %         nodeIds = find(roiStructuralData.nodes.moduleIds == i);
    %         nodesByModule = zeros(size(roiStructuralData.adjacencyMatrix));
    %
    %         nodesByModule(nodeIds, nodeIds) = 1;
    %         spy(nodesByModule);
    %         x=get(gca,'children');
    %         lastX = length(x);
    %         color = [cmap(lastX,:)];
    %         set(x(lastX),'color',color);
    %     end
    sound(sin(1:1000)); pause(0.2); sound(sin(1:1000));
catch ME
    sound(tan(1:1000)); pause(0.2); sound(tan(1:1000));
    rethrow(ME);
end

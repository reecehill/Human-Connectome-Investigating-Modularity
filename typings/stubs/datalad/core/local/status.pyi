"""
This type stub file was generated by pyright.
"""

from datalad.interface.base import Interface, build_doc, eval_results
from datalad.distribution.dataset import datasetmethod

"""Report status of a dataset (hierarchy)'s work tree"""
__docformat__ = ...
lgr = ...
_common_diffstatus_params = ...
STATE_COLOR_MAP = ...
def yield_dataset_status(ds, paths, annexinfo, untracked, recursion_limit, queried, eval_submodule_state, eval_filetype, cache, reporting_order): # -> Generator[dict[str, str] | Any, Any, None]:
    """Internal helper to obtain status information on a dataset

    Parameters
    ----------
    ds : Dataset
      Dataset to get the status of.
    path : Path-like, optional
      Paths to constrain the status to (see main status() command).
    annexinfo : str
      Annex information reporting mode (see main status() command).
    untracked : str, optional
      Reporting mode for untracked content (see main status() command).
    recursion_limit : int, optional
    queried : set
      Will be populated with a Path instance for each queried dataset.
    eval_submodule_state : str
      Submodule evaluation mode setting for Repo.diffstatus().
    eval_filetype : bool, optional
      THIS OPTION IS IGNORED. It will be removed in a future release.
    cache : dict
      Cache to be passed on to all Repo.diffstatus() calls to avoid duplicate
      queries.
    reporting_order : {'depth-first', 'breadth-first'}, optional
      By default, subdataset content records are reported after the record
      on the subdataset's submodule in a superdataset (depth-first).
      Alternatively, report all superdataset records first, before reporting
      any subdataset content records (breadth-first).

    Yields
    ------
    dict
      DataLad result records.
    """
    ...

@build_doc
class Status(Interface):
    """Report on the state of dataset content.

    This is an analog to `git status` that is simultaneously crippled and more
    powerful. It is crippled, because it only supports a fraction of the
    functionality of its counter part and only distinguishes a subset of the
    states that Git knows about. But it is also more powerful as it can handle
    status reports for a whole hierarchy of datasets, with the ability to
    report on a subset of the content (selection of paths) across any number
    of datasets in the hierarchy.

    *Path conventions*

    All reports are guaranteed to use absolute paths that are underneath the
    given or detected reference dataset, regardless of whether query paths are
    given as absolute or relative paths (with respect to the working directory,
    or to the reference dataset, when such a dataset is given explicitly).
    Moreover, so-called "explicit relative paths" (i.e. paths that start with
    '.' or '..') are also supported, and are interpreted as relative paths with
    respect to the current working directory regardless of whether a reference
    dataset with specified.

    When it is necessary to address a subdataset record in a superdataset
    without causing a status query for the state _within_ the subdataset
    itself, this can be achieved by explicitly providing a reference dataset
    and the path to the root of the subdataset like so::

      datalad status --dataset . subdspath

    In contrast, when the state of the subdataset within the superdataset is
    not relevant, a status query for the content of the subdataset can be
    obtained by adding a trailing path separator to the query path (rsync-like
    syntax)::

      datalad status --dataset . subdspath/

    When both aspects are relevant (the state of the subdataset content
    and the state of the subdataset within the superdataset), both queries
    can be combined::

      datalad status --dataset . subdspath subdspath/

    When performing a recursive status query, both status aspects of subdataset
    are always included in the report.


    *Content types*

    The following content types are distinguished:

    - 'dataset' -- any top-level dataset, or any subdataset that is properly
      registered in superdataset
    - 'directory' -- any directory that does not qualify for type 'dataset'
    - 'file' -- any file, or any symlink that is placeholder to an annexed
      file when annex-status reporting is enabled
    - 'symlink' -- any symlink that is not used as a placeholder for an annexed
      file

    *Content states*

    The following content states are distinguished:

    - 'clean'
    - 'added'
    - 'modified'
    - 'deleted'
    - 'untracked'
    """
    result_renderer = ...
    _examples_ = ...
    _params_ = ...
    @staticmethod
    @datasetmethod(name='status')
    @eval_results
    def __call__(path=..., *, dataset=..., annex=..., untracked=..., recursive=..., recursion_limit=..., eval_subdataset_state=..., report_filetype=...): # -> Generator[dict[str, str | tuple[Literal['path not underneath the reference dataset %s'], Any] | Logger] | dict[str, Any | list[Any]] | dict[str, str], Any, None]:
        ...
    
    @staticmethod
    def custom_result_renderer(res, **kwargs): # -> None:
        ...
    
    @staticmethod
    def custom_result_summary_renderer(results): # -> None:
        ...
    


def get_paths_by_ds(refds, dataset_arg, paths, subdsroot_mode=...): # -> tuple[dict[Any, Any], list[Any]]:
    """Resolve and sort any paths into their containing datasets

    Any path will be associated (sorted into) its nearest containing dataset.
    It is irrelevant whether or not a path presently exists on the file system.
    However, only datasets that exist on the file system are used for
    sorting/association -- known, but non-existent subdatasets are not
    considered.

    Parameters
    ----------
    refds: Dataset
    dataset_arg: Dataset or str or Path or None
      Any supported value given to a command's `dataset` argument. Given
      to `resolve_path()`.
    paths: list
      Any number of absolute or relative paths, in str-form or as
      Path instances, to be sorted into their respective datasets. See also
      the `subdsroot_mode` parameter.
    subdsroot_mode: {'rsync', 'super', 'sub'}
      Switch behavior for paths that are the root of a subdataset. By default
      ('rsync'), such a path is associated with its parent/superdataset,
      unless the path ends with a trailing directory separator, in which case
      it is sorted into the subdataset record (this resembles the path
      semantics of rsync, hence the label). In 'super' mode, the path is always
      placed with the superdataset record. Likewise, in 'sub' mode the path
      is always placed into the subdataset record.

    Returns
    -------
    dict, list
      The first return value is the main result, a dictionary with root
      directories of all discovered datasets as keys and a list of the
      associated paths inside these datasets as values.  Keys and values are
      normalized to be Path instances of absolute paths.
      The second return value is a list of all paths (again Path instances)
      that are not located underneath the reference dataset.
    """
    ...


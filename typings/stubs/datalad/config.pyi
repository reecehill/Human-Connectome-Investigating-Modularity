"""
This type stub file was generated by pyright.
"""

from functools import lru_cache

"""
"""
lgr = ...
cfg_kv_regex = ...
cfg_section_regex = ...
cfg_sectionoption_regex = ...
_where_reload_doc = ...
@lru_cache()
def get_git_version(runner=...): # -> str:
    """Return version of available git"""
    ...

def anything2bool(val): # -> bool:
    ...

class ConfigManager:
    """Thin wrapper around `git-config` with support for a dataset configuration.

    The general idea is to have an object that is primarily used to read/query
    configuration option.  Upon creation, current configuration is read via one
    (or max two, in the case of the presence of dataset-specific configuration)
    calls to `git config`.  If this class is initialized with a Dataset
    instance, it supports reading and writing configuration from
    ``.datalad/config`` inside a dataset too. This file is committed to Git and
    hence useful to ship certain configuration items with a dataset.

    The API aims to provide the most significant read-access API of a
    dictionary, the Python ConfigParser, and GitPython's config parser
    implementations.

    This class is presently not capable of efficiently writing multiple
    configurations items at once.  Instead, each modification results in a
    dedicated call to `git config`. This author thinks this is OK, as he
    cannot think of a situation where a large number of items need to be
    written during normal operation. If such need arises, various solutions are
    possible (via GitPython, or an independent writer).

    Each instance carries a public `overrides` attribute. This dictionary
    contains variables that override any setting read from a file. The overrides
    are persistent across reloads, and are not modified by any of the
    manipulation methods, such as `set` or `unset`.

    Any DATALAD_* environment variable is also presented as a configuration
    item. Settings read from environment variables are not stored in any of the
    configuration file, but are read dynamically from the environment at each
    `reload()` call. Their values take precedence over any specification in
    configuration files, and even overrides.

    Parameters
    ----------
    dataset : Dataset, optional
      If provided, all `git config` calls are executed in this dataset's
      directory. Moreover, any modifications are, by default, directed to
      this dataset's configuration file (which will be created on demand)
    dataset_only : bool
      Legacy option, do not use.
    overrides : dict, optional
      Variable overrides, see general class documentation for details.
    source : {'any', 'local', 'dataset', 'dataset-local'}, optional
      Which sources of configuration setting to consider. If 'dataset',
      configuration items are only read from a dataset's persistent
      configuration file, if any is present (the one in ``.datalad/config``, not
      ``.git/config``); if 'local', any non-committed source is considered
      (local and global configuration in Git config's terminology);
      if 'dataset-local', persistent dataset configuration and local, but
      not global or system configuration are considered; if 'any'
      all possible sources of configuration are considered.
    """
    _checked_git_identity = ...
    def __init__(self, dataset=..., dataset_only=..., overrides=..., source=...) -> None:
        ...
    
    def reload(self, force=...): # -> None:
        """Reload all configuration items from the configured sources

        If `force` is False, all files configuration was previously read from
        are checked for differences in the modification times. If no difference
        is found for any file no reload is performed. This mechanism will not
        detect newly created global configuration files, use `force` in this case.
        """
        ...
    
    @_where_reload
    def obtain(self, var, default=..., dialog_type=..., valtype=..., store=..., where=..., reload=..., **kwargs):
        """
        Convenience method to obtain settings interactively, if needed

        A UI will be used to ask for user input in interactive sessions.
        Questions to ask, and additional explanations can be passed directly
        as arguments, or retrieved from a list of pre-configured items.

        Additionally, this method allows for type conversion and storage
        of obtained settings. Both aspects can also be pre-configured.

        Parameters
        ----------
        var : str
          Variable name including any section like `git config` expects them,
          e.g. 'core.editor'
        default : any type
          In interactive sessions and if `store` is True, this default value
          will be presented to the user for confirmation (or modification).
          In all other cases, this value will be silently assigned unless
          there is an existing configuration setting.
        dialog_type : {'question', 'yesno', None}
          Which dialog type to use in interactive sessions. If `None`,
          pre-configured UI options are used.
        store : bool
          Whether to store the obtained value (or default)
        %s
        `**kwargs`
          Additional arguments for the UI function call, such as a question
          `text`.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def keys(self): # -> dict_keys[Unknown, Unknown]:
        """Returns list of configuration item names"""
        ...
    
    def get(self, key, default=...): # -> None:
        """D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."""
        ...
    
    def sections(self): # -> list[str | Any]:
        """Returns a list of the sections available"""
        ...
    
    def options(self, section): # -> list[Unknown]:
        """Returns a list of options available in the specified section."""
        ...
    
    def has_section(self, section): # -> bool:
        """Indicates whether a section is present in the configuration"""
        ...
    
    def has_option(self, section, option): # -> bool:
        """If the given section exists, and contains the given option"""
        ...
    
    def getint(self, section, option): # -> int:
        """A convenience method which coerces the option value to an integer"""
        ...
    
    def getbool(self, section, option, default=...): # -> bool:
        """A convenience method which coerces the option value to a bool

        Values "on", "yes", "true" and any int!=0 are considered True
        Values which evaluate to bool False, "off", "no", "false" are considered
        False
        TypeError is raised for other values.
        """
        ...
    
    def getfloat(self, section, option): # -> float:
        """A convenience method which coerces the option value to a float"""
        ...
    
    def items(self, section=...): # -> dict_items[Unknown, Unknown] | list[tuple[Unknown, Unknown]]:
        """Return a list of (name, value) pairs for each option

        Optionally limited to a given section.
        """
        ...
    
    def get_value(self, section, option, default=...):
        """Like `get()`, but with an optional default value

        If the default is not None, the given default value will be returned in
        case the option did not exist. This behavior imitates GitPython's
        config parser.
        """
        ...
    
    @_where_reload
    def add(self, var, value, where=..., reload=...): # -> None:
        """Add a configuration variable and value

        Parameters
        ----------
        var : str
          Variable name including any section like `git config` expects them, e.g.
          'core.editor'
        value : str
          Variable value
        %s"""
        ...
    
    @_where_reload
    def set(self, var, value, where=..., reload=..., force=...): # -> None:
        """Set a variable to a value.

        In opposition to `add`, this replaces the value of `var` if there is
        one already.

        Parameters
        ----------
        var : str
          Variable name including any section like `git config` expects them, e.g.
          'core.editor'
        value : str
          Variable value
        force: bool
          if set, replaces all occurrences of `var` by a single one with the
          given `value`. Otherwise raise if multiple entries for `var` exist
          already
        %s"""
        ...
    
    @_where_reload
    def rename_section(self, old, new, where=..., reload=...): # -> None:
        """Rename a configuration section

        Parameters
        ----------
        old : str
          Name of the section to rename.
        new : str
          Name of the section to rename to.
        %s"""
        ...
    
    @_where_reload
    def remove_section(self, sec, where=..., reload=...): # -> None:
        """Rename a configuration section

        Parameters
        ----------
        sec : str
          Name of the section to remove.
        %s"""
        ...
    
    @_where_reload
    def unset(self, var, where=..., reload=...): # -> None:
        """Remove all occurrences of a variable

        Parameters
        ----------
        var : str
          Name of the variable to remove
        %s"""
        ...
    


def rewrite_url(cfg, url): # -> str:
    """Any matching 'url.<base>.insteadOf' configuration is applied

    Any URL that starts with such a configuration will be rewritten
    to start, instead, with <base>. When more than one insteadOf
    strings match a given URL, the longest match is used.

    Parameters
    ----------
    cfg : ConfigManager or dict
      dict-like with configuration variable name/value-pairs.
    url : str
      URL to be rewritten, if matching configuration is found.

    Returns
    -------
    str
      Rewritten or unmodified URL.
    """
    ...


"""
This type stub file was generated by pyright.
"""

from ants.decorators import image_method

__all__ = ['ilr', 'rank_intensity', 'quantile', 'regress_poly', 'regress_components', 'get_average_of_timeseries', 'compcor', 'bandpass_filter_matrix']
def rank_intensity(x, mask=..., get_mask=..., method=...):
    """
    Rank transform the intensity of the input image with or without masking.
    Intensities will transform from [0,1,2,55] to [0,1,2,3] so this may not be
    appropriate for quantitative images - however, you never know.  rank
    transformations generally improve robustness so it is an empirical question
    that should be evaluated.

    Arguments
    ---------

    x : ANTsImage
        input image

    mask : ANTsImage
        optional mask

    get_mask: boolean
        will estimate a mask when none provided

    method : a scipy rank method (max,min,average,dense)


    return: transformed image

    Example
    -------
    >>> img = ants.image_read(ants.get_data('r16'))
    >>> ants.rank_intensity(img)
    """
    ...

def ilr(data_frame, voxmats, ilr_formula, verbose=...): # -> dict[str, Any]:
    """
    Image-based linear regression.

    This function simplifies calculating p-values from linear models
    in which there is a similar formula that is applied many times
    with a change in image-based predictors.  Image-based variables
    are stored in the input matrix list. They should be named
    consistently in the input formula and in the image list.  If they
    are not, an error will be thrown.  All input matrices should have
    the same number of rows and columns.

    This function takes advantage of statsmodels R-style formulas.

    ANTsR function: `ilr`

    Arguments
    ---------

    data_frame: This data frame contains all relevant predictors except for
        the matrices associated with the image variables.  One should convert
        any categorical predictors ahead of time using `pd.get_dummies`.

    voxmats: The named list of matrices that contains the changing
        predictors.

    ilr_formula: This is a character string that defines a valid regression
        formula in the R-style.

    verbose:  will print a little bit of diagnostic information that allows
        a degree of model checking

    Returns
    -------

    A list of different matrices that contain names derived from the
    formula and the coefficients of the regression model.  The size of
    the output values ( p-values, t-values, parameter values ) will match
    the input matrix and, as such, can be converted to an image via `make_image`

    Example
    -------

    >>> nsub = 20
    >>> mu, sigma = 0, 1
    >>> outcome = np.random.normal( mu, sigma, nsub )
    >>> covar = np.random.normal( mu, sigma, nsub )
    >>> mat = np.random.normal( mu, sigma, (nsub, 500 ) )
    >>> mat2 = np.random.normal( mu, sigma, (nsub, 500 ) )
    >>> data = {'covar':covar,'outcome':outcome}
    >>> df = pd.DataFrame( data )
    >>> vlist = { "mat1": mat, "mat2": mat2 }
    >>> myform = " outcome ~ covar * mat1 "
    >>> result = ants.ilr( df, vlist, myform)
    >>> myform = " mat2 ~ covar + mat1 "
    >>> result = ants.ilr( df, vlist, myform)

    """
    ...

@image_method
def quantile(image, q, nonzero=...): # -> tuple[Any, ...]:
    """
    Get the quantile values from an ANTsImage
    
    Examples
    --------
    >>> img = ants.image_read(ants.get_data('r16'))
    >>> ants.quantile(img, 0.5)
    >>> ants.quantile(img, (0.5, 0.75))
    """
    ...

def regress_poly(degree, data, remove_mean=..., axis=...): # -> tuple[Any, ndarray[Any, dtype[float64]] | NDArray[Any]]:
    """
    Returns data with degree polynomial regressed out.
    :param bool remove_mean: whether or not demean data (i.e. degree 0),
    :param int axis: numpy array axes along which regression is performed
    """
    ...

def regress_components(data, components, remove_mean=...):
    """
    Returns data with components regressed out.
    :param bool remove_mean: whether or not demean data (i.e. degree 0),
    :param int axis: numpy array axes along which regression is performed
    """
    ...

def get_average_of_timeseries(image, idx=...): # -> NDArray[signedinteger[Any]] | NDArray[floating[Any]]:
    """Average the timeseries into a dimension-1 image.
    image: input time series image
    idx:  indices over which to average
    """
    ...

def bandpass_filter_matrix(matrix, tr=..., lowf=..., highf=..., order=...):
    """
    Bandpass filter the input time series image

    ANTsR function: `frequencyFilterfMRI`

    Arguments
    ---------

    image: input time series image

    tr:    sampling time interval (inverse of sampling rate)

    lowf:  low frequency cutoff

    highf: high frequency cutoff

    order: order of the butterworth filter run using `filtfilt`

    Returns
    -------
    filtered matrix

    Example
    -------

    >>> import numpy as np
    >>> import ants
    >>> import matplotlib.pyplot as plt
    >>> brainSignal = np.random.randn( 400, 1000 )
    >>> tr = 1
    >>> filtered = ants.bandpass_filter_matrix( brainSignal, tr = tr )
    >>> nsamples = brainSignal.shape[0]
    >>> t = np.linspace(0, tr*nsamples, nsamples, endpoint=False)
    >>> k = 20
    >>> plt.plot(t, brainSignal[:,k], label='Noisy signal')
    >>> plt.plot(t, filtered[:,k], label='Filtered signal')
    >>> plt.xlabel('time (seconds)')
    >>> plt.grid(True)
    >>> plt.axis('tight')
    >>> plt.legend(loc='upper left')
    >>> plt.show()
    """
    ...

def clean_data(arr, standardize=...):
    """
    Remove columns from a NumPy array that have no variation or contain NA/Inf values.
    Optionally standardize the remaining data.

    :param arr: NumPy array to be cleaned.
    :param standardize: Boolean, if True standardize the data.
    :return: Cleaned (and optionally standardized) NumPy array.
    """
    ...

def compcor(boldImage, ncompcor=..., quantile=..., mask=..., filter_type=..., degree=...): # -> dict[str, Any]:
    """
    Compute noise components from the input image

    ANTsR function: `compcor`

    this is adapted from nipy code https://github.com/nipy/nipype/blob/e29ac95fc0fc00fedbcaa0adaf29d5878408ca7c/nipype/algorithms/confounds.py

    Arguments
    ---------

    boldImage: input time series image

    ncompcor:  number of noise components to return

    quantile:  quantile defining high-variance

    mask:      mask defining brain or specific tissues

    filter_type: type off filter to apply to time series before computing
                 noise components.

        'polynomial' - Legendre polynomial basis
        False - None (mean-removal only)

    degree: order of polynomial used to remove trends from the timeseries

    Returns
    -------
    dictionary containing:

        components: a numpy array

        basis: a numpy array containing the (non-constant) filter regressors

    Example
    -------
    >>> cc = ants.compcor( ants.image_read(ants.get_ants_data("ch2")) )

    """
    ...


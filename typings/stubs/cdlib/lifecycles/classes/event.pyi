"""
This type stub file was generated by pyright.
"""

import networkx as nx
from cdlib.classes import TemporalClustering
from cdlib.lifecycles.algorithms.classic_match import *
from typing import Callable

class CommunityEvent:
    def __init__(self, com_id) -> None:
        """
        Constructor

        :param com_id: community id
        """
        ...
    
    def set_from_event(self, from_event: dict): # -> None:
        """
        Set from event

        :param from_event: from event
        """
        ...
    
    def set_to_event(self, to_event: dict): # -> None:
        """
        Set to event

        :param to_event: to event
        """
        ...
    
    def set_in_flow(self, in_flow: dict): # -> None:
        """
        Set in flow

        :param in_flow: in flow
        """
        ...
    
    def set_out_flow(self, out_flow: dict): # -> None:
        """
        Set out flow

        :param out_flow: out flow
        """
        ...
    
    def get_from_event(self) -> dict:
        """
        Get from event

        :return: from event
        """
        ...
    
    def get_to_event(self) -> dict:
        """
        Get to event

        :return: to event
        """
        ...
    
    def get_in_flow(self) -> dict:
        """
        Get in flow

        :return: in flow
        """
        ...
    
    def get_out_flow(self) -> dict:
        """
        Get out flow

        :return: out flow
        """
        ...
    
    def to_json(self) -> dict:
        """
        Convert the event to json

        :return: the event as json
        """
        ...
    


class LifeCycle:
    """
    Class representing the lifecycle of a temporal clustering.
    It allows to compute the events composing the lifecycle (leveraging different definitions)
    and to analyze them starting from a TemporalClustering object.
    """
    def __init__(self, clustering: TemporalClustering = ...) -> None:
        """
        Constructor

        :param clustering: a TemporalClustering Object

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        """
        ...
    
    def compute_events_from_explicit_matching(self): # -> None:
        """
        Compute the events of the lifecycle using the explicit matching (if available)

         :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> from dynetx import DynGraph
        >>> dg = DynGraph()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     dg.add_interactions_from(g, t)
        >>> tc = algorithms.tiles(dg, 10)
        >>> events = LifeCycle(tc)
        >>> events.compute_events_from_explicit_matching()
        """
        ...
    
    def compute_events_with_custom_matching(self, method: Callable[[set, set], float], two_sided: bool = ..., threshold: float = ...): # -> None:
        """
        Compute the events of the lifecycle using a custom matching similarity function


        :param method: a set similarity function with co-domain in [0,1] (e.g., Jaccard)
        :param two_sided: boolean.
                            Whether the match has to be applied only from the past to the future (False)
                            or even from the future to the past (True, default)
        :param threshold: the threshold above which two communities are considered matched

        :Example:

        >>> from cdlib import algorithms
        >>> from cdlib import TemporalClustering, LifeCycle
        >>>  tc = TemporalClustering()
        >>> # build the temporal clustering object
        >>> evts = LifeCycle(tc)
        >>> jaccard = lambda x, y: len(set(x) & set(y)) / len(set(x) | set(y))
        >>> evts.compute_events_with_custom_matching(jaccard, two_sided=True, threshold=0.2)
        """
        ...
    
    def compute_events(self, matching_type: str = ..., matching_params: dict = ...): # -> None:
        """
        Compute the events of the lifecycle

        :param matching_type: the type of matching algorithm to use. Options are "facets", "asur", "greene".
        :param matching_params: the parameters of the matching algorithm.
                                Defaults to {"min_branch_size": 1, "threshold": 0.5}.
                                The former parameter is required for "facets", the latter by "asur" and "greene".

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")

        """
        ...
    
    def get_event(self, com_id: str) -> CommunityEvent:
        """
        Get the events associated to a community

        :param com_id: the community id
        :return: the events associated to the community

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> evt = events.get_event("0_2")

        """
        ...
    
    def get_events(self) -> dict:
        """
        Get all the events

        :return: the events

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> evts = events.get_events()
        """
        ...
    
    def get_event_types(self) -> list:
        """
        Get the event types

        :return: the event types

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> evts = events.get_event_types()
        """
        ...
    
    def analyze_flows(self, direction: str = ..., min_branch_size: int = ..., attr=...) -> dict:
        """
        Analyze the flows of the lifecycle

        :param direction: the temporal direction in which the flows are to be analyzed. Options are "+" and "-".
        :param min_branch_size: the minimum branch size
        :param attr: the attribute to analyze
        :return: the analyzed flows

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> c = events.analyze_flows("+")

        """
        ...
    
    def analyze_flow(self, com_id: str, direction: str = ..., min_branch_size: int = ..., attr=...) -> dict:
        """
        Analyze the flow of a community

        :param com_id: the community id
        :param direction: the temporal direction in which the flow is to be analyzed. Options are "+" and "-".
        :param min_branch_size: the minimum branch size
        :param attr: the attribute to analyze
        :return: the analyzed flow

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        """
        ...
    
    def set_attribute(self, attr: dict, name: str): # -> None:
        """
        Set the attributes of the lifecycle

        :param attr: the attributes
        :param name: the name of the attribute

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> import random
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>>
        >>> def random_attributes():
        >>>     attrs = {}
        >>>     for i in range(250):
        >>>        attrs[i] = {}
        >>>        for t in range(10):
        >>>             attrs[i][t] = random.choice(["A", "B", "C", "D", "E"])
        >>>     return attrs
        >>>
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> events.set_attribute(random_attributes(), "fakeattribute")

        """
        ...
    
    def get_attribute(self, name: str) -> dict:
        """
        Get the attributes associated to the nodes

        :param name: the name of the attribute

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> import random
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>>
        >>> def random_attributes():
        >>>     attrs = {}
        >>>     for i in range(250):
        >>>        attrs[i] = {}
        >>>        for t in range(10):
        >>>             attrs[i][t] = random.choice(["A", "B", "C", "D", "E"])
        >>>     return attrs
        >>>
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> events.set_attribute(random_attributes(), "fakeattribute")
        >>> attrs = events.get_attribute("fakeattribute")
        """
        ...
    
    def polytree(self) -> nx.DiGraph:
        """
        Reconstruct the poly-tree representing communities lifecycles using a provided similarity function.

        :return: a networkx DiGraph object.
                Nodes represent communities, their ids are assigned following the pattern {tid}_{cid},
                where tid is the time of observation and
                cid is the position of the community within the Clustering object.

        :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> g = events.polytree()
        """
        ...
    
    def validate_flow(self, target: str, direction: str, min_branch_size: int = ..., iterations: int = ...) -> dict:
        """
        Compare the flow with a null model. Each branch of each flow is compared with a null branch of the same size.
        The null model is generated by randomly sampling elements from the reference partition *iterations* times.
        The mean and standard deviation of the null model are used to compute a z-score
        for each branch, which is then used to compute a p-value.

        :param target: target set identifier
        :param direction: temporal direction, either "+" (out flow) or "-" (in flow)
        :param min_branch_size: minimum size of a branch to be considered
        :param iterations: number of random draws to be used to generate the null model
        :return:

         :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> cf = events.validate_flow("0_2", "+")
        """
        ...
    
    def validate_all_flows(self, direction: str, min_branch_size=..., iterations=...) -> dict:
        """
        Compare all flows with null models. See validate_flow for details.

        :param direction: temporal direction, either "+" (out flow) or "-" (in flow)
        :param min_branch_size: minimum size of a branch to be considered
        :param iterations: number of random draws to be used to generate the null model
        :return: a dictionary keyed by set identifier and valued by mean, std, and p-value

         :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> vf = events.validate_all_flows("+")
        """
        ...
    
    def to_json(self) -> dict:
        """
        Convert the lifecycle to json

        :return: the lifecycle as json

         :Example:

        >>> from cdlib import TemporalClustering, LifeCycle
        >>> from cdlib import algorithms
        >>> from networkx.generators.community import LFR_benchmark_graph
        >>> tc = TemporalClustering()
        >>> for t in range(0, 10):
        >>>     g = LFR_benchmark_graph(
        >>>         n=250,
        >>>         tau1=3,
        >>>         tau2=1.5,
        >>>         mu=0.1,
        >>>         average_degree=5,
        >>>         min_community=20,
        >>>         seed=10,
        >>>     )
        >>>     coms = algorithms.louvain(g)  # here any CDlib algorithm can be applied
        >>>     tc.add_clustering(coms, t)
        >>> events = LifeCycle(tc)
        >>> events.compute_events("facets")
        >>> events.to_json()
        """
        ...
    



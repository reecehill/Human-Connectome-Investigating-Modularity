try
    addpath(genpath('C:\Users\Reece\AppData\Roaming\MathWorks\MATLAB Add-Ons\Toolboxes\Brain Connectivity Toolbox'));
    % Iterative community finetuning. W is the input connection matrix.
    close all;
    clearvars -except pathToParticipants subject roiStructuralData optimalGamma;
    pathToParticipants = 'D:\Dissertation\Participants';
    subject = 'sub-002';
    roiLabels = ["lh.precentral.label"]; % only supports single values for now.
    
    showTicksPer = 500;

    adj_matrix = matfile([pathToParticipants '\' subject '\matrices.mat']).adj_matrix;
    load([pathToParticipants '\' subject '\labelSRF.mat'],"glpfaces","faceROIidL","faceROIidR","subROIid","filenames","subfilenames","glpvertex");
    load([pathToParticipants '\' subject '\edgeList.mat']);

    load([pathToParticipants '\' subject '\MNIcoor.mat'],"Coor_MNI152");
    load([pathToParticipants '\' subject '\1stlevel\fMRIModules_0002.mat']);

    allFilenames = [filenames;transpose(subfilenames)];
    regionNameIds = [faceROIidL; faceROIidR+34; subROIid+34+17];
    allLabels = allFilenames(regionNameIds);


    baseStruct.adjacencyMatrix = [];
    baseStruct.nodes.ids = [];
    baseStruct.nodes.labels = [];
    baseStruct.nodes.moduleIds = []; % for each node, list its module id.
    baseStruct.nodes.mni152 = []; % the 3D coord of each node.
    baseStruct.nodes.threeDimensions = []; % module ids in 3d
    baseStruct.nodes.shape = [];
    baseStruct.modules.nodeIds = []; % the ids of all nodes WITH a module.
    baseStruct.modules.surfaceAreas = [];
    baseStruct.modules.centreOfMasses = [];
    baseStruct.modules.shapes = {};


    tempStoreOfStrucModuleIds = [];
    if(exist("roiStructuralData",'var') && exist("optimalGamma",'var'))
        tempStoreOfStrucModuleIds = roiStructuralData.nodes.moduleIds;
        tempStoreOfOptimalGamma = optimalGamma;
    end

    allStructuralData = baseStruct;
    roiStructuralData = baseStruct;
    allFunctionalData = baseStruct;
    roiFunctionalData = baseStruct;
    allBrainData = baseStruct;
    roiBrainData = baseStruct;

    %% Brain data
    importedBrainData = spm_vol([pathToParticipants '/' subject '/data/bert/mri/aparc+aseg.nii']);
    [threeDimensions, mni152] = spm_read_vols(importedBrainData);
    coordsWithData = mni152(:,find(threeDimensions>0));
    allBrainData.nodes.mni152 = pcdownsample(pointCloud(transpose(coordsWithData)),"random",0.1).Location;
    allBrainData.modules.shape = alphaShape(allBrainData.nodes.mni152);
    [~,boundaryCoordsOfShape] = boundaryFacets(allBrainData.modules.shape);
    allBrainData.modules.centreOfMasses = mean(boundaryCoordsOfShape);



    importedBrainData = spm_vol([pathToParticipants '/' subject '/data/bert/mri/' num2str(roiLabels(1))  '_fsaverage_mask.nii']);
    [threeDimensions, mni152] = spm_read_vols(importedBrainData);
    coordsWithData = mni152(:,find(threeDimensions>0));
    [~,roiBrainData.nodes.mni152] = getMNIFromRasCoords([pathToParticipants '/' subject],transpose(coordsWithData),2);
    %roiBrainData.nodes.mni152 = pcdownsample(pointCloud(transpose(coordsWithData)),"random",0.1).Location;
    roiBrainData.modules.shape = alphaShape(roiBrainData.nodes.mni152);
    [~,boundaryCoordsOfShape] = boundaryFacets(roiBrainData.modules.shape);
    roiBrainData.modules.centreOfMasses(1,:) = mean(boundaryCoordsOfShape);
    clearvars importedBrainData threeDimensions mni152;

    %% Structural data
    % All structure data
    allStructuralData.nodes.ids = 1:1:length(allLabels);
    %allStructuralData.nodes.mni152 = Coor_MNI152;
    %TODO: This is not in MNI152 space!
    allStructuralData.nodes.mni152 = [lpcentroids;rpcentroids;subCoor];
    allStructuralData.nodes.shape = alphaShape(allStructuralData.nodes.mni152);
    [~,boundaryCoordsOfShape] = boundaryFacets(allStructuralData.nodes.shape);
    allStructuralData.modules.centreOfMasses(1,:) = mean(boundaryCoordsOfShape);

    %% Offset structural data to match mask
    offset = allStructuralData.modules.centreOfMasses - allBrainData.modules.centreOfMasses;
    allBrainData.modules.shape.Points = allBrainData.modules.shape.Points + repmat(offset(1,:),length(allBrainData.modules.shape.Points),1);
    allBrainData.nodes.mni152 = allBrainData.nodes.mni152 + repmat(offset(1,:),length(allBrainData.nodes.mni152),1);
    roiBrainData.modules.shape.Points = roiBrainData.modules.shape.Points + repmat(offset(1,:),length(roiBrainData.modules.shape.Points),1);
    roiBrainData.nodes.mni152 = roiBrainData.nodes.mni152 + repmat(offset(1,:),length(roiBrainData.nodes.mni152),1);

    clear Coor_MNI152;
    allStructuralData.nodes.labels = allLabels;
    %allStructuralData.nodes.threeDimensions =
    %getThreeDimensions(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3));


    % Filtered structure data, of only those from ROI.
    roiStructuralData.nodes.ids = find(ismember(allLabels, roiLabels));
    roiStructuralData.adjacencyMatrix = adj_matrix(roiStructuralData.nodes.ids,roiStructuralData.nodes.ids);
    if(~isempty(tempStoreOfStrucModuleIds))
        roiStructuralData.nodes.moduleIds = tempStoreOfStrucModuleIds;
        optimalGamma = tempStoreOfOptimalGamma;
    else
        disp('Sorting structural data into modules...');
        %[roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, 0.78, 0.80);
        [roiStructuralData.nodes.moduleIds, optimalGamma, Q1] = sortIntoModules(roiStructuralData.adjacencyMatrix, -0.02, 0);
    end
    roiStructuralData.nodes.labels = allLabels(roiStructuralData.nodes.ids);
    roiStructuralData.nodes.mni152 = allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:);
    clearvars tempStoreOfOptimalGamma tempStoreOfStrucModuleIds;


    %% Functional data
    allFunctionalData.nodes.mni152 = funcXyzCoordinatesmm;
    allFunctionalData.nodes.moduleIds = fmriModules(:); % for each node, list its module id.
    allFunctionalData.nodes.threeDimensions = intensitiesPerVoxel;
    allFunctionalData.modules.threeDimensions = fmriModules; % module ids in 3d
    allFunctionalData.modules.nodeIds = find(allFunctionalData.nodes.moduleIds>0); % the ids of all nodes with a module.
    clearvars fmriModules intensitiesPerVoxel xyzCoordinatesmm;

    % Filtered functional data, on only those from ROI. TO DO: filter
    % functional data to get only specific areas.


    %% Build shapes from coordinates.
    allStructuralData.nodes.shape = alphaShape(allStructuralData.nodes.mni152);
    roiStructuralData.nodes.shape = alphaShape(roiStructuralData.nodes.mni152);
    for moduleIndex=1:max(roiStructuralData.nodes.moduleIds)
        activeNodes = find(roiStructuralData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            roiStructuralData.modules.shapes{moduleIndex} = alphaShape(roiStructuralData.nodes.mni152(activeNodes,:));
            shape = roiStructuralData.modules.shapes{moduleIndex};
            roiStructuralData.modules.surfaceAreas(moduleIndex) = surfaceArea(roiStructuralData.modules.shapes{moduleIndex});
            boundaryPointsIndexes = boundaryFacets(roiStructuralData.modules.shapes{moduleIndex});
            boundaryCoords = shape.Points(boundaryPointsIndexes);
            roiStructuralData.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoords);

            [~,boundaryCoordsOfShape] = boundaryFacets(roiStructuralData.modules.shapes{moduleIndex});
    allStructuralData.modules.centreOfMasses(1,:) = mean(boundaryCoordsOfShape);
        else
            disp("Not draeing...")
        end
    end

    for moduleIndex=1:max(allFunctionalData.nodes.moduleIds)
        activeNodes = find(allFunctionalData.nodes.moduleIds == moduleIndex);
        % Do not build shape if module consists of 1, 2, or 3 nodes. (as 3D
        % is required)
        if(length(activeNodes)>3)
            coords = allFunctionalData.nodes.mni152(activeNodes,:);
            allFunctionalData.modules.shapes{moduleIndex} = alphaShape(coords);
            allFunctionalData.modules.surfaceAreas(moduleIndex) = surfaceArea(allFunctionalData.modules.shapes{moduleIndex});
            boundaryPointsIndexes = boundaryFacets(allFunctionalData.modules.shapes{moduleIndex});
            boundaryCoords = coords(boundaryPointsIndexes);
            allFunctionalData.modules.centreOfMasses(moduleIndex,:) = mean(boundaryCoords);
        end
    end


    overlappingRegions = baseStruct;
    overlappingRegionIndex = 1;
    %% Find the functional modules shapes that overlap with structural modules.
    for strucShape=roiStructuralData.modules.shapes
        for funcShape=allFunctionalData.modules.shapes
            if(~isempty(funcShape{1}) && ~isempty(strucShape{1}))
                coords = inShape(strucShape{1},funcShape{1}.Points);
                overlappingCoordinates = funcShape{1}.Points(coords,:);
                if(~isempty(overlappingCoordinates))
                    % An overlapping area has been found. Build shape of
                    % the overlapping area.
                    overlappingRegions.modules.shapes{overlappingRegionIndex} = alphaShape(overlappingCoordinates);
                    overlappingRegions.modules.centreOfMasses = [overlappingRegions.modules.centreOfMasses, mean(overlappingCoordinates)];
                    overlappingRegions.modules.surfaceAreas(overlappingRegionIndex) = surfaceArea(overlappingRegions.modules.shapes{overlappingRegionIndex});
                    overlappingRegionIndex = overlappingRegionIndex + 1;
                end
            end
        end
    end

    totalSurfaceAreaOfAllModules = sum(roiStructuralData.modules.surfaceAreas,'all') + sum(allFunctionalData.modules.surfaceAreas,'all');
    totalSurfaceAreaOfOverlappingRegions = sum(overlappingRegions.modules.surfaceAreas,'all');
    percentageCover = (totalSurfaceAreaOfOverlappingRegions/totalSurfaceAreaOfAllModules)*100;

    figure2 = figure;
    plottedLabels = allStructuralData.nodes.labels(1:showTicksPer:end);
    spy(adj_matrix);
    rectangle('Position',[min(roiStructuralData.nodes.ids) min(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids) length(roiStructuralData.nodes.ids)], 'EdgeColor','red')
    xticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(allStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Global network - connectivity matrix')
    subtitle('Square shows local connectivity (figure 2)')

    figure(2);
    plottedLabels = roiStructuralData.nodes.labels(1:showTicksPer:end);
    spy(roiStructuralData.adjacencyMatrix);
    xticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    yticks(1:showTicksPer:length(roiStructuralData.nodes.labels));
    xticklabels(plottedLabels);
    yticklabels(plottedLabels);
    title('Local network (lSF-lSP) - connectivity matrix')



    nStrucModulesToPlot = max(roiStructuralData.nodes.moduleIds,[],'all') - unique(roiStructuralData.nodes.moduleIds);
    nFuncModulesToPlot = max(allFunctionalData.nodes.moduleIds,[],'all') - unique(allFunctionalData.nodes.moduleIds);
    nThingsToPlot = length(nStrucModulesToPlot)+length(nFuncModulesToPlot);
    strucColorMap = colormap(jet(nThingsToPlot));
    funcColorMap = flipud(strucColorMap);


    figure('Name',"Shape Map");
    subtitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma) ' | % cover: ' num2str(percentageCover) '%']);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    %plot(allBrainData.nodes.shape,'FaceColor',[0.8 0.15 0.15],'FaceAlpha',0.6,'BackFaceLighting','lit','FaceLighting','gouraud','EdgeColor','none','DisplayName','Brain from mask');
    %plot(allStructuralData.nodes.shape,'FaceColor',[0.1 0.8 0.1],'FaceAlpha',0.6,'EdgeColor','none','DisplayName','Brain from structural nodes','AmbientStrength',0.5,'AlignVertexCenters','on','FaceLighting','flat');
    plot(roiBrainData.modules.shape,'FaceColor',[0.1 0.8 0.8],'FaceAlpha',0.6,'EdgeColor','none','DisplayName','ROI from mask','AmbientStrength',0.5,'AlignVertexCenters','on','FaceLighting','flat');
    plot3(roiStructuralData.modules.centreOfMasses(:,1),roiStructuralData.modules.centreOfMasses(:,2),roiStructuralData.modules.centreOfMasses(:,3),'*','MarkerSize',10,'Color','g','DisplayName','Struc COM');
   
    plot3(roiBrainData.modules.centreOfMasses(:,1),roiBrainData.modules.centreOfMasses(:,2),roiBrainData.modules.centreOfMasses(:,3),'*','MarkerSize',10,'Color','r','DisplayName','ROIMask COM');
    strucModule = 1;
    for shapeToPlot=roiStructuralData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            hold on;
        end
        strucModule = strucModule + 1;

    end

    funcModule = 1;
    for shapeToPlot=allFunctionalData.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['fMRI Module #' num2str(funcModule)])
            hold on;
        end
        funcModule = funcModule + 1;
    end

    overlappingRegion = 1;
    for shapeToPlot=overlappingRegions.modules.shapes
        if(~isempty(shapeToPlot{1}))
            plot(shapeToPlot{1},'FaceColor',funcColorMap(overlappingRegion,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['Overlap #' num2str(overlappingRegion)])
            hold on;
        end
        overlappingRegion = overlappingRegion + 1;
    end

    %% Visualise overlap
    figure(6);
    subtitle(['DWI- and fMRI-derived "modules" in MNI152 space']);
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    legend on;
    hold on;

    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucModules = find(roiStructuralData.nodes.moduleIds(:)==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucModules,:);
        centrePoint = mean(activeStrucModuleCoords);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            plot3(centrePoint(:,1),centrePoint(:,2),centrePoint(:,3),'*','Color','k','HandleVisibility','off');
        end
        %plot3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'^','DisplayName',['DWI
        %Module #' num2str(strucModule)]);
        hold on;
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no
        % activation).
        if(funcModule>0)
            roiFunctionalData.modules.byId = find(allFunctionalData.nodes.moduleIds(:)==funcModule);
            activeFmriModuleCoords = allFunctionalData.nodes.mni152(roiFunctionalData.modules.byId,:);
            plot3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','Color',funcColorMap(funcModule,:),'DisplayName',['fMRI Module #' num2str(funcModule)]);
            hold on;
        end
    end


    figure(7);
    %suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]);
    subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on; legend on;
    %circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    %roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1).* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4,.4, .4]);
    boundaryOfBrain = boundary(allStructuralData.nodes.mni152,1);
    trisurf(boundaryOfBrain,allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),'FaceColor',[0.1,0.1,0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area') %hold on;
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(boundaryOfModule))
            %surf(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',cmap(strucModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
            trisurf(boundaryOfModule,activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation).
        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);

        if(~isempty(boundaryOfModule))
            trisurf(boundaryOfModule,activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end



    figure(8);
    suptitle('DWI- and fMRI-derived "modules" in MNI152 space');
    title(['Single subject (#02) | (fMRI: FWE<0.05, k=0) | gamma=' num2str(optimalGamma)]); subtitle('Modules made of only one node are excluded.');
    xlabel('Right->Left');
    ylabel('Inferior->Superior');
    zlabel('Anterior-Posterior');
    hold on;
    legend on;
    circleSizes = ones(length(allStructuralData.nodes.mni152), 1) .* 0.1;
    roiCircleSizes = ones(length(roiStructuralData.nodes.mni152), 1) .* 0.1;
    %scatter3(allStructuralData.nodes.mni152(:,1),allStructuralData.nodes.mni152(:,2),allStructuralData.nodes.mni152(:,3),circleSizes,[.4, .4, .4]);
    plot(allStructuralData.nodes.shape,'FaceColor',[0.1 0.1 0.1],'FaceAlpha',0.05,'EdgeColor','none','DisplayName','Brain')
    hold on;
    %boundaryOfRoi = boundary(allStructuralData.nodes.mni152(roiStructuralData.nodes.ids,:),0.5);
    %trisurf(boundaryOfRoi,roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),'FaceColor','none','FaceAlpha',0.2,'EdgeColor',[1 0.1 0.1],'DisplayName','ROI-Area')
    %scatter3(roiStructuralData.nodes.mni152(:,1),roiStructuralData.nodes.mni152(:,2),roiStructuralData.nodes.mni152(:,3),roiCircleSizes,'DisplayName','ROI')
    hold on;
    for strucModule=1:max(roiStructuralData.nodes.moduleIds)
        activeStrucNodeIds = find(roiStructuralData.nodes.moduleIds==strucModule);
        activeStrucModuleCoords = roiStructuralData.nodes.mni152(activeStrucNodeIds,:);
        activeStrucModuleShape = alphaShape(activeStrucModuleCoords);
        activeStrucModuleCentre = mean(activeStrucModuleCoords);
        activeStrucModuleSurfaceArea = surfaceArea(activeStrucModuleShape);

        %scatter3(activeStrucModuleCoords(:,1),activeStrucModuleCoords(:,2),activeStrucModuleCoords(:,3),'*','DisplayName',['DWI Module #' num2str(strucModule)]);
        boundaryOfModule = boundary(activeStrucModuleCoords);
        if(~isempty(activeStrucModuleShape))
            plot(activeStrucModuleShape,'FaceColor',strucColorMap(strucModule,:),'FaceAlpha',0.3,'EdgeColor','none','DisplayName',['DWI Module #' num2str(strucModule)])
        end
    end
    for funcModule=1:max(allFunctionalData.nodes.moduleIds,[],'all')
        % For fmri data, a score of 0 means no module membership (e.g., no activation). if(funcModule>0)

        activeFuncNodeIds = find(allFunctionalData.nodes.moduleIds==funcModule);
        activeFmriModuleCoords = allFunctionalData.nodes.mni152(activeFuncNodeIds,:);
        %scatter3(activeFmriModuleCoords(:,1),activeFmriModuleCoords(:,2),activeFmriModuleCoords(:,3),'s','DisplayName',['fMRI Module #' num2str(funcModule)]);
        boundaryOfModule = boundary(activeFmriModuleCoords);
        activeFuncModuleShape = alphaShape(activeFmriModuleCoords);
        if(~isempty(boundaryOfModule))
            plot(activeFuncModuleShape,'FaceColor',funcColorMap(funcModule,:),'FaceAlpha',0.5,'EdgeColor','none','DisplayName',['fMRI Activation: #' num2str(funcModule)])
            %scatter3(activeFmriModuleCoords(boundaryOfModule,1),activeFmriModuleCoords(boundaryOfModule,2),activeFmriModuleCoords(boundaryOfModule,3),'s','HandleVisibility','off');
        end
        hold on;
    end


    %% Visualise strucModules
%     figure1 = figure;
%     hold on;
%     moduleIndex = min(roiStructuralData.nodes.moduleIds); % For each module
%     cmap = hsv(length(roiStructuralData.nodes.moduleIds));
%     for i = transpose(roiStructuralData.nodes.moduleIds)
%         % Get ids of nodes that are in this module.
%         nodeIds = find(roiStructuralData.nodes.moduleIds == i);
%         nodesByModule = zeros(size(roiStructuralData.adjacencyMatrix));
% 
%         nodesByModule(nodeIds, nodeIds) = 1;
%         spy(nodesByModule);
%         x=get(gca,'children');
%         lastX = length(x);
%         color = [cmap(lastX,:)];
%         set(x(lastX),'color',color);
%     end
    sound(sin(1:1000)); pause(0.2); sound(sin(1:1000));
catch ME
    sound(tan(1:1000)); pause(0.2); sound(tan(1:1000));
    rethrow(ME);
end

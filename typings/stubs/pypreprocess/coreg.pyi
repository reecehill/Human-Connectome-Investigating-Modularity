"""
This type stub file was generated by pyright.
"""

import numpy as np

"""
:Module: coreg.py
:Synopsis: Histogram-based co-registration of 3D MRI images.
:Author: DOHMATOB Elvis Dopgima <gmdopp@gmail.com>

"""
EPS = np.finfo(float).eps
def compute_similarity_from_jhist(jh, fwhm=..., cost_fun=...):
    """
    Computes an information-theoretic similarity from a joint histogram.

    Parameters
    ----------
    jh: 2D array
        joint histogram of the two random variables being compared

    fwhm: float or pair of float
        kernel width for smoothing the joint histogram

    cost_fun: string, optional (default 'nmi')
        smilarity model to use; possible values are:
        'mi': Mutual Information
        'nmi': Normalized Mutual Information
        'ecc': Entropic Cross-Correlation

    Returns
    -------
    o: float
        the computed similariy measure
    """
    ...

def compute_similarity(params, ref, src, ref_affine, src_affine, grid, cost_fun=..., fwhm=..., bins=...):
    """
    Computes the similarity between the reference image (ref) and the moving
    image src, under the current affine motion parameters (x).

    The computed similarity measure is histogram-based.

    Parameters
    ----------
    params: 1D array of 6 floats
        current affine motion parameters; specifies an affine transformation
        matrix

    ref: 1D array of length n_voxels
        the reference image already sampled accuring to the current sampling
        rate (in pyramidal/multi-resolution loop)

    src: 3D array of shape
        moving image to be resampled unto the reference image's grid, deformed
        rigidly according to the matrix M

    ref_affine: 2D array of shape (4, 4)
        affine matrix of reference image (ref

    src_affine: 2D arfray of shape (4, 4)
        affine matrix of moving image (src)

    grid: 2D array of shape (3, n_voxels)
        grid of reference image (ref)

    bins: pair of integers, optional (default (256, 256))
       shape of the joint histogram being computed

    cost_fun: string, optional (default 'nmi')
        smilarity model to use; possible values are:
        'mi': Mutual Information
        'nmi': Normalized Mutual Information
        'ecc': Entropic Cross-Correlation

    fwhm: 1D array of 2 floats
        FWHM for smoothing the joint histogram

    Returns
    -------
    o: float
        the computed similariy measure
    """
    ...

class Coregister:
    """
    Similarity-based rigid-body multi-modal registration.

    Parameters
    ----------
    sep: 1D array of floats, optional (default [4, 2])
        pyramidal optimization seperation (in mm)

    params: 1D array of length 6, optional (default [0, 0, 0, 0, 0, 0]
        starting estimates


    tol: 1D array of 6 floats, optional (
    default [.02, .02, .02, .001, .001, .001])
        tolerances for the accuracy of each parameter

    cost_fun: string, optional (default "nmi")
        similarity function to be optimized. Possible values are:
        "mi": Mutual Information
        "nmi": Normalized Mutual Information
        "ecc": Entropy Correlation Coefficient

    fwhm: 1D array of 2 floats
        FWHM for smoothing the joint histogram

    bins: pair of integers, optional (default (256, 256))
       shape of the joint histogram being computed

    Attributes
    ----------
    params_: 1D array of 6 floats (3 translations + 3 rotations)
        the realign parameters estimated

    References
    ----------
    [1] Rigid Body Registration, by J. Ashburner and K. Friston

    """
    def __init__(self, sep=..., params_init=..., tol=..., cost_fun=..., smooth_vols=..., fwhm=..., bins=..., verbose=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def fit(self, target, source): # -> Self@Coregister:
        """
        Estimates the co-registration parameters for rigidly registering
        vol to vol, which can be of different modality
        (fMRI and PET, etc.).

        The technology used is histogram-based registration.

        Parameters
        ----------
        vol: string (existing filename) or 3D (if 4D then then first volume
        will be used) nibabel image object
            reference volume (image that is kept fixed)

        vol: string (existing filename) or 3D nibabel image object
            source image (image that is jiggled about to fit the
            reference image)

        Returns
        -------
        `Coregistration` instance
            fitted object
        """
        ...
    
    def transform(self, source, output_dir=..., prefix=..., ext=..., basenames=...): # -> str | list[Unknown] | list[Nifti1Image]:
        """
        Applies estimated co-registration parameter to the input volume
        (source).

        Parameters
        ----------
        source: string (existing filename) or 3D nibabel image object
            source image (image that is jiggled about to fit the
            reference image)

        output_dir: string, optional (dafault None)
            existing dirname where output will be written

        prefix: string, optional (default 'Coreg')
            prefix for output filenames.

        ext: string, optional (default ".nii.gz")
            file extension for ouput images

        Returns
        -------
        coregistered_source: nibabel image object or existing filename
        (if output_dir is specified)
            the coregistered source volume
        """
        ...
    



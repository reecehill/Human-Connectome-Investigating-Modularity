function [trkEP_full,trk_len_full,trk_type_full]=conversion(pathToFile, type)
%% load trk file generated by dsi studio

% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS
addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));


display('step1: performing conversion from .trk to surface and atlas')
display(['Type: ' num2str(type) ' (' class(type) ')'])
%ft_defaults
%atlas=ft_read_mri([pathToFile,'/mri/aparc+aseg.nii']);
atlas=ft_read_mri([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);
atlasImg=niftiinfo([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);
%trackImg_mni152=ft_read_mri([pathToFile '/T1w/Diffusion/1m0_mni152.tt.nii.gz']);
%trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);

%TODO: We must first flip the Y coordinates (LPS -> LAS)
% The T1w image is LAS
% The dsistudio tracks are LPS

if type==1
    RASmat = atlas.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
elseif type==2
    RASmat = atlas.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
else
    display('wrong type of surface')
end
dimL = atlas.dim(1);
dimI = atlas.dim(2);
dimA = atlas.dim(3);

atlasMat = [1   0   0   0;
            0   0  -1   dimI;
            0  -1   0   dimA;
            0   0   0   1];  % from .trk (LPS orientation) to aseg.nii (RAS orientation)

surfMat = RASmat*atlasMat;  % from .trk to pial files.


trk_len_full=[];
trk_type_full=[];
trkEP_full=[];
for i=1:1
    filename=[pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'.trk']

    [rawTrkMeta,rawTrk]=trk_read(filename);

    % filename2 = [pathToFile,'/tracks_mat.mat'];
    % eval(['load(filename2)']);
    % tracts = tracts';
    % for i = 1: length(rawTrk)
    %     rawTrk(i).matrix = tracts(1:rawTrk(i).nPoints,:);
    %     tracts(1:rawTrk(i).nPoints,:) = [];
    % end
    %
    %

    vs=rawTrkMeta.voxel_size; % voxel may not be cube
    lenrawTrk=length(rawTrk);

    % vs = 1;

    % trk_len, 8th is true|false in grey matter both ends
    trk_len=zeros(lenrawTrk,1,'single');
    trk_type=zeros(lenrawTrk,3,'single');
    trkEP=zeros(lenrawTrk,6,'single');%
    % trkEPatlas=zeros(lenrawTrk,6,'single');%
    nNotInAtlas = 0;
    for k=1:lenrawTrk

        trk=rawTrk(k).matrix./vs;

        % Flip track coordinates LPS -> LAS.
        trk(:,2) = trk(:,2) * -1;

        trkSize=size(trk,1);

        %compute track length
        id1=trk(1:end-1,:);
        id2=trk(2:end,:);
        dist=sqrt( (id1(:,1)-id2(:,1)).^2 +(id1(:,2)-id2(:,2)).^2 +(id1(:,3)-id2(:,3)).^2);
        trk_len(k,1)=sum(dist);

        % for the track to pial surface space
        l=1;%start point
        ttemp=surfMat*[trk(l,1); trk(l,2); trk(l,3); 1]; % by Peter
        trkEP(k,1:3)=[single(ttemp(1:3)')];

        l=trkSize;%end point
        ttemp=surfMat*[trk(l,1); trk(l,2); trk(l,3); 1];% by Peter

        trkEP(k,4:6)=[single(ttemp(1:3)')];

        if mod(k/1000,1)==0 %show progress
            disp(num2str(k/lenrawTrk));
        end

        %% code here to see if both endpoints are in the grey matter
        %for the transformation into anatomy space
        trka=rawTrk(k).matrix./vs;
        l=1;% start point
        ttemp=atlasMat*round([trka(l,1); trka(l,2); trka(l,3); 1]);% by Xue
        trkstartp= round(ttemp(1:3))+1; %by Xue

        l=trkSize;%end point
        ttemp=atlasMat*round([trka(l,1); trka(l,2); trka(l,3); 1]);% by Xue
        trkendp=round(ttemp(1:3))+1; %by Xue

        % by Reece - some trkstart/trkend are outside the atlas range (presumed due to
        % rounding). So, set cap according to atlas dimensions.
        dimsAboveRange = find(trkstartp>atlas.dim(:));
        dimsBelowRange = trkstartp<1;
        trkstartp(dimsAboveRange) = atlas.dim(dimsAboveRange);
        trkstartp(dimsBelowRange) = 1;

        dimsAboveRange = find(trkendp>atlas.dim(:));
        dimsBelowRange = trkendp<1;
        trkendp(dimsAboveRange) = atlas.dim(dimsAboveRange);
        trkendp(dimsBelowRange) = 1;

        % TODO: Insert validation check. Are points being moved inconsiderable
        % distances?
        %

        tmp=zeros(1,3);
        try
            tmp(1:2)=[atlas.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            disp(trkstartp);
            disp(trkendp);
        end

        if(sum(tmp) == 0)
            nNotInAtlas = nNotInAtlas +1;
        end




        %for info on the choice of these numbers (1000, 3000 etc) check the
        %freesurfer lookup table.

        % add subcortical regions
        if  ( (tmp(1)<7 && tmp(1)>0) || (tmp(1)>26 && tmp(1)<47) || (tmp(1)<1000 && tmp(1)>58) || (tmp(1)>=3000) ) &&  ( (tmp(2)<7 && tmp(2)>0) || (tmp(2)>26 && tmp(2)<47) || (tmp(2)<1000 && tmp(2)>58) || (tmp(2)>=3000) )
            tmp(1,3)=0;
        elseif ( (tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000) ) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24 && ( (tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000) ) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24
            tmp(1,3)=1;
        elseif tmp(1)==0 && tmp(2)==0
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp)*checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                pause
            end
        elseif tmp(1)==0 && ( ((tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000)) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                pause
            end
        elseif tmp(2)==0 && ( ((tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000)) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;

        %     hold on
        %     plot3(trkstartp(1),trkstartp(2),trkstartp(3),'ok')
        %     plot3(trkendp(1),trkendp(2),trkendp(3),'ok')
        %     hold off

    end
    disp("nNotInAtlas:")
    trk_len_full(1+((i-1)*lenrawTrk):(i)*lenrawTrk) =trk_len;
    trk_type_full(1+((i-1)*lenrawTrk):(i)*lenrawTrk,:)=trk_type;
    trkEP_full(1+((i-1)*lenrawTrk):(i)*lenrawTrk,:)=trkEP;
end


end

%%
%  coordsIn3d = zeros(size(allFunctionalData.modules.threeDimensions),3);
%             % Create matrix where each element is a vector of coordinates.
%             coordsIn3d(sub2ind(size(coordsIn3d),xSubsection,ySubsection,zSubsection))=allFunctionalData.nodes.mni152(activeNodes);

function mapDwiAndFmriToFaces(pathToParticipants,subject,conditionIndex,visualiseData)
%% INSTRUCTIONS
% Anatomical, DWI, fMRI data are used in this script.
try
    tic;
    if ~exist([pathToParticipants '/' subject '/moduleResults'], 'dir')
        mkdir([pathToParticipants '/' subject '/moduleResults'])
    end
    if ~exist([pathToParticipants '/' subject '/moduleResults/figures'], 'dir')
        mkdir([pathToParticipants '/' subject '/moduleResults/figures'])
    end
    if ~exist([pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex)], 'dir')
        mkdir([pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex)])
    end

    %% Initialise.
    addpath('toolboxes/FieldTrip');
    ft_defaults;
    ft_hastoolbox('bct',1);
    addpath('toolboxes/Iso2Mesh/iso2mesh');
    addpath(genpath('toolboxes/SurfStat'));
    close all;
    clearvars -except pathToParticipants subject conditionIndex visualiseData allBrainData roiStructuralData optimalGamma ;
    ISO2MESH_TEMP='/home/reece/tempiso2mesh';
    surf = struct('nodes',[],'faces',[],'edges',[],'regions',[],'holes',[]);
    baseStruct.surf = surf;

    if(exist("allBrainData",'var') && ~isempty(allBrainData.leftHemisphere.surf.faces) && ~isempty(allBrainData.rightHemisphere.surf.faces) && ~isempty(allBrainData.leftHemisphere.optimalGamma) && ~isempty(allBrainData.rightHemisphere.optimalGamma))
        tempStore.leftStructuralModules = allBrainData.leftHemisphere.surf.faces(:,4);
        tempStore.rightStructuralModules = allBrainData.rightHemisphere.surf.faces(:,4);
        tempStore.leftOptimalGamma = allBrainData.leftHemisphere.optimalGamma;
        tempStore.rightOptimalGamma = allBrainData.rightHemisphere.optimalGamma;
    end
    allStructuralData = baseStruct;
    roiStructuralData = baseStruct;
    allFunctionalData = baseStruct;
    allBrainData = baseStruct;
    clearvars surf modules nodes baseStruct
    %% Parameters
    roiLabels = ["precentral.label"]; % only supports single values for now.
    showTicksPer = 1000;
    viewSliceOfAllFmriModules = 0;

    %% Load external parameters
    adj_matrix = matfile([pathToParticipants '/' subject '/matrices.mat']).adj_matrix;
    load([pathToParticipants '/' subject '/labelSRF.mat'],"nvl","nvr","nfl","nfr","glpfaces","glpvertex","grpfaces","grpvertex","faceROIidL","faceROIidR","subROIid","filenames","subfilenames");
    load([pathToParticipants '/' subject '/edgeList.mat'], "lpcentroids","rpcentroids","subCoor");
    load([pathToParticipants '/' subject '/MNIcoor.mat'],"Coor_MNI152");
    load([pathToParticipants '/' subject '/1stlevel/fMRIModules_000' num2str(conditionIndex) '.mat'], "fmriModules");

    %% TODO: Automate getting transformation matrices.
    % To get tkrRAS coordinates from row,col,slice of fmri data:
    % inv(mri.hdr.tkrvox2ras)*rmmissing(Reg)*[R A S 1]'

    % where tMov is generated by:
    % mri_info --vox2ras-tkr
    % ${SUBJECTS_DIR}/sub-002/data/func/task-HcpMotor_acq-ap_bold.nii

    % Added by Reece to make compatible with Python and HCP.
    %!mri_info --vox2ras-tkr
    %${SUBJECTS_DIR}/sub-002/data/func/task-HcpMotor_acq-ap_bold.nii %no
    %longer needed

    %tMov = load([pathToParticipants '/' subject
    %'/data/func/vox2ras-tkr.csv']); %no longer needed.

    % where REG was obtained by:
    %  tkregister2 --mov "${SUBJECTS_DIR}/sub-002/data/func/sartask-HcpMotor_acq-ap_bold.nii" --s sub-002/data/  --noedit --regheader --reg "${SUBJECTS_DIR}/sub-002/data/func/register.dat" --targ "${SUBJECTS_DIR}/sub-002/data/bert/mri/T1.nii"
    % Reg = table2array(readtable([pathToParticipants '/' subject
    % ,'/data/func/register.dat'])); %no longer needed.

    %% Integrate/handle labels into dataset.
    allBrainData.leftHemisphere.labels.ids = faceROIidL;
    allBrainData.rightHemisphere.labels.ids = faceROIidR+34;
    allBrainData.leftHemisphere.labels.names = filenames( allBrainData.leftHemisphere.labels.ids);
    allBrainData.rightHemisphere.labels.names = filenames( allBrainData.rightHemisphere.labels.ids);
    allBrainData.subCortical.labels.names = transpose(subfilenames(subROIid));

    %% All Anatomical data
    allBrainData.surf.nodes_mni152 = Coor_MNI152;
    % Left hemisphere
    allBrainData.leftHemisphere.surf.faces = nfl;
    %allBrainData.leftHemisphere.surf.faces = glpfaces;
    allBrainData.leftHemisphere.surf.nodes = nvl;
    %allBrainData.leftHemisphere.surf.nodes = glpvertex;

    % Right hemisphere
    allBrainData.rightHemisphere.surf.faces = nfr;
    %allBrainData.rightHemisphere.surf.faces = grpfaces;
    allBrainData.rightHemisphere.surf.nodes = nvr;
    %allBrainData.rightHemisphere.surf.nodes = grpvertex;

    % Both hemispheres make a whole.
    allBrainData.surf.faces_mni152 = Coor_MNI152;
    [allBrainData.surf.nodes, allBrainData.surf.faces] = mergesurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces);
    %allBrainData.surf.edges = meshedge(allBrainData.surf.faces);
    clearvars glpfaces grpfaces nvl nvr nfl nfr glpvertex grpvertex


    %% All Structural data
    % All structure data
    allStructuralData.adjacencyMatrix = adj_matrix;
    clearvars adj_matrix;

    %% ROI Anatomical Data
    % Add region of interest data (face IDs and centroids).
    roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain = find(ismember(allBrainData.leftHemisphere.labels.names,strcat('lh.L_',roiLabels)));
    roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain = find(ismember(allBrainData.rightHemisphere.labels.names,strcat('rh.R_',roiLabels)));
    %roiStructuralData.faceIdsOfAllBrain = [roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain; length(allBrainData.leftHemisphere.surf.faces) + roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain];
    %roiStructuralData.surf.faces_mni152 = allBrainData.surf.faces_mni152(roiStructuralData.faceIdsOfAllBrain,:);
    roiStructuralData.leftHemisphere.surf.centroids = lpcentroids(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,:);
    roiStructuralData.rightHemisphere.surf.centroids = rpcentroids(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,:);
    roiStructuralData.leftHemisphere.adjacencyMatrix = allStructuralData.adjacencyMatrix(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain);

    %     %Testing if labels are inaccurate...
    % Offset the face IDs of right hemisphere to skip past the left
    % hemisphere faces!
    roiStructuralData.rightHemisphere.adjacencyMatrix = allStructuralData.adjacencyMatrix(length(allBrainData.leftHemisphere.surf.faces) + roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,length(allBrainData.leftHemisphere.surf.faces) + roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain);
    %     adjacencyMatrixChangesAtPoint = find(ischange(roiStructuralData.rightHemisphere.adjacencyMatrix) ==1);
    %     [pointX, pointY] = ind2sub(size(roiStructuralData.rightHemisphere.adjacencyMatrix), adjacencyMatrixChangesAtPoint);
    %     %Update adjacency matrix accordingly...
    %     roiStructuralData.rightHemisphere.adjacencyMatrix = roiStructuralData.rightHemisphere.adjacencyMatrix(1:pointX,1:pointX);
    %     roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain = roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain(1:pointX);

    roiStructuralData.leftHemisphere.labels.names = allBrainData.leftHemisphere.labels.names(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain);
    roiStructuralData.rightHemisphere.labels.names = allBrainData.rightHemisphere.labels.names(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain);
    roiStructuralData.subCortical.labels.names = []; % script is incompatible with ROI within the subcortical regions.


    clearvars rpcentroids lpcentroids Coor_MNI305 Coor_MNI152;
    % --------
    % ----
    % --------



    %% ROI Structural Data
    if(exist('tempStore','var'))
        if(~isempty(tempStore.leftStructuralModules) && ~isempty(tempStore.rightStructuralModules) && ~isempty(tempStore.leftOptimalGamma) && ~isempty(tempStore.rightOptimalGamma))
            allBrainData.leftHemisphere.surf.faces(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,4) = tempStore.leftStructuralModules;
            allBrainData.rightHemisphere.surf.faces(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,4) = tempStore.rightStructuralModules;
            allBrainData.leftHemisphere.optimalGamma = tempStore.leftOptimalGamma;
            allBrainData.rightHemisphere.optimalGamma = tempStore.rightOptimalGamma;
        else
            disp('Please clear workspace and try again.')
        end

    else
        disp('Sorting DWI data into modules...');

        if(size(roiStructuralData.leftHemisphere.adjacencyMatrix,1) > 0)
            if(isfile([pathToParticipants '/' subject '/moduleResults/leftStructuralModules.mat']))
                load([pathToParticipants '/' subject '/moduleResults/leftStructuralModules.mat'], "leftStructuralModules");
                [allBrainData.leftHemisphere.surf.faces(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,4)] = leftStructuralModules;
            else
                if(isfile([pathToParticipants '/' subject '/moduleResults/leftOptimalGamma.mat']))
                    load([pathToParticipants '/' subject '/moduleResults/leftOptimalGamma.mat'], "leftOptimalGamma");
                    allBrainData.leftHemisphere.optimalGamma = leftOptimalGamma;
                else
                    %[leftOptimalGamma] = findOptimalGamma(pathToParticipants, subject, roiStructuralData.leftHemisphere.adjacencyMatrix, 0.6, 1.4, visualiseData)
                    [leftOptimalGamma] = findOptimalGamma(pathToParticipants, subject, roiStructuralData.leftHemisphere.adjacencyMatrix, 0.7, 0.74, visualiseData)
                    allBrainData.leftHemisphere.optimalGamma = leftOptimalGamma;
                    filename=[pathToParticipants '/' subject '/moduleResults/leftOptimalGamma.mat'];
                    save(filename,'leftOptimalGamma','-v7.3');
                end
                [allBrainData.leftHemisphere.surf.faces(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,4), allBrainData.leftHemisphere.Q1] = sortIntoModules(roiStructuralData.leftHemisphere.adjacencyMatrix, allBrainData.leftHemisphere.optimalGamma);
                filename=[pathToParticipants '/' subject '/moduleResults/leftStructuralModules.mat'];
                leftStructuralModules = allBrainData.leftHemisphere.surf.faces(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,4);
                save(filename,'leftStructuralModules','-v7.3');
            end
        else
            allBrainData.leftHemisphere.optimalGamma = [];
        end


        if(size(roiStructuralData.rightHemisphere.adjacencyMatrix,1) > 0)
            if(isfile([pathToParticipants '/' subject '/moduleResults/rightStructuralModules.mat']))
                load([pathToParticipants '/' subject '/moduleResults/rightStructuralModules.mat'], "rightStructuralModules");
                [allBrainData.rightHemisphere.surf.faces(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,4)] = rightStructuralModules;
            else
                if(isfile([pathToParticipants '/' subject '/moduleResults/rightOptimalGamma.mat']))
                    load([pathToParticipants '/' subject '/moduleResults/rightOptimalGamma.mat'], "rightOptimalGamma");
                    allBrainData.rightHemisphere.optimalGamma = rightOptimalGamma;
                else
                    %[rightOptimalGamma] = findOptimalGamma(pathToParticipants, subject, roiStructuralData.rightHemisphere.adjacencyMatrix, 0.6, 1.4, visualiseData)
                    [rightOptimalGamma] = findOptimalGamma(pathToParticipants, subject, roiStructuralData.rightHemisphere.adjacencyMatrix, 0.7, 0.74, visualiseData)
                    allBrainData.rightHemisphere.optimalGamma = rightOptimalGamma;
                    filename=[pathToParticipants '/' subject '/moduleResults/rightOptimalGamma.mat'];
                    save(filename,'rightOptimalGamma','-v7.3');
                end
                [allBrainData.rightHemisphere.surf.faces(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,4), allBrainData.rightHemisphere.Q1] = sortIntoModules(roiStructuralData.rightHemisphere.adjacencyMatrix, allBrainData.rightHemisphere.optimalGamma);
                filename=[pathToParticipants '/' subject '/moduleResults/rightStructuralModules.mat'];
                rightStructuralModules = allBrainData.rightHemisphere.surf.faces(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,4);
                save(filename,'rightStructuralModules','-v7.3');
            end
        else
            allBrainData.rightHemisphere.optimalGamma = [];
        end
    end

    %% fMRI data
    % As of version 2, fMRI and diffusion data are in the same space
    % (MNI152). 
    % Note: the nodes of the fMRI are NOT in the same space, so we cannot
    % just reassign a colour as seen for structural. Instead, we build a
    % surface (for 3D visualisation) and also project each point onto the anatomical surface.
    % allFunctionalData.surf.faces_mni152 = funcXyzCoordinatesmm; %unused.

    allBrainData.rightHemisphere.surf.faces(allNeighbouringFaces,5) = moduleIndex;
    allBrainData.rightHemisphere.surf.faces(allNeighbouringFaces,5) = moduleIndex;

    allFunctionalData.moduleIds = fmriModules(:); % for each node, list its module id.
    xSubsection = 1:1:size(fmriModules,1);
    ySubsection = 1:1:size(fmriModules,2);
    zSubsection = 1:1:size(fmriModules,3);
    opt.keepratio = 1;
    opt.radbound = 10;
    opt.distbound = 0.2;
    allBrainData.leftHemisphere.surf.faces(:,5) = 0;
    allBrainData.rightHemisphere.surf.faces(:,5) = 0;

   
    

    %         %% Build connectivity matrix from fMRI -- ABANDONED.
    %         leftFmriFaceIds = find(~allBrainData.leftHemisphere.surf.faces(:,5) == 0);
    %         leftFaceNeighbors = edgeneighbors(allBrainData.leftHemisphere.surf.faces(leftFmriFaceIds,1:3),'general');
    %         for faceId=leftFmriFaceIds
    %             % For each activate face, check if its neighbors are active. If
    %             % they are not, remove them from the list.
    %             for neighborId=leftFaceNeighbors
    %                 if(allBrainData.leftHemisphere.surf.faces([leftFaceNeighbors{neighborId,:}],5) >0)
    %             leftFaceNeighbors(faceId) =  [leftFaceNeighbors{2,:}]
    %         end

    % To illustrate faces that have overlap with DWI and fMRI, we add a 6th
    % column of ones where there is overlap.
    leftFacesWithOverlap = intersect(find(~allBrainData.leftHemisphere.surf.faces(:,4) == 0),find(~allBrainData.leftHemisphere.surf.faces(:,5) == 0));
    allBrainData.leftHemisphere.surf.faces(leftFacesWithOverlap,6) = 1;

    rightFacesWithOverlap = intersect(find(~allBrainData.rightHemisphere.surf.faces(:,4) == 0),find(~allBrainData.rightHemisphere.surf.faces(:,5) == 0));
    allBrainData.rightHemisphere.surf.faces(rightFacesWithOverlap,6) = 1;

    %% VISUALISATIONS


    % Visualise the merged brain.
    figure;
    title("Whole brain");
    subtitle("Left and right hemisphere merged before any computation.");
    plotmesh(allBrainData.surf.nodes, allBrainData.surf.faces);
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/whole-brain'],'compact');


    figure;

    % fMRI activations
    title('fMRI modules determined by meshing all surfaces at once.');
    hold on;
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces,'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');
    plotsurf(allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/fmri-modules-at-once'],'compact');



    % Visualise fMRI activations on the anatomical surface.
    figure;
    hold on;
    title('fMRI activations projected to nearest surface triangle.');
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,5)==0),[1:3,5]),'FaceAlpha',0.7,'FaceColor',[0.9 0.9 0.9],'EdgeAlpha',0.2,'EdgeColor',[0.5 0.5 0.5],'DisplayName','Left hemisphere');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,5)==0),[1:3,5]),'FaceAlpha',0.7,'FaceColor',[0.9 0.9 0.9],'EdgeAlpha',0.2,'EdgeColor',[0.5 0.5 0.5],'DisplayName','Right hemisphere');

    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,5)>0),[1:3,5]),'FaceAlpha',0.8,'EdgeAlpha',0.7,'FaceColor','interp','DisplayName','fMRI Activations/Modules');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,5)>0),[1:3,5]),'FaceAlpha',0.8,'EdgeAlpha',0.7,'FaceColor','interp','DisplayName','fMRI Activations/Modules');
    lightangle(100,0);
    lightangle(0,0);
    lightangle(100,100);
    view(0,90);
    legend;
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/fmri-modules-to-surface'],'compact');


    figure;
    title("Structural modules of the precentral gyrus");
    hold on;
    xlabel('Left-Right');
    ylabel('Anterior-Posterior');
    zlabel('Inferior-Superior');
    hold on;
    ax = gca;               % get the current axis
    ax.Clipping = 'off';    % turn clipping off
    camlight;
    lightangle(-45,30);
    lightangle(100,0);
    lightangle(0,0);
    lightangle(100,100);
    lighting gouraud;
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4) == 0),1:4),'DisplayName','Left hemisphere','EdgeColor','#575757','EdgeAlpha',0.2,'FaceColor','#d69696','Marker','o','MarkerSize',1);
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4) == 0),1:4),'DisplayName','Right hemisphere','EdgeColor','#575757','EdgeAlpha',0.2,'FaceColor','#d69696','Marker','o','MarkerSize',1);
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4) > 0),1:4),'DisplayName','Structural module','EdgeColor','#575757','EdgeAlpha',0.2,'Marker','o','MarkerSize',1,'Faceghtghting','none');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4) > 0),1:4),'DisplayName','Structural module','EdgeColor','#575757','EdgeAlpha',0.2,'Marker','o','MarkerSize',1,'FaceLighting','none');
    legend;
    view(190,25);
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/structural-modules'],'compact');

    clearvars tempStoreOfOptimalGamma tempStoreOfStrucModuleIds;

    figure;
    title("Faces of overlap between function and structure");
    hold on;
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,6) == 0),[1:3,6]),'DisplayName','Left hemisphere');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,6) == 0),[1:3,6]),'DisplayName','Right hemisphere');
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,6) > 0),[1:3,6]),'DisplayName','fMRI + Structure','FaceColor','r');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,6) > 0),[1:3,6]),'DisplayName','fMRI + Structure','FaceColor','r');
    legend;
    view(190,25);
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/faces-of-overlap'],'compact');



    %% PLOTTING OF ADJACENCY MATRICES.
    figure;
    axis vis3d equal;
    title('Global network - connectivity matrix');
    subtitle('Square shows local connectivity (figure 2)');
    plottedLabels = [allBrainData.leftHemisphere.labels.names; allBrainData.rightHemisphere.labels.names; allBrainData.subCortical.labels.names];
    spy(allStructuralData.adjacencyMatrix);
    % Broken, doesnt work when both hemisphere are selected!
    %Left hemisphere ROI
    rectangle('Position',[min(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain) min(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain)], 'EdgeColor','red')
    % Right hemisphere ROI
    rectangle('Position',[length(allBrainData.leftHemisphere.surf.faces) + min(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain) length(allBrainData.leftHemisphere.surf.faces) + min(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain)], 'EdgeColor','red')

    xticks(1:showTicksPer:length(plottedLabels));
    yticks(1:showTicksPer:length(plottedLabels));
    xticklabels(plottedLabels(1:showTicksPer:end));
    yticklabels(plottedLabels(1:showTicksPer:end));
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/global-matrix'],'compact');


    if(numel(roiStructuralData.leftHemisphere.adjacencyMatrix) > 0)
        figure;
        title('Local network (lSF-lSP) - connectivity matrix (left)')

        plottedLabels = roiStructuralData.leftHemisphere.labels.names;
        spy(roiStructuralData.leftHemisphere.adjacencyMatrix);

        xticks(1:(showTicksPer/50):length(plottedLabels));
        yticks(1:(showTicksPer/50):length(plottedLabels));
        xticklabels(plottedLabels(1:(showTicksPer/50):end));
        yticklabels(plottedLabels(1:(showTicksPer/50):end));
        savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/local-left-matrix'],'compact');
    end

    if(numel(roiStructuralData.rightHemisphere.adjacencyMatrix) > 0)
        figure;
        title('Local network (lSF-lSP) - connectivity matrix (right)')

        plottedLabels = roiStructuralData.rightHemisphere.labels.names;
        spy(roiStructuralData.rightHemisphere.adjacencyMatrix);

        xticks(1:(showTicksPer/50):length(plottedLabels));
        yticks(1:(showTicksPer/50):length(plottedLabels));
        xticklabels(plottedLabels(1:(showTicksPer/50):end));
        yticklabels(plottedLabels(1:(showTicksPer/50):end));
        savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/local-right-matrix'],'compact');

    end
    toc;
    disp("Saving...");
    % Remove data that we won't use again.
    allBrainData.surf = [];
    allBrainData.leftHemisphere.surfaceNorm = [];
    allBrainData.rightHemisphere.surfaceNorm = [];
    allBrainData.leftHemisphere.nodesToFaces = [];
    allBrainData.rightHemisphere.nodesToFaces = [];
    if(size(allFunctionalData.modules,2) == 0)
        disp("This subject had no fMRI activations!");
    end


    %% IMPORTED FROM CALCULATEOVERLAP.M
    leftOverlappingFaces = find(allBrainData.leftHemisphere.surf.faces(:,6) == 1);
    leftOffset = max(allBrainData.leftHemisphere.surf.faces(:,5))+1;
    allBrainData.leftHemisphere.surf.faces(allBrainData.leftHemisphere.surf.faces(:,5)>0,5) = allBrainData.leftHemisphere.surf.faces(allBrainData.leftHemisphere.surf.faces(:,5)>0,5) + leftOffset;
    allBrainData.leftHemisphere.surf.faces(:,7) = allBrainData.leftHemisphere.surf.faces(:,4) + allBrainData.leftHemisphere.surf.faces(:,5);

    maxLeftStructuralModule = max(allBrainData.leftHemisphere.surf.faces(:,4),[],'all');
    for moduleIndex=1:maxLeftStructuralModule
        %% For each module, get its outline.
        % Edges are defined by two indexes - the two nodes they connect.
        leftStrucModuleFacesIndexes{moduleIndex} = find(allBrainData.leftHemisphere.surf.faces(:,4) == moduleIndex);
        leftStrucModuleFacesBiggerThan1Indexes{moduleIndex} = length(find(allBrainData.leftHemisphere.surf.faces(:,4) == moduleIndex)) > 1;
        leftStrucModuleNodeIndexesTemp = allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},1:3);
        leftStrucModuleNodeIndexes = unique(leftStrucModuleNodeIndexesTemp(:));
        allBrainData.leftHemisphere.surf.nodes(leftStrucModuleNodeIndexes,4) = moduleIndex;
        [strucEdges{moduleIndex},~]=surfedge(allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},1:3));
    end

    leftFuncModuleIndexes = transpose(unique(allBrainData.leftHemisphere.surf.faces(leftOverlappingFaces,5)));
    %funcModuleIndexes = transpose(unique(allBrainData.leftHemisphere.surf.faces(allBrainData.leftHemisphere.surf.faces(:,5)>0,5)));

    for funcModuleIndex=leftFuncModuleIndexes
        leftFuncModuleFacesIndexes{funcModuleIndex} = intersect(leftOverlappingFaces,find(allBrainData.leftHemisphere.surf.faces(:,5) == funcModuleIndex));

        leftGlobalFuncModuleFacesIndexes{funcModuleIndex}= find(allBrainData.leftHemisphere.surf.faces(:,5) == funcModuleIndex);

        leftFuncModuleNodeIndexesTemp = allBrainData.leftHemisphere.surf.faces(leftFuncModuleFacesIndexes{funcModuleIndex},1:3);
        leftFuncModuleNodeIndexes{funcModuleIndex} = unique(leftFuncModuleNodeIndexesTemp(:));
        [leftFuncEdges{funcModuleIndex},~]=surfedge(allBrainData.leftHemisphere.surf.faces(leftFuncModuleFacesIndexes{funcModuleIndex},(1:3)));
    end

    rightOverlappingFaces = find(allBrainData.rightHemisphere.surf.faces(:,6) == 1);
    rightOffset = max(allBrainData.rightHemisphere.surf.faces(:,5))+1;
    allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5) = allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5) + rightOffset;
    allBrainData.rightHemisphere.surf.faces(:,7) = allBrainData.rightHemisphere.surf.faces(:,4) + allBrainData.rightHemisphere.surf.faces(:,5);

    %globalFunctionalModules = transpose(unique(allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5)));

    maxRightStructuralModule = max(allBrainData.rightHemisphere.surf.faces(:,4),[],'all');
    for moduleIndex=1:maxRightStructuralModule
        %% For each module, get its outline.
        % Edges are defined by two indexes - the two nodes they connect.
        rightStrucModuleFacesIndexes{moduleIndex} = find(allBrainData.rightHemisphere.surf.faces(:,4) == moduleIndex);
        rightStrucModuleFacesBiggerThan1Indexes{moduleIndex} = length(find(allBrainData.rightHemisphere.surf.faces(:,4) == moduleIndex)) > 1;
        rightStrucModuleNodeIndexesTemp = allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3);
        rightStrucModuleNodeIndexes = unique(rightStrucModuleNodeIndexesTemp(:));
        rightStrucModuleAreaMm{moduleIndex} = sum(elemvolume(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3)));
        allBrainData.rightHemisphere.surf.nodes(rightStrucModuleNodeIndexes,4) = moduleIndex;
        [strucEdges{moduleIndex},~]=surfedge(allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3));
    end

    rightFuncModuleIndexes = transpose(unique(allBrainData.rightHemisphere.surf.faces(rightOverlappingFaces,5)));
    %funcModuleIndexes = transpose(unique(allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5)));

    for funcModuleIndex=rightFuncModuleIndexes
        rightFuncModuleFacesIndexes{funcModuleIndex} = intersect(rightOverlappingFaces,find(allBrainData.rightHemisphere.surf.faces(:,5) == funcModuleIndex));
        rightFuncModuleAreaMm{funcModuleIndex} = sum(elemvolume(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},1:3)));

        rightGlobalFuncModuleFacesIndexes{funcModuleIndex}= find(allBrainData.rightHemisphere.surf.faces(:,5) == funcModuleIndex);
        rightGlobalFuncModuleAreaMm{funcModuleIndex} = sum(elemvolume(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},1:3)));

        rightFuncModuleNodeIndexesTemp = allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},1:3);
        rightFuncModuleNodeIndexes{funcModuleIndex} = unique(rightFuncModuleNodeIndexesTemp(:));
        [rightFuncEdges{funcModuleIndex},~]=surfedge(allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},(1:3)));
    end

    figure;
    xlabel('Left-Right');
    ylabel('Anterior-Posterior');
    zlabel('Inferior-Superior');
    hold on;
    ax = gca;               % get the current axis
    ax.Clipping = 'off';    % turn clipping off
    title("Left motor homonculus parcellated into triangular nodes");
    %plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(:,1:3),'DisplayName','Left hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
    plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4) > 0),1:3),'DisplayName','Left hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
    leftColormap_hsv = hsv(maxLeftStructuralModule);
    for moduleIndex=1:maxLeftStructuralModule
        color = leftColormap_hsv(moduleIndex,:);
        plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},1:3),'DisplayName',['Structural Module: #' num2str(moduleIndex)],'EdgeAlpha',0.3,'FaceColor',[color]);
        %plotedges(allBrainData.leftHemisphere.surf.nodes(:,1:3), strucEdges{moduleIndex},'linewidth',randi(5,1),'Color',[color 0.9],'linestyle','-','DisplayName',['Structural Module: #' num2str(moduleIndex)]);
    end

    leftColormap_jet = jet(length(leftFuncModuleIndexes));
    count = 0;
    for funcModuleIndex=leftFuncModuleIndexes
        count = count+1;
        color = leftColormap_jet(count,:);
        %plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surf.faces(intersect(leftOverlappingFaces,funcModuleFacesIndexes{funcModuleIndex}),1:3),'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'EdgeAlpha',0.3,'FaceColor',colormap_jet(funcModuleIndex,:));
        plotedges(allBrainData.leftHemisphere.surf.nodes(:,1:3), leftFuncEdges{funcModuleIndex},'linewidth',3,'Color',[color],'linestyle','-','DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3,'AlignVertexCenters','on','HandleVisibility','off');
        plot(NaN,NaN,'linewidth',5,'Color',[color],'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3)
    end

    camlight;
    lighting gouraud;
    legend;
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/left-precentral-gyrus-struc-and-func'],'compact');


    figure;
    xlabel('Left-Right');
    ylabel('Anterior-Posterior');
    zlabel('Inferior-Superior');
    hold on;
    ax = gca;               % get the current axis
    ax.Clipping = 'off';    % turn clipping off
    title("Right motor homonculus parcellated into triangular nodes");
    %plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(:,1:3),'DisplayName','Left hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
    plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4) > 0),1:3),'DisplayName','Right hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
    rightColormap_hsv = hsv(maxRightStructuralModule);
    for moduleIndex=1:maxRightStructuralModule
        color = rightColormap_hsv(moduleIndex,:);
        plotsurf(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3),'DisplayName',['Structural Module: #' num2str(moduleIndex)],'EdgeAlpha',0.3,'FaceColor',[color]);
    end

    rightColormap_jet = jet(length(rightFuncModuleIndexes));
    count = 0;
    for funcModuleIndex=rightFuncModuleIndexes
        count = count+1;
        color = rightColormap_jet(count,:);
        %plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surf.faces(intersect(leftOverlappingFaces,funcModuleFacesIndexes{funcModuleIndex}),1:3),'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'EdgeAlpha',0.3,'FaceColor',colormap_jet(funcModuleIndex,:));
        plotedges(allBrainData.rightHemisphere.surf.nodes(:,1:3), rightFuncEdges{funcModuleIndex},'linewidth',3,'Color',[color],'linestyle','-','DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3,'AlignVertexCenters','on','HandleVisibility','off');
        plot(NaN,NaN,'linewidth',5,'Color',[color],'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3)
    end
    camlight;
    lighting gouraud;
    legend;
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/right-precentral-gyrus-struc-and-func'],'compact');



    figure;
    hold on;
    title("Independent view of each structural module from left hemisphere");
    modulesWith1OrMoreFaces = cat(2,leftStrucModuleFacesBiggerThan1Indexes{:});
    tiledlayout(ceil(sum(modulesWith1OrMoreFaces)/3),3,'TileSpacing','None','Padding','None');

    for moduleIndex=1:maxLeftStructuralModule
        if(modulesWith1OrMoreFaces(moduleIndex) == 1)
            ax = nexttile;               % get the current axis
            hold on;
            ax.Clipping = 'off';    % turn clipping offcamlight;
            light(ax,'Position',[0 0 0]);
            light(ax,'Position',[200 200 200]);
            light(ax,'Position',[-100 70 0]);
            lighting(ax, 'gouraud');
            plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),...
                allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},(1:3)),'DisplayName',['Structural Module: ' moduleIndex],'EdgeAlpha',0.3,'FaceColor',leftColormap_hsv(moduleIndex,:));
        end
    end
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/isolated-struc-modules-left'],'compact');


    figure;
    hold on;
    title("Independent view of each structural module from right hemisphere");
    rightModulesWith1OrMoreFaces = cat(2,rightStrucModuleFacesBiggerThan1Indexes{:});
    tiledlayout(ceil(sum(rightModulesWith1OrMoreFaces)/3),3,'TileSpacing','None','Padding','None');

    for moduleIndex=1:maxRightStructuralModule
        if(rightModulesWith1OrMoreFaces(moduleIndex) == 1)
            ax = nexttile;               % get the current axis
            hold on;
            ax.Clipping = 'off';    % turn clipping offcamlight;
            light(ax,'Position',[0 0 0]);
            light(ax,'Position',[200 200 200]);
            light(ax,'Position',[-100 70 0]);
            lighting(ax, 'gouraud');
            plotsurf(allBrainData.rightHemisphere.surf.nodes(:,1:3),...
                allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},(1:3)),'DisplayName',['Structural Module: ' moduleIndex],'EdgeAlpha',0.3,'FaceColor',rightColormap_hsv(moduleIndex,:));
        end
    end
    savefig(gcf,[pathToParticipants '/' subject '/moduleResults/figures/' num2str(conditionIndex) '/isolated-struc-modules-right'],'compact');




    if(~visualiseData==1)
        close all;
    end
    clearvars -except allBrainData allFunctionalData pathToParticipants subject conditionIndex;
    filename=[pathToParticipants '/' subject '/moduleResults/allBrainData__' num2str(conditionIndex) '.mat'];
    %save(filename,'allBrainData','-v7.3'); %Adding 7.3 makes filesize
    %larger than necessary.
    save(filename,'allBrainData');
    disp("Script finished successfully.");


    sound(sin(1:1000)); pause(0.2); sound(sin(1:1000));
    set(0,'DefaultFigureVisible','on')
catch ME
    sound(tan(1:1000)); pause(0.2); sound(tan(1:1000));
    rethrow(ME);
end
end

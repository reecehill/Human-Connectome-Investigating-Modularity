"""
This type stub file was generated by pyright.
"""

from ..support.protocol import ProtocolInterface

"""Base classes to custom git-annex remotes (e.g. extraction from archives)"""
__docformat__ = ...
lgr = ...
URI_PREFIX = ...
SUPPORTED_PROTOCOL = ...
DEFAULT_COST = ...
DEFAULT_AVAILABILITY = ...
class AnnexRemoteQuit(Exception):
    ...


def get_function_nargs(f): # -> int:
    ...

class AnnexExchangeProtocol(ProtocolInterface):
    """A little helper to protocol interactions of custom remote with annex
    """
    HEADER = ...
    def __init__(self, repopath, custom_remote_name=...) -> None:
        ...
    
    def initiate(self): # -> None:
        ...
    
    def write_section(self, cmd): # -> None:
        ...
    
    def write_entries(self, entries): # -> None:
        ...
    
    def __iadd__(self, entry): # -> Self@AnnexExchangeProtocol:
        ...
    
    def start_section(self, cmd): # -> int:
        ...
    
    def end_section(self, id_, exception): # -> None:
        ...
    
    def add_section(self, cmd, exception): # -> None:
        ...
    
    @property
    def records_callables(self): # -> Literal[False]:
        ...
    
    @property
    def records_ext_commands(self): # -> Literal[True]:
        ...
    
    @property
    def do_execute_ext_commands(self): # -> Literal[True]:
        ...
    
    @property
    def do_execute_callables(self): # -> Literal[True]:
        ...
    


class AnnexCustomRemote:
    """Base class to provide custom special remotes for git-annex

    Implements git-annex special custom remotes protocol described
    at
    http://git-annex.branchable.com/design/external_special_remote_protocol/
    """
    CUSTOM_REMOTE_NAME = ...
    SUPPORTED_SCHEMES = ...
    COST = ...
    AVAILABILITY = ...
    def __init__(self, path=..., cost=..., fin=..., fout=...) -> None:
        """
        Parameters
        ----------
        path : string, optional
            Path to the repository for which this custom remote is serving.
            Usually this class is instantiated by a script which runs already
            within that directory, so the default is to point to current
            directory, i.e. '.'
        fin:
        fout:
            input/output streams.  If not specified, stdin, stdout used
        """
        ...
    
    def get_contentlocation(self, key, absolute=..., verify_exists=...): # -> str:
        """Return (relative to top or absolute) path to the file containing the key

        This is a wrapper around AnnexRepo.get_contentlocation which provides caching
        of the result (we are asking the location for the same archive key often)
        """
        ...
    
    def send(self, *args): # -> None:
        """Send a message to git-annex

        Parameters
        ----------
        `*args`: list of strings
           arguments to be joined by a space and passed to git-annex
        """
        ...
    
    def send_unsupported(self, msg=...): # -> None:
        """Send UNSUPPORTED-REQUEST to annex and log optional message in our log
        """
        ...
    
    def read(self, req=..., n=...): # -> list[str] | None:
        """Read a message from git-annex

        Parameters
        ----------

        req : string, optional
           Expected request - first msg of the response
        n : int
           Number of response elements after first msg
        """
        ...
    
    def heavydebug(self, msg, *args, **kwargs): # -> None:
        ...
    
    def debug(self, msg): # -> None:
        ...
    
    def error(self, msg, annex_err=...): # -> None:
        ...
    
    def info(self, msg): # -> None:
        ...
    
    def progress(self, bytes): # -> None:
        ...
    
    def main(self): # -> None:
        """Interface to the command line tool"""
        ...
    
    def stop(self, msg=...):
        ...
    
    def req_INITREMOTE(self, *args): # -> None:
        """Initialize this remote. Provides high level abstraction.

        Specific implementation should go to _initialize
        """
        ...
    
    def req_PREPARE(self, *args): # -> None:
        """Prepare "to deliver". Provides high level abstraction

         Specific implementation should go to _prepare
         """
        ...
    
    def req_EXPORTSUPPORTED(self): # -> None:
        ...
    
    def req_GETCOST(self): # -> None:
        ...
    
    def req_GETAVAILABILITY(self): # -> None:
        ...
    
    def req_CLAIMURL(self, url): # -> None:
        ...
    
    def req_TRANSFER(self, cmd, key, file): # -> None:
        ...
    
    def req_CHECKURL(self, url): # -> None:
        """
        The remote replies with one of CHECKURL-FAILURE, CHECKURL-CONTENTS, or CHECKURL-MULTI.

        CHECKURL-CONTENTS Size|UNKNOWN Filename
            Indicates that the requested url has been verified to exist.
            The Size is the size in bytes, or use "UNKNOWN" if the size could not be determined.
            The Filename can be empty (in which case a default is used), or can specify a filename that is suggested to be used for this url.

        CHECKURL-MULTI Url Size|UNKNOWN Filename ...
            Indicates that the requested url has been verified to exist, and contains multiple files, which can each be accessed using their own url.
            Note that since a list is returned, neither the Url nor the Filename can contain spaces.

        CHECKURL-FAILURE
            Indicates that the requested url could not be accessed.
        """
        ...
    
    def req_CHECKPRESENT(self, key):
        """
        CHECKPRESENT-SUCCESS Key
            Indicates that a key has been positively verified to be present in the remote.
        CHECKPRESENT-FAILURE Key
            Indicates that a key has been positively verified to not be present in the remote.
        CHECKPRESENT-UNKNOWN Key ErrorMsg
            Indicates that it is not currently possible to verify if the key is present in the remote. (Perhaps the remote cannot be contacted.)
        """
        ...
    
    def req_REMOVE(self, key):
        """
        REMOVE-SUCCESS Key
            Indicates the key has been removed from the remote. May be returned if the remote didn't have the key at the point removal was requested.
        REMOVE-FAILURE Key ErrorMsg
            Indicates that the key was unable to be removed from the remote.
        """
        ...
    
    def req_WHEREIS(self, key):
        """Added in 5.20150812-17-g6bc46e3

        provide any information about ways to access the content of a key stored in it,
        such as eg, public urls. This will be displayed to the user by eg,
        git annex whereis. The remote replies with WHEREIS-SUCCESS or WHEREIS-FAILURE.
        Note that users expect git annex whereis to run fast, without eg, network access.
        This is not needed when SETURIPRESENT is used, since such uris are automatically
        displayed by git annex whereis.

        WHEREIS-SUCCESS String
            Indicates a location of a key. Typically an url, the string can be anything
            that it makes sense to display to the user about content stored in the special
            remote.
        WHEREIS-FAILURE
            Indicates that no location is known for a key.
        """
        ...
    
    def get_DIRHASH(self, key, full=...): # -> str:
        """Gets a two level hash associated with a Key.

        Parameters
        ----------
        full: bool, optional
          If True, would spit out full DIRHASH path, i.e. with a KEY/ directory

        Something like "abc/def". This is always the same for any given Key, so
        can be used for eg, creating hash directory structures to store Keys in.
        """
        ...
    
    def get_URLS(self, key): # -> list[Unknown]:
        """Gets URL(s) associated with a Key.

        """
        ...
    


def generate_uuids(): # -> dict[str, str]:
    """Generate UUIDs for our remotes. Even though quick, for consistency pre-generated and recorded in consts.py"""
    ...

def init_datalad_remote(repo, remote, encryption=..., autoenable=..., opts=...):
    """Initialize datalad special remote"""
    ...


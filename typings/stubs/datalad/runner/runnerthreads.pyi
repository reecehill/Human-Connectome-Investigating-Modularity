"""
This type stub file was generated by pyright.
"""

import threading
from abc import ABCMeta, abstractmethod
from enum import Enum
from queue import Queue
from subprocess import Popen
from typing import Any, IO, Optional

lgr = ...
class IOState(Enum):
    ok = ...
    process_exit = ...


class SignalingThread(threading.Thread):
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, Optional[bytes]]]]) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def signal(self, content: tuple[Any, IOState, Optional[bytes]]) -> bool:
        ...
    


class WaitThread(SignalingThread):
    """
    Instances of this thread wait for a process to exit and enqueue
    an exit event in the signal queues.
    """
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, Optional[bytes]]]], process: Popen) -> None:
        ...
    
    def run(self) -> None:
        ...
    


class ExitingThread(SignalingThread):
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, Optional[bytes]]]]) -> None:
        ...
    
    def request_exit(self) -> None:
        """
        Request the thread to exit. This is not guaranteed to
        have any effect, because the instance has to check for
        self.exit_requested and act accordingly. It might not
        do that.
        """
        ...
    


class TransportThread(ExitingThread, metaclass=ABCMeta):
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, Optional[bytes]]]], user_info: Any) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def signal_event(self, state: IOState, data: Optional[bytes]) -> bool:
        ...
    
    @abstractmethod
    def read(self) -> Optional[bytes]:
        """
        Read data from source return None, if source is close,
        or destination close is required.
        """
        ...
    
    @abstractmethod
    def write(self, data: bytes) -> bool:
        """
        Write given data to destination, return True if data is
        written successfully, False otherwise.
        """
        ...
    
    def run(self) -> None:
        ...
    


class ReadThread(TransportThread):
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, Optional[bytes]]]], user_info: Any, source: IO, destination_queue: Queue[tuple[Any, IOState, bytes]], length: int = ...) -> None:
        ...
    
    def read(self) -> Optional[bytes]:
        ...
    
    def write(self, data: bytes) -> bool:
        ...
    


class WriteThread(TransportThread):
    def __init__(self, identifier: str, signal_queues: list[Queue[tuple[Any, IOState, Optional[bytes]]]], user_info: Any, source_queue: Queue[Optional[bytes]], destination: IO) -> None:
        ...
    
    def read(self) -> Optional[bytes]:
        ...
    
    def write(self, data: bytes) -> bool:
        ...
    



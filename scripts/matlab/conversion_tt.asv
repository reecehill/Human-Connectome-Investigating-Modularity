function [trkEP_full,trk_len_full,trk_type_full]=conversion_tt(pathToFile, type)
%% load tt file generated by dsi studio
%close all;
% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS
gcp; %start parallel pool.

addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));


display('step1: performing conversion from .trk to surface and atlas')
display(['Type: ' num2str(type) ' (' class(type) ')'])
%ft_defaults
%atlas=ft_read_mri([pathToFile,'/mri/aparc+aseg.nii']);
atlas=ft_read_mri([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);
trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0_new.tt.nii.gz']);
figure;
slice(double(atlas.anatomy),size(atlas.anatomy,2)/2,size(atlas.anatomy,1)/2,size(atlas.anatomy,3)/2);
figure;
trackImg.anatomy = flip(trackImg.anatomy,2);
slice(double(trackImg.anatomy),size(trackImg.anatomy,2)/2,size(trackImg.anatomy,1)/2,size(trackImg.anatomy,3)/2);

 
%trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);

%TODO: We must first flip the Y coordinates (LPS -> LAS)
% The T1w image is LAS
% The dsistudio tracks are LPS

if type==1
    atlasCRSToTkRAS = atlas.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
elseif type==2
    atlasCRSToTkRAS = atlas.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
    ttCRSToTkRAS = trackImg.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
    Reg = importdata([pathToFile '/MNINonLinear/register.dat']);
    Reg = reshape(Reg.data(4:end), [4 4])';
else
    display('wrong type of surface')
end
dimL = atlas.dim(1);
dimP = atlas.dim(2);
dimS = atlas.dim(3);

ttMat = [trackImg.transform(1,1)   0   0  0;
              0   trackImg.transform(2,2)   0  0;
              0   0   trackImg.transform(3,3)   0;
              0   0   0   1]; 


ttMat =  [atlasCRSToTkRAS(1,1)   0   0  0;
               0   0   atlasCRSToTkRAS(2,3)  0;
              0   atlasCRSToTkRAS(3,2)   0   0;
              0   0   0   1] * ...
              [  0.7   0   0   0;
              0   -0.7   0   0;
              0   0   0.7   -0;
              0   0   0   1] * ...
              [     .7   0   0  atlasCRSToTkRAS(1,4);
              0   .7   0  -atlasCRSToTkRAS(3,4);
              0   0   .7   atlasCRSToTkRAS(2,4);
              0   0   0   1]; 

ttMat =      ttCRSToTkRAS * trackImg.transform;
           

atlasMat = [1   0   0  0;
              0   1   0  0;
              0   0   1   0;
              0   0   0   1];

surfMat = atlasCRSToTkRAS*atlasMat;  % from .tt to pial files.


trk_len_full=[];
trk_type_full=[];
trkEP_full=[];
for i=1:1
    gunzip([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'_new.tt.gz'],[pathToFile,'/T1w/Diffusion']);
    movefile([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'_new.tt'],[pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'_new.mat']);
    load([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'_new.mat'], "color", "dimension", "track", "trans_to_mni", "voxel_size");

    tracts = parse_tt(track);

    % filename2 = [pathToFile,'/tracks_mat.mat'];
    % eval(['load(filename2)']);
    % tracts = tracts';
    % for i = 1: length(rawTrk)
    %     rawTrk(i).matrix = tracts(1:rawTrk(i).nPoints,:);
    %     tracts(1:rawTrk(i).nPoints,:) = [];
    % end
    %
    %

    lenrawTrk=length(tracts);

    % vs = 1;

    % trk_len, 8th is true|false in grey matter both ends
    trk_len=zeros(lenrawTrk,1,'single');
    trk_type=zeros(lenrawTrk,3,'single');
    trkEP=zeros(lenrawTrk,6,'single');%
    % trkEPatlas=zeros(lenrawTrk,6,'single');%
    nNotInAtlas = 0;
    figure;
    hold on;
    storeTrkStartP = zeros([lenrawTrk,3]);
    storeTrkEndP = zeros([lenrawTrk,3]);
    storeTrkStartCoords = zeros([lenrawTrk,3]);
    for k=1:lenrawTrk

        trkMatrix = cell2mat(tracts(k));
        trkMatrix = trkMatrix ./ voxel_size;

        
        trkMatrixWOnes = [trkMatrix(1,:) 1; trkMatrix(end,:) 1;];
        
        %trkMatrixWOnes(:,1) = -1 * trkMatrixWOnes(:,1);
        %trkMatrixWOnes(:,3) = -1 * trkMatrixWOnes(:,3);

        trkMatrixWOnes = (trkMatrixWOnes')'; % Flip track coordinates LPS -> LAS -> RAS.
        VoxCRS = (round(inv(ttCRSToTkRAS)*trkMatrixWOnes'))'; %convert xyz (coords: LPS) to ijk (indices: LPS).



        %for the transformation into anatomy space
        trka = trkMatrix./voxel_size;
        trkSize=size(trka,1);

        %compute track length
        id1=trka(1:end-1,:);
        id2=trka(2:end,:);
        dist=sqrt( (id1(:,1)-id2(:,1)).^2 +(id1(:,2)-id2(:,2)).^2 +(id1(:,3)-id2(:,3)).^2);
        trk_len(k,1)=sum(dist);

        % for the track to pial surface space
        l=1;%start point
        ttemp=surfMat*[trka(l,1); trka(l,2); trka(l,3); 1]; % by Peter
        trkEP(k,1:3)=[single(ttemp(1:3)')];

        l=trkSize;%end point
        ttemp=surfMat*[trka(l,1); trka(l,2); trka(l,3); 1];% by Peter

        trkEP(k,4:6)=[single(ttemp(1:3)')];

        if mod(k/1000,1)==0 %show progress
            disp(num2str(k/lenrawTrk));
        end

        %% code here to see if both endpoints are in the grey matter
        trkstartp = VoxCRS(1,1:3);

        % Where a voxel is now marginally outside atlas.dim due to
        % rounding, bring it back in.
%         voxelsAboveRange = (trkstartp-atlas.dim==1);
%         trkstartp(voxelsAboveRange) = atlas.dim(voxelsAboveRange)';
%         voxelsBelowRange = trkstartp == 0;
%         trkstartp(voxelsBelowRange) = 1;
        %storeTrkStartP(k, 1:4) = [trkMatrix_transformed(1,1:3) 1];
        storeTrkStartP(k, 1:4) = [trkstartp 1];
        storeTrkStartCoords(k, 1:4) = [trkMatrixWOnes(1,1:4)];
        trkendp = VoxCRS(end,1:3);
%         voxelsAboveRange = (trkendp-atlas.dim==1);
%         trkendp(voxelsAboveRange) = atlas.dim(voxelsAboveRange)';
%         voxelsBelowRange = trkendp == 0;
%         trkendp(voxelsBelowRange) = 1;
        %storeTrkEndP(k, 1:4) = [trkendp 1];
        storeTrkEndP(k, 1:4) = [trkendp 1];

        % by Reece - some trkstart/trkend are outside the atlas range (presumed due to
        % rounding). So, set cap according to atlas dimensions.
%         dimsAboveRange = find(trkstartp>atlas.dim(:));
%         dimsBelowRange = trkstartp<1;
%         trkstartp(dimsAboveRange) = atlas.dim(dimsAboveRange);
%         trkstartp(dimsBelowRange) = 1;

%         dimsAboveRange = find(trkendp>atlas.dim(:));
%         dimsBelowRange = trkendp<1;
%         trkendp(dimsAboveRange) = atlas.dim(dimsAboveRange);
%         trkendp(dimsBelowRange) = 1;

        % TODO: Insert validation check. Are points being moved inconsiderable
        % distances?
        %

        tmp=zeros(1,3);
        try
            tmp(1:2)=[atlas.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            %scatter3(trkMatrix(1,1),trkMatrix(1,2),trkMatrix(1,3));
            %scatter3(trkMatrix(end,1),trkMatrix(end,2),trkMatrix(end,3));
            nNotInAtlas = nNotInAtlas +1;
        end

%         if(sum(tmp) == 0)
%             nNotInAtlas = nNotInAtlas +1;
%         end




        %for info on the choice of these numbers (1000, 3000 etc) check the
        %freesurfer lookup table.

        % add subcortical regions
        if  ( (tmp(1)<7 && tmp(1)>0) || (tmp(1)>26 && tmp(1)<47) || (tmp(1)<1000 && tmp(1)>58) || (tmp(1)>=3000) ) &&  ( (tmp(2)<7 && tmp(2)>0) || (tmp(2)>26 && tmp(2)<47) || (tmp(2)<1000 && tmp(2)>58) || (tmp(2)>=3000) )
            tmp(1,3)=0;
        elseif ( (tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000) ) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24 && ( (tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000) ) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24
            tmp(1,3)=1;
        elseif tmp(1)==0 && tmp(2)==0
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp)*checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                pause
            end
        elseif tmp(1)==0 && ( ((tmp(2)>=7 && tmp(2)<=26) || (tmp(2)>=47 && tmp(2)<=58) || (tmp(2)>=1000 && tmp(2)<3000)) && tmp(2)~=2000 && tmp(2)~=14 && tmp(2)~=15 && tmp(2)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                pause
            end
        elseif tmp(2)==0 && ( ((tmp(1)>=7 && tmp(1)<=26) || (tmp(1)>=47 && tmp(1)<=58) || (tmp(1)>=1000 && tmp(1)<3000)) && tmp(1)~=2000 && tmp(1)~=14 && tmp(1)~=15 && tmp(1)~=24)
            try
                tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
            catch
                disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;

        %     hold on
        %     plot3(trkstartp(1),trkstartp(2),trkstartp(3),'ok')
        %     plot3(trkendp(1),trkendp(2),trkendp(3),'ok')
        %     hold off

    end
    disp("nNotInAtlas:");
    disp(nNotInAtlas);
    trk_len_full(1+((i-1)*lenrawTrk):(i)*lenrawTrk) =trk_len;
    trk_type_full(1+((i-1)*lenrawTrk):(i)*lenrawTrk,:)=trk_type;
    trkEP_full(1+((i-1)*lenrawTrk):(i)*lenrawTrk,:)=trkEP;
 
    diffCoords = (ttCRSToTkRAS*storeTrkStartP')';
    atlasVoxels = (round(inv(atlasCRSToTkRAS)*diffCoords'))';
    atlasCoords = (atlasCRSToTkRAS*atlasVoxels')';

    %diffCoords = flip(diffCoords,2);
    figure;
    title("Tracts and Aparc in coordinates (xyz)")
    legend on;
    hold on;
    axis
    scatter3(atlasCoords(1:1:end,1),atlasCoords(1:1:end,2),atlasCoords(1:1:end,3), 'DisplayName', "atlasCoords");
    scatter3(diffCoords(1:1:end,1),(diffCoords(1:1:end,2)),diffCoords(1:1:end,3), 'DisplayName', "diffCoords");
    %scatter3(storeTrkStartCoords(:,1),storeTrkStartCoords(:,2),storeTrkStartCoords(:,3), 'DisplayName', "storeTrkStartCoords");
      

    figure;
    title("Tracts and Aparc in voxels (ijk)")
    atlasVoxels = zeros(atlas.dim);
    atlasVoxelsIndices = find(atlas.anatomy > mean(atlas.anatomy,'ALL'));
    [atlasX, atlasY, atlasZ] = ind2sub(atlas.dim, atlasVoxelsIndices);
    atlasVoxels = [atlasX atlasY atlasZ];

    diffVoxels = storeTrkStartP;
    legend on;
    hold on;
    axis
    scatter3(atlasVoxels(1:1:end,1),atlasVoxels(1:1:end,2),atlasVoxels(1:1:end,3), 'DisplayName', "atlasVoxels");
    scatter3(diffVoxels(1:1:end,1),(diffVoxels(1:1:end,2)),diffVoxels(1:1:end,3), 'DisplayName', "diffVoxels");
    %scatter3(storeTrkStartCoords(:,1),storeTrkStartCoords(:,2),storeTrkStartCoords(:,3), 'DisplayName', "storeTrkStartCoords");
      
    end


end

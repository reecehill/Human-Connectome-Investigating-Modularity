function [trkEP_full,trk_len_full,trk_type_full]=conversion_tt(pathToFile, type, nTrackIterations)
% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS

% load tt file generated by dsi studio
close all;
restoredefaultpath;
gcp;
addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));
addpath('toolboxes/FieldTrip');
ft_defaults;
ft_hastoolbox('gifti',1);
ft_hastoolbox('iso2mesh',1);
ft_hastoolbox('freesurfer',1);
disp('step1: performing conversion from .trk to surface and atlas')
disp(['Type: ' num2str(type) ' (' class(type) ')'])

isInDifferentSpace = true;

%atlas image generated by FreeSurfer.
if(isInDifferentSpace)
    atlas_mninonlinear = ft_read_mri([pathToFile '/MNINonLinear/aparc+aseg.nii.gz']);
    tkregister_matrix    = importdata([pathToFile '/MNINonLinear/register_t1w_to_mninonlinear.dat']);
    tkregister_matrix    = reshape(tkregister_matrix.data(4:end), [4 4])';
else
    
end

atlas_t1w = ft_read_mri([pathToFile '/T1w/aparc+aseg.nii.gz']);

disp("It's important to confirm the labels used in your atlas file" + ...
            " (e.g., aparc+aseg) and update the code accordingly. Assumed values for white matter have been used.");

if(exist([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz'],'file'))
    % trackImg generated by DSI Studio (.tt.nii.gz) - saved in aparc+aseg.nii.gz
    % space. Note there is also a .trk file that this file relies on for
    % computations. trackImg is optional for visualisation purposes.
    trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);
end



if type==1
    atlas_t1w_CRSToTkRAS = atlas_t1w.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
    if(isInDifferentSpace)
        atlas_mninonlinear_CRSToTkRAS = atlas_mninonlinear.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
    end
elseif type==2
    atlas_t1w_CRSToTkRAS = atlas_t1w.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
    if(isInDifferentSpace)
        atlas_mninonlinear_CRSToTkRAS = atlas_mninonlinear.hdr.tkrvox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
    end
else
    disp('wrong type of surface')
end


trk_len_full=[];
trk_type_full=[];
trkEP_full=[];

%% Loop through track files
for i=1:str2double(nTrackIterations)
    nTracksWithTwoUnknownEndpoints = 0;
    nTracksWithOneUnknownEndpoint = 0;
    %whiteMatterEndpointLabelIDs =[];

    %Read .trk meta and coordinates.
    [rawTrkHeader, rawtrkCoords_tkReg] = trk_read([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'.trk']);

%     trkCoords_ras = rawtrkCoords_tkReg;
    rawTrkLen=length(rawtrkCoords_tkReg);
    trk_len=zeros(rawTrkLen,1,'single');
    trk_type=zeros(rawTrkLen,3,'single');
    trkEP=zeros(rawTrkLen,6,'single');%
    storeTrkStartP = zeros([4,rawTrkLen]);
    storeTrkEndP = zeros([4,rawTrkLen]);
    storeTrkStartCoords_t1w = zeros([4,rawTrkLen]);
    storeTrkStartCoords_mninonlinear = zeros([4,rawTrkLen]);
    voxel_size = rawTrkHeader.voxel_size;
    atlasT1wDim = atlas_t1w.dim;
    milestones = round(rawTrkLen * (0:0.1:1));
    tic;
    disp("Looping through each track and converting into endpoints.");
    disp("Note: We get the anatomy label using aparc+aseg and *.trk when both in T1w space.");
    disp("Note: Later, and if specified, we move *.trk into MNINonLinear space.");
    
    parfor k=1:rawTrkLen
        if ismember(k,milestones)
            disp((k/rawTrkLen)*100+"%");
        end
        trkMatrix_crs = rawtrkCoords_tkReg(k).matrix ./ voxel_size;

        % Flip Y [LPS (.trk) -> LAS (.anat)]
        trkMatrix_crs(:,2) = (-1 * trkMatrix_crs(:,2)) + atlasT1wDim(2); %flip Y.
        % Define the endpoints of the track.
        trkMatrix_crs_terminals = [trkMatrix_crs(1,:)'  trkMatrix_crs(end,:)'; 1 1;];


        trkstartp = round(trkMatrix_crs_terminals(1:3,1)); %rename for readability
        trkendp = round(trkMatrix_crs_terminals(1:3,end)); %rename for readability
        trkstartp = boundByAtlasDimensions(trkstartp, atlasT1wDim);
        trkendp = boundByAtlasDimensions(trkendp, atlasT1wDim);

        %% Transform track coordinates from CRS into Scanner RAS space
        % Get track coordinates from CRS into Scanner RAS space.
        trkMatrix_ras = atlas_t1w_CRSToTkRAS * [trkMatrix_crs'; ones(1,size(trkMatrix_crs,1))];
        % Get track endpoints from CRS into Scanner RAS space.
        trkMatrix_ras_terminals = atlas_t1w_CRSToTkRAS * trkMatrix_crs_terminals;

%         if(isInDifferentSpace)
%             % Register TkReg track endpoints from DSIStudio default to
%             % subject.
%             trkMatrix_registered_ras = tkregister_matrix * trkMatrix_ras;
%             trkMatrix_registered_ras_terminals = tkregister_matrix * trkMatrix_ras_terminals;
%         end
        

        trkMatrix_registered_ras = trkMatrix_ras;
        trkMatrix_registered_ras_mninonlinear = tkregister_matrix * trkMatrix_ras;
        trkMatrix_registered_ras_terminals = trkMatrix_ras_terminals;
        trkMatrix_registered_ras_terminals_mninonlinear =  tkregister_matrix * trkMatrix_ras_terminals;
        
        
        storeTrkStartP(:, k) = [trkstartp; 1]; % store endpoint in matrix for visualisation.
        storeTrkStartCoords_t1w(:, k) = [trkMatrix_registered_ras(1:3,1); 1]; % store endpoint in matrix for visualisation.
        storeTrkStartCoords_mninonlinear(:, k) = [trkMatrix_registered_ras_mninonlinear(1:3,1); 1]; % store endpoint in matrix for visualisation.
        
        %storeTrkEndP(:, k) = [trkendp; 1];

        %% TODO: Insert validation check. Are points being moved inconsiderable
        %% distances?

        %Compute track length along each vertex
        trkPoints_notLast=trkMatrix_crs(1:end-1,:);
        trkPoints_notFirst=trkMatrix_crs(2:end,:);
        distBetweenTrkPoints=sqrt( (trkPoints_notLast(:,1)-trkPoints_notFirst(:,1)).^2 +(trkPoints_notLast(:,2)-trkPoints_notFirst(:,2)).^2 +(trkPoints_notLast(:,3)-trkPoints_notFirst(:,3)).^2);
        trk_len(k,1)=sum(distBetweenTrkPoints);

        % for the track to pial surface space
        % NOTE: Saved in MNINonLinear space!
        trkEP(k,:)=[double(trkMatrix_registered_ras_terminals_mninonlinear(1:3,1)') double(trkMatrix_registered_ras_terminals_mninonlinear(1:3,end)')];

        % tmp information:
        % 1: trkstartp anatomical label ID
        % 2: trkendp anatomical label ID
        % 3: neighbouring voxels are in grey matter. (e.g., terminating within
        % subcortical structures). 1 = "ends in grey matter".
        tmp=NaN(1,3);
        try
            tmp(1:2)=[atlas_t1w.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas_t1w.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            %scatter3(trkMatrix(1,1),trkMatrix(1,2),trkMatrix(1,3));
            %scatter3(trkMatrix(end,1),trkMatrix(end,2),trkMatrix(end,3));
            disp("Error: The track endpoints yield indices that are not within the atlas image.");
            pause;
        end


        %% Check subcortical regions
        % For info on the choice of these numbers (1000, 3000 etc) check the
        % Freesurfer lookup table:
        % https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT
        ventricularSystemIndices = [14:15,24];
        whiteMatterIndices = [1:6,27:46,59:999,ventricularSystemIndices];
        subcorticalIndices = [7:13,16:23,25:26,47:58,1001:1099,1101:1999,2001:2099,2101:2999];
        unknownIndices = [0,1000,2000,3000,4000,1100,2100,3100,4100,11100,12100,13100,14100];
        if(ismember(tmp(1),whiteMatterIndices) || ...
                ismember(tmp(2),whiteMatterIndices))
            % If either endpoint is in the white matter, mark it.
            tmp(1,3)=0;
            
            if(tmp(1,3) == 0)
                if(ismember(tmp(1),whiteMatterIndices))
                    %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                end
                if(ismember(tmp(2),whiteMatterIndices))
                    %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                end
            end
        else
            % If the tracks do not terminate in white matter, confirm they
            % terminate in grey matter.
            if( ismember(tmp(1),subcorticalIndices) && ...
                    ismember(tmp(2),subcorticalIndices))
                % Both endpoints end in subcortical/grey matter...
                tmp(1,3)=1;
            elseif ( ismember(tmp(1),subcorticalIndices) && ...
                    ismember(tmp(2),unknownIndices))
                % Endpoint starts in subcortical/grey matter but
                % ends in "unknown"...
                try
                    nTracksWithOneUnknownEndpoint = nTracksWithOneUnknownEndpoint + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas_t1w,trkendp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                    pause
                end
            elseif ( ismember(tmp(1),unknownIndices) && ...
                    ismember(tmp(2),subcorticalIndices))
                % Endpoint starts in "unknown" but
                % ends in subcortical/grey matter...
                try
                    nTracksWithOneUnknownEndpoint = nTracksWithOneUnknownEndpoint + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas_t1w,trkstartp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                    pause
                end
            elseif (ismember(tmp(1),unknownIndices) && ...
                    ismember(tmp(2),unknownIndices))
                % If both track endpoints are "unknown"...
                try
                    nTracksWithTwoUnknownEndpoints = nTracksWithTwoUnknownEndpoints + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas_t1w,trkstartp) && checkInNeighbourVoxels_withsubcortical(atlas_t1w,trkendp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                    pause
                end
            else
                disp("Endpoint not analysed.");
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;
    end
    disp("Done looping converting tracks to endpoints.")
    toc;
    disp(["Number of tracks with one unknown endpoint as per atlas:", num2str(nTracksWithOneUnknownEndpoint)]);
    disp(["Number of tracks with both endpoints in unknown as per atlas:", num2str(nTracksWithTwoUnknownEndpoints)]);
    disp(["Number of tracks with start AND end points in grey matter (filtered in):", sum(trk_type(:,3))]);
    if(sum(isnan(trk_type(:,3))) > 0)
        disp(["Number of tracks with endpoints uncategorised as white/grey matter:", num2str(sum(isnan(trk_type(:,3))))]);        
        pause
    end
    disp(["Number of tracks, therefore, concluded to be in white matter (filtered out):", size(trk_type,1)-sum(trk_type(:,3))]);
    disp(["Total tracts:", size(trk_type,1)]);
    
    trk_len_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen) =trk_len;
    trk_type_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trk_type;
    trkEP_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trkEP;

end


%% Visualisations
if(exist("trackImg", "var"))
    figure;
    title("Slices of atlas and trackImg nifti files")
    slice(double(atlas_t1w.anatomy),size(atlas_t1w.anatomy,2)/2,size(atlas_t1w.anatomy,1)/2,size(atlas_t1w.anatomy,3)/2);
    figure;
    trackImg.anatomy = flip(trackImg.anatomy,2);
    slice(double(trackImg.anatomy),size(trackImg.anatomy,2)/2,size(trackImg.anatomy,1)/2,size(trackImg.anatomy,3)/2);
end

if(1 == 0)
    trkCoords_tkReg_t1w = storeTrkStartCoords_t1w';
    trkCoords_tkReg_mninonlinear = storeTrkStartCoords_mninonlinear';

    % Convert: trkCoords_tkReg (tkReg) -> atlas CRS
    atlasCRS_t1w = (round(inv(atlas_t1w_CRSToTkRAS)*trkCoords_tkReg_t1w'))';
    atlasCoords_tkReg_t1w = (atlas_t1w_CRSToTkRAS*atlasCRS_t1w')';

    atlasCRS_mninonlinear = (round(inv(atlas_mninonlinear_CRSToTkRAS)*trkCoords_tkReg_mninonlinear'))';
    atlasCoords_tkReg_mninonlinear = (atlas_mninonlinear_CRSToTkRAS*atlasCRS_mninonlinear')';

    % ----
    % Figure (1): tracts (T1w) and aparc (T1w) superimposed.
    % Used to show tracts are registered to T1w.
    % ---
    figure;
    title("Tracts and Aparc in coordinates (xyz)")
    subtitle(["Tracts=T1w space","aparc+aseg=T1w space"])
    hold on;
    legend;
    scatter3(atlasCoords_tkReg_t1w(:,1),atlasCoords_tkReg_t1w(:,2),atlasCoords_tkReg_t1w(:,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg_t1w(:,1),trkCoords_tkReg_t1w(:,2),trkCoords_tkReg_t1w(:,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'/tracts_t1w__aparc_t1w__cords_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_aparc_xyz.png']);
    
    % ----
    % Figure (2): tracts (MNINonLinear) and aparc (MNINonLinear) superimposed.
    % Used to show tracts are registered to MNINonLinear.
    % ---
    figure;
    title("Tracts and Aparc in coordinates (xyz)")
    subtitle(["Tracts=MNINonLinear space","aparc+aseg=MNINonLinear space"])
    hold on;
    legend;
    scatter3(atlasCoords_tkReg_mninonlinear(:,1),atlasCoords_tkReg_mninonlinear(:,2),atlasCoords_tkReg_mninonlinear(:,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg_mninonlinear(:,1),trkCoords_tkReg_mninonlinear(:,2),trkCoords_tkReg_mninonlinear(:,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'/tracts_mni__aparc_mni__cords_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_mni__aparc_mni__cords_xyz.png']);
    

    % ----
    % Figure (3): tracts (MNINonLinear) and aparc (MNINonLinear) and fmri (MNINonLinear) superimposed.
    % Used to show tracts are registered to MNINonLinear, with coloured
    % faces from fMRI.
    % ---
    mycifti = ft_read_cifti([pathToFile,'/MNINonLinear/Results/tfMRI_MOTOR/tfMRI_MOTOR_hp200_s2_level2_MSMAll.feat/100307_tfMRI_MOTOR_level2_hp200_s2_MSMAll.dscalar.nii']);
    mygifti_L = gifti([pathToFile,'/MNINonLinear/fsaverage_LR32k/100307.L.pial.32k_fs_LR.surf.gii']);
    mygifti_R = gifti([pathToFile,'/MNINonLinear/fsaverage_LR32k/100307.R.pial.32k_fs_LR.surf.gii']);

    figure;
    hold on;
    title("Tracts and Aparc and fMRI in coordinates (xyz)")
    subtitle(["Tracts=MNINonLinear space","aparc+aseg=MNINonLinear space","fMRI=MNINonLinear space"])
    hold on;
    legend;
    xlabel('x');
    ylabel('y');
    zlabel('z');
    mygifti_L_vertices_transformed = [mygifti_L.vertices];
    mygifti_R_vertices_transformed = [mygifti_R.vertices];

    % NB: vertices coords are in SurfaceRAS. Therefore, to go from aparc (CRS)
    % to this, we must use "type 1".
    %mygifti_L.faces(mygifti_L.faces>1) = 1;
    plotsurf(mygifti_L_vertices_transformed(:,1:3), mygifti_L.faces, mycifti.x100307_tfmri_motor_level2_lf_avg_hp200_s2_msmall(mycifti.brainstructure==1), 'DisplayName','L hemisphere surface', 'FaceAlpha', '0.2', 'EdgeAlpha','0.05');
    hold on;
    plotsurf(mygifti_R_vertices_transformed(:,1:3), mygifti_R.faces, mycifti.x100307_tfmri_motor_level2_lf_avg_hp200_s2_msmall(mycifti.brainstructure==2), 'DisplayName','R hemisphere surface', 'FaceAlpha', '0.2', 'EdgeAlpha','0.05');
    scatter3(atlasCoords_tkReg_mninonlinear(:,1),atlasCoords_tkReg_mninonlinear(:,2),atlasCoords_tkReg_mninonlinear(:,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg_mninonlinear(:,1),(trkCoords_tkReg_mninonlinear(:,2)),trkCoords_tkReg_mninonlinear(:,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'/tracts_mni__aparc_mni__fmri_mni__cords_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_mni__aparc_mni__fmri_mni__cords_xyz.png']);

    % ----
    % Figure (4): tracts (T1w) and aparc (T1w).
    % Used to show tracts are registered to T1w using CRS.
    % ---
    figure;
    title("Tracts and Aparc in voxels (ijk)")
    % Build: take atlas.nii.gz and binarize it to approximate volume (CRS)
    atlasCRSIndices = find(atlas_t1w.anatomy > mean(atlas_t1w.anatomy,'ALL'));
    [atlasX, atlasY, atlasZ] = ind2sub(atlas_t1w.dim, atlasCRSIndices);
    atlasCRS_t1w = [atlasX atlasY atlasZ];
    trkCRS = storeTrkStartP;
    hold on;
    legend;
    scatter3(atlasCRS_t1w(1:1:end,1),atlasCRS_t1w(1:1:end,2),atlasCRS_t1w(1:1:end,3), 'DisplayName', "atlasCRS");
    scatter3(trkCRS(1,1:1:end),trkCRS(2,1:1:end),trkCRS(3,1:1:end), 'DisplayName', "trkCRS");
    savefig([pathToFile,'/tracts_aparc_ijk.fig']);
    saveas(gcf, [pathToFile,'/tracts_aparc_ijk.png']);
end
end
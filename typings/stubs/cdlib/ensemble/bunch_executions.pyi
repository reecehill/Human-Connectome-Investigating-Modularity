"""
This type stub file was generated by pyright.
"""

import networkx as nx
from typing import Callable

__all__ = ["BoolParameter", "CategoricalParameter", "Parameter", "grid_execution", "grid_search", "pool", "pool_grid_filter", "random_search"]
Parameter = ...
BoolParameter = ...
CategoricalParameter = ...
def grid_execution(graph: nx.Graph, method: Callable[[nx.Graph, dict], object], parameters: list) -> tuple:
    """
    Instantiate the specified community discovery method performing a grid search on the parameter set.

    :param method: community discovery method (from nclib.community)
    :param graph: networkx/igraph object
    :param parameters: list of Parameter and BoolParameter objects
    :return: at each call the generator yields a tuple composed by the current configuration and the obtained communities

    :Example:

    >>> import networkx as nx
    >>> from cdlib import algorithms, ensemble
    >>> g = nx.karate_club_graph()
    >>> resolution = ensemble.Parameter(name="resolution", start=0.1, end=1, step=0.1)
    >>> for communities in ensemble.grid_execution(graph=g, method=algorithms.louvain, parameters=[resolution]):
    >>>     print(communities)
    """
    ...

def grid_search(graph: nx.Graph, method: Callable[[nx.Graph, dict], object], parameters: list, quality_score: Callable[[nx.Graph, object], object], aggregate: Callable[[list], object] = ...) -> tuple:
    """
    Returns the optimal partition of the specified graph w.r.t. the selected algorithm and quality score.

    :param method: community discovery method (from nclib.community)
    :param graph: networkx/igraph object
    :param parameters: list of Parameter and BoolParameter objects
    :param quality_score: a fitness function to evaluate the obtained partition (from nclib.evaluation)
    :param aggregate: function to select the best fitness value. Possible values: min/max
    :return: at each call the generator yields a tuple composed by: the optimal configuration for the given algorithm, input paramters and fitness function; the obtained communities; the fitness score

    :Example:

    >>> import networkx as nx
    >>> from cdlib import algorithms, ensemble
    >>> g = nx.karate_club_graph()
    >>> resolution = ensemble.Parameter(name="resolution", start=0.1, end=1, step=0.1)
    >>> randomize = ensemble.BoolParameter(name="randomize")
    >>> communities, scoring = ensemble.grid_search(graph=g, method=algorithms.louvain,
    >>>                                                     parameters=[resolution, randomize],
    >>>                                                     quality_score=evaluation.erdos_renyi_modularity,
    >>>                                                     aggregate=max)
    >>> print(communities, scoring)
    """
    ...

def random_search(graph: nx.Graph, method: Callable[[nx.Graph, dict], object], parameters: list, quality_score: Callable[[nx.Graph, object], object], instances: int = ..., aggregate: Callable[[list], object] = ...) -> tuple:
    """
    Returns the optimal partition of the specified graph w.r.t. the selected algorithm and quality score over a randomized sample of the input parameters.

    :param method: community discovery method (from nclib.community)
    :param graph: networkx/igraph object
    :param parameters: list of Parameter and BoolParameter objects
    :param quality_score: a fitness function to evaluate the obtained partition (from nclib.evaluation)
    :param instances: number of randomly selected parameters configurations
    :param aggregate: function to select the best fitness value. Possible values: min/max

    :return: at each call the generator yields a tuple composed by: the optimal configuration for the given algorithm, input paramters and fitness function; the obtained communities; the fitness score

    :Example:

    >>> import networkx as nx
    >>> from cdlib import algorithms, ensemble
    >>> g = nx.karate_club_graph()
    >>> resolution = ensemble.Parameter(name="resolution", start=0.1, end=1, step=0.1)
    >>> randomize = ensemble.BoolParameter(name="randomize")
    >>> communities, scoring = ensemble.random_search(graph=g, method=algorithms.louvain,
    >>>                                                       parameters=[resolution, randomize],
    >>>                                                       quality_score=evaluation.erdos_renyi_modularity,
    >>>                                                       instances=5, aggregate=max)
    >>> print(communities, scoring)
    """
    ...

def pool(graph: nx.Graph, methods: Callable[[nx.Graph, dict], object], configurations: list) -> tuple:
    """
    Execute on a pool of community discovery internal on the input graph.

    :param methods: list community discovery methods (from nclib.community)
    :param graph: networkx/igraph object
    :param configurations: list of lists (one for each method) of Parameter and BoolParameter objects
    :return: at each call the generator yields a tuple composed by: the actual method, its current configuration and the obtained communities
    :raises ValueError: if the number of methods is different from the number of configurations specified

    :Example:

    >>> import networkx as nx
    >>> from cdlib import algorithms, ensemble
    >>> g = nx.karate_club_graph()
    >>> # Louvain
    >>> resolution = ensemble.Parameter(name="resolution", start=0.1, end=1, step=0.1)
    >>> randomize = ensemble.BoolParameter(name="randomize")
    >>> louvain_conf = [resolution, randomize]
    >>>
    >>> # Angel
    >>> threshold = ensemble.Parameter(name="threshold", start=0.1, end=1, step=0.1)
    >>> angel_conf = [threshold]
    >>>
    >>> methods = [algorithms.louvain, algorithms.angel]
    >>>
    >>> for communities in ensemble.pool(g, methods, [louvain_conf, angel_conf]):
    >>>     print(communities)
    """
    ...

def pool_grid_filter(graph: nx.Graph, methods: Callable[[nx.Graph, dict], object], configurations: list, quality_score: Callable[[nx.Graph, object], object], aggregate: Callable[[list], object] = ...) -> tuple:
    """
    Execute a pool of community discovery internal on the input graph.
    Returns the optimal partition for each algorithm given the specified quality function.

    :param methods: list community discovery methods (from nclib.community)
    :param graph: networkx/igraph object
    :param configurations: list of lists (one for each method) of Parameter and BoolParameter objects
    :param quality_score: a fitness function to evaluate the obtained partition (from nclib.evaluation)
    :param aggregate: function to select the best fitness value. Possible values: min/max
    :return: at each call the generator yields a tuple composed by: the actual method, its optimal configuration; the obtained communities; the fitness score.
    :raises ValueError: if the number of methods is different from the number of configurations specified

    :Example:

    >>> import networkx as nx
    >>> from cdlib import algorithms, ensemble
    >>> g = nx.karate_club_graph()
    >>> # Louvain
    >>> resolution = ensemble.Parameter(name="resolution", start=0.1, end=1, step=0.1)
    >>> randomize = ensemble.BoolParameter(name="randomize")
    >>> louvain_conf = [resolution, randomize]
    >>>
    >>> # Angel
    >>> threshold = ensemble.Parameter(name="threshold", start=0.1, end=1, step=0.1)
    >>> angel_conf = [threshold]
    >>>
    >>> methods = [algorithms.louvain, algorithms.angel]
    >>>
    >>> for communities, scoring in ensemble.pool_grid_filter(g, methods, [louvain_conf, angel_conf], quality_score=evaluation.erdos_renyi_modularity, aggregate=max):
    >>>     print(communities, scoring)

    """
    ...


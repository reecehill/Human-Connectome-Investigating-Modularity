"""
This type stub file was generated by pyright.
"""

from datalad.support.external_versions import external_versions
from datalad.utils import on_windows
from datalad import cfg
from datalad.config import anything2bool

"""Various handlers/functionality for different types of files (e.g. for archives)

"""
if noton_windows and (cfg.obtain('datalad.runtime.use-patool', default=False, valtype=anything2bool) or notexternal_versions['cmd:7z']):
    ...
else:
    ...
lgr = ...
def decompress_file(archive, dir_, leading_directories=...): # -> None:
    """Decompress `archive` into a directory `dir_`

    Parameters
    ----------
    archive: str
    dir_: str
    leading_directories: {'strip', None}
      If `strip`, and archive contains a single leading directory under which
      all content is stored, all the content will be moved one directory up
      and that leading directory will be removed.
    """
    ...

class ArchivesCache:
    """Cache to maintain extracted archives

    Parameters
    ----------
    toppath : str
      Top directory under .git/ of which temp directory would be created.
      If not provided -- random tempdir is used
    persistent : bool, optional
      Passed over into generated ExtractedArchives
    """
    def __init__(self, toppath=..., persistent=...) -> None:
        ...
    
    @property
    def path(self): # -> str:
        ...
    
    def clean(self, force=...): # -> None:
        ...
    
    def get_archive(self, archive):
        ...
    
    def __getitem__(self, archive):
        ...
    
    def __delitem__(self, archive): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    


class ExtractedArchive:
    """Container for the extracted archive
    """
    STAMP_SUFFIX = ...
    def __init__(self, archive, path=..., persistent=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def clean(self, force=...): # -> None:
        ...
    
    @property
    def path(self): # -> str:
        """Given an archive -- return full path to it within cache (extracted)
        """
        ...
    
    @property
    def stamp_path(self): # -> str:
        ...
    
    @property
    def is_extracted(self): # -> bool:
        ...
    
    def assure_extracted(self): # -> str:
        """Return path to the extracted `archive`.  Extract archive if necessary
        """
        ...
    
    def get_extracted_filename(self, afile): # -> str:
        """Return full path to the `afile` within extracted `archive`

        It does not actually extract any archive
        """
        ...
    
    def get_extracted_files(self): # -> Generator[Unknown | str, None, None]:
        """Generator to provide filenames which are available under extracted archive
        """
        ...
    
    def get_leading_directory(self, depth=..., consider=..., exclude=...): # -> str | None:
        """Return leading directory of the content within archive

        Parameters
        ----------
        depth: int or None, optional
          Maximal depth of leading directories to consider.  If None - no upper
          limit
        consider : list of str, optional
          Regular expressions for file/directory names to be considered (before
          exclude). Applied to the entire relative path to the file as in the archive
        exclude: list of str, optional
          Regular expressions for file/directory names to be excluded from consideration.
          Applied to the entire relative path to the file as in the archive

        Returns
        -------
        str or None:
          If there is no single leading directory -- None returned
        """
        ...
    
    def get_extracted_file(self, afile): # -> str:
        ...
    
    def __del__(self): # -> None:
        ...
    



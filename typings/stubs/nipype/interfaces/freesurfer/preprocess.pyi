"""
This type stub file was generated by pyright.
"""

from ... import LooseVersion
from ..io import FreeSurferSource
from ..base import CommandLine, CommandLineInputSpec, File, InputMultiPath, OutputMultiPath, TraitedSpec, traits
from .base import FSCommand, FSCommandOpenMP, FSTraitedSpec, FSTraitedSpecOpenMP, Info

"""Provides interfaces to various commands provided by FreeSurfer
"""
__docformat__ = ...
iflogger = ...
FSVersion = ...
class ParseDICOMDirInputSpec(FSTraitedSpec):
    dicom_dir = ...
    dicom_info_file = ...
    sortbyrun = ...
    summarize = ...


class ParseDICOMDirOutputSpec(TraitedSpec):
    dicom_info_file = ...


class ParseDICOMDir(FSCommand):
    """Uses mri_parse_sdcmdir to get information from dicom directories

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import ParseDICOMDir
    >>> dcminfo = ParseDICOMDir()
    >>> dcminfo.inputs.dicom_dir = '.'
    >>> dcminfo.inputs.sortbyrun = True
    >>> dcminfo.inputs.summarize = True
    >>> dcminfo.cmdline
    'mri_parse_sdcmdir --d . --o dicominfo.txt --sortbyrun --summarize'

    """
    _cmd = ...
    input_spec = ParseDICOMDirInputSpec
    output_spec = ParseDICOMDirOutputSpec


class UnpackSDICOMDirInputSpec(FSTraitedSpec):
    source_dir = ...
    output_dir = ...
    run_info = ...
    config = ...
    seq_config = ...
    dir_structure = ...
    no_info_dump = ...
    scan_only = ...
    log_file = ...
    spm_zeropad = ...
    no_unpack_err = ...


class UnpackSDICOMDir(FSCommand):
    """Use unpacksdcmdir to convert dicom files

    Call unpacksdcmdir -help from the command line to see more information on
    using this command.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import UnpackSDICOMDir
    >>> unpack = UnpackSDICOMDir()
    >>> unpack.inputs.source_dir = '.'
    >>> unpack.inputs.output_dir = '.'
    >>> unpack.inputs.run_info = (5, 'mprage', 'nii', 'struct')
    >>> unpack.inputs.dir_structure = 'generic'
    >>> unpack.cmdline
    'unpacksdcmdir -generic -targ . -run 5 mprage nii struct -src .'
    """
    _cmd = ...
    input_spec = UnpackSDICOMDirInputSpec


class MRIConvertInputSpec(FSTraitedSpec):
    read_only = ...
    no_write = ...
    in_info = ...
    out_info = ...
    in_stats = ...
    out_stats = ...
    in_matrix = ...
    out_matrix = ...
    in_i_size = ...
    in_j_size = ...
    in_k_size = ...
    force_ras = ...
    in_i_dir = ...
    in_j_dir = ...
    in_k_dir = ...
    _orientations = ...
    in_orientation = ...
    in_center = ...
    sphinx = ...
    out_i_count = ...
    out_j_count = ...
    out_k_count = ...
    vox_size = ...
    out_i_size = ...
    out_j_size = ...
    out_k_size = ...
    out_i_dir = ...
    out_j_dir = ...
    out_k_dir = ...
    out_orientation = ...
    out_center = ...
    out_datatype = ...
    resample_type = ...
    no_scale = ...
    no_change = ...
    tr = ...
    te = ...
    ti = ...
    autoalign_matrix = ...
    unwarp_gradient = ...
    apply_transform = ...
    apply_inv_transform = ...
    devolve_transform = ...
    crop_center = ...
    crop_size = ...
    cut_ends = ...
    slice_crop = ...
    slice_reverse = ...
    slice_bias = ...
    fwhm = ...
    _filetypes = ...
    _infiletypes = ...
    in_type = ...
    out_type = ...
    ascii = ...
    reorder = ...
    invert_contrast = ...
    in_file = ...
    out_file = ...
    conform = ...
    conform_min = ...
    conform_size = ...
    cw256 = ...
    parse_only = ...
    subject_name = ...
    reslice_like = ...
    template_type = ...
    split = ...
    frame = ...
    midframe = ...
    skip_n = ...
    drop_n = ...
    frame_subsample = ...
    in_scale = ...
    out_scale = ...
    in_like = ...
    fill_parcellation = ...
    smooth_parcellation = ...
    zero_outlines = ...
    color_file = ...
    no_translate = ...
    status_file = ...
    sdcm_list = ...
    template_info = ...
    crop_gdf = ...
    zero_ge_z_offset = ...


class MRIConvertOutputSpec(TraitedSpec):
    out_file = OutputMultiPath(File(exists=True), desc="converted output file")


class MRIConvert(FSCommand):
    """use fs mri_convert to manipulate files

    .. note::
       Adds niigz as an output type option

    Examples
    --------

    >>> mc = MRIConvert()
    >>> mc.inputs.in_file = 'structural.nii'
    >>> mc.inputs.out_file = 'outfile.mgz'
    >>> mc.inputs.out_type = 'mgz'
    >>> mc.cmdline
    'mri_convert --out_type mgz --input_volume structural.nii --output_volume outfile.mgz'

    """
    _cmd = ...
    input_spec = MRIConvertInputSpec
    output_spec = MRIConvertOutputSpec
    filemap = ...


class DICOMConvertInputSpec(FSTraitedSpec):
    dicom_dir = ...
    base_output_dir = ...
    subject_dir_template = ...
    subject_id = ...
    file_mapping = ...
    out_type = ...
    dicom_info = ...
    seq_list = ...
    ignore_single_slice = ...


class DICOMConvert(FSCommand):
    """use fs mri_convert to convert dicom files

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import DICOMConvert
    >>> cvt = DICOMConvert()
    >>> cvt.inputs.dicom_dir = 'dicomdir'
    >>> cvt.inputs.file_mapping = [('nifti', '*.nii'), ('info', 'dicom*.txt'), ('dti', '*dti.bv*')]

    """
    _cmd = ...
    input_spec = DICOMConvertInputSpec
    @property
    def cmdline(self): # -> LiteralString:
        """`command` plus any arguments (args)
        validates arguments and generates command line"""
        ...
    


class ResampleInputSpec(FSTraitedSpec):
    in_file = ...
    resampled_file = ...
    voxel_size = ...


class ResampleOutputSpec(TraitedSpec):
    resampled_file = ...


class Resample(FSCommand):
    """Use FreeSurfer mri_convert to up or down-sample image files

    Examples
    --------

    >>> from nipype.interfaces import freesurfer
    >>> resampler = freesurfer.Resample()
    >>> resampler.inputs.in_file = 'structural.nii'
    >>> resampler.inputs.resampled_file = 'resampled.nii'
    >>> resampler.inputs.voxel_size = (2.1, 2.1, 2.1)
    >>> resampler.cmdline
    'mri_convert -vs 2.10 2.10 2.10 -i structural.nii -o resampled.nii'

    """
    _cmd = ...
    input_spec = ResampleInputSpec
    output_spec = ResampleOutputSpec


class ReconAllInputSpec(CommandLineInputSpec):
    subject_id = ...
    directive = ...
    hemi = ...
    T1_files = InputMultiPath(File(exists=True), argstr="-i %s...", desc="name of T1 file to process")
    T2_file = ...
    FLAIR_file = ...
    use_T2 = ...
    use_FLAIR = ...
    openmp = ...
    parallel = ...
    hires = ...
    mprage = ...
    big_ventricles = ...
    brainstem = ...
    hippocampal_subfields_T1 = ...
    hippocampal_subfields_T2 = ...
    expert = ...
    xopts = ...
    subjects_dir = ...
    flags = InputMultiPath(traits.Str, argstr="%s", desc="additional parameters")
    talairach = ...
    mri_normalize = ...
    mri_watershed = ...
    mri_em_register = ...
    mri_ca_normalize = ...
    mri_ca_register = ...
    mri_remove_neck = ...
    mri_ca_label = ...
    mri_segstats = ...
    mri_mask = ...
    mri_segment = ...
    mri_edit_wm_with_aseg = ...
    mri_pretess = ...
    mri_fill = ...
    mri_tessellate = ...
    mris_smooth = ...
    mris_inflate = ...
    mris_sphere = ...
    mris_fix_topology = ...
    mris_make_surfaces = ...
    mris_surf2vol = ...
    mris_register = ...
    mrisp_paint = ...
    mris_ca_label = ...
    mris_anatomical_stats = ...
    mri_aparc2aseg = ...


class ReconAllOutputSpec(FreeSurferSource.output_spec):
    subjects_dir = ...
    subject_id = ...


class ReconAll(CommandLine):
    """Uses recon-all to generate surfaces and parcellations of structural data
    from anatomical images of a subject.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import ReconAll
    >>> reconall = ReconAll()
    >>> reconall.inputs.subject_id = 'foo'
    >>> reconall.inputs.directive = 'all'
    >>> reconall.inputs.subjects_dir = '.'
    >>> reconall.inputs.T1_files = 'structural.nii'
    >>> reconall.cmdline
    'recon-all -all -i structural.nii -subjid foo -sd .'
    >>> reconall.inputs.flags = "-qcache"
    >>> reconall.cmdline
    'recon-all -all -i structural.nii -qcache -subjid foo -sd .'
    >>> reconall.inputs.flags = ["-cw256", "-qcache"]
    >>> reconall.cmdline
    'recon-all -all -i structural.nii -cw256 -qcache -subjid foo -sd .'

    Hemisphere may be specified regardless of directive:

    >>> reconall.inputs.flags = []
    >>> reconall.inputs.hemi = 'lh'
    >>> reconall.cmdline
    'recon-all -all -i structural.nii -hemi lh -subjid foo -sd .'

    ``-autorecon-hemi`` uses the ``-hemi`` input to specify the hemisphere
    to operate upon:

    >>> reconall.inputs.directive = 'autorecon-hemi'
    >>> reconall.cmdline
    'recon-all -autorecon-hemi lh -i structural.nii -subjid foo -sd .'

    Hippocampal subfields can accept T1 and T2 images:

    >>> reconall_subfields = ReconAll()
    >>> reconall_subfields.inputs.subject_id = 'foo'
    >>> reconall_subfields.inputs.directive = 'all'
    >>> reconall_subfields.inputs.subjects_dir = '.'
    >>> reconall_subfields.inputs.T1_files = 'structural.nii'
    >>> reconall_subfields.inputs.hippocampal_subfields_T1 = True
    >>> reconall_subfields.cmdline
    'recon-all -all -i structural.nii -hippocampal-subfields-T1 -subjid foo -sd .'
    >>> reconall_subfields.inputs.hippocampal_subfields_T2 = (
    ... 'structural.nii', 'test')
    >>> reconall_subfields.cmdline
    'recon-all -all -i structural.nii -hippocampal-subfields-T1T2 structural.nii test -subjid foo -sd .'
    >>> reconall_subfields.inputs.hippocampal_subfields_T1 = False
    >>> reconall_subfields.cmdline
    'recon-all -all -i structural.nii -hippocampal-subfields-T2 structural.nii test -subjid foo -sd .'
    """
    _cmd = ...
    _additional_metadata = ...
    input_spec = ReconAllInputSpec
    output_spec = ReconAllOutputSpec
    _can_resume = ...
    force_run = ...
    _autorecon1_steps = ...
    if Info.looseversion() < LooseVersion("6.0.0"):
        _autorecon2_volonly_steps = ...
        _autorecon2_lh_steps = ...
        _autorecon3_lh_steps = ...
        _autorecon3_added_steps = ...
    else:
        _autorecon2_volonly_steps = ...
        _autorecon2_lh_steps = ...
        _autorecon3_lh_steps = ...
        _autorecon3_added_steps = ...
        _autorecon2_volonly_steps = ...
        _autorecon2_lh_steps = ...
        _autorecon3_lh_steps = ...
        _autorecon3_added_steps = ...
    _autorecon2_rh_steps = ...
    _autorecon2_perhemi_steps = ...
    _autorecon2_steps = ...
    _autorecon3_rh_steps = ...
    _autorecon3_perhemi_steps = ...
    _autorecon3_steps = ...
    _autorecon_lh_steps = ...
    _autorecon_rh_steps = ...
    _steps = ...
    _binaries = ...
    @property
    def cmdline(self): # -> str:
        ...
    
    @property
    def version(self): # -> str | None:
        ...
    


class BBRegisterInputSpec(FSTraitedSpec):
    subject_id = ...
    source_file = ...
    init = ...
    init_reg_file = ...
    contrast_type = ...
    intermediate_file = ...
    reg_frame = ...
    reg_middle_frame = ...
    out_reg_file = ...
    spm_nifti = ...
    epi_mask = ...
    dof = ...
    fsldof = ...
    out_fsl_file = ...
    out_lta_file = ...
    registered_file = ...
    init_cost_file = ...


class BBRegisterInputSpec6(BBRegisterInputSpec):
    init = ...
    init_reg_file = ...


class BBRegisterOutputSpec(TraitedSpec):
    out_reg_file = ...
    out_fsl_file = ...
    out_lta_file = ...
    min_cost_file = ...
    init_cost_file = ...
    registered_file = ...


class BBRegister(FSCommand):
    """Use FreeSurfer bbregister to register a volume to the Freesurfer anatomical.

    This program performs within-subject, cross-modal registration using a
    boundary-based cost function. It is required that you have an anatomical
    scan of the subject that has already been recon-all-ed using freesurfer.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import BBRegister
    >>> bbreg = BBRegister(subject_id='me', source_file='structural.nii', init='header', contrast_type='t2')
    >>> bbreg.cmdline
    'bbregister --t2 --init-header --reg structural_bbreg_me.dat --mov structural.nii --s me'

    """
    _cmd = ...
    if LooseVersion("0.0.0") < Info.looseversion() < LooseVersion("6.0.0"):
        input_spec = ...
    else:
        input_spec = ...
    output_spec = BBRegisterOutputSpec


class ApplyVolTransformInputSpec(FSTraitedSpec):
    source_file = ...
    transformed_file = ...
    _targ_xor = ...
    target_file = ...
    tal = ...
    tal_resolution = ...
    fs_target = ...
    _reg_xor = ...
    reg_file = ...
    lta_file = ...
    lta_inv_file = ...
    reg_file = ...
    fsl_reg_file = ...
    xfm_reg_file = ...
    reg_header = ...
    mni_152_reg = ...
    subject = ...
    inverse = ...
    interp = ...
    no_resample = ...
    m3z_file = ...
    no_ded_m3z_path = ...
    invert_morph = ...


class ApplyVolTransformOutputSpec(TraitedSpec):
    transformed_file = ...


class ApplyVolTransform(FSCommand):
    """Use FreeSurfer mri_vol2vol to apply a transform.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import ApplyVolTransform
    >>> applyreg = ApplyVolTransform()
    >>> applyreg.inputs.source_file = 'structural.nii'
    >>> applyreg.inputs.reg_file = 'register.dat'
    >>> applyreg.inputs.transformed_file = 'struct_warped.nii'
    >>> applyreg.inputs.fs_target = True
    >>> applyreg.cmdline
    'mri_vol2vol --fstarg --reg register.dat --mov structural.nii --o struct_warped.nii'

    """
    _cmd = ...
    input_spec = ApplyVolTransformInputSpec
    output_spec = ApplyVolTransformOutputSpec


class SmoothInputSpec(FSTraitedSpec):
    in_file = ...
    reg_file = ...
    smoothed_file = ...
    proj_frac_avg = ...
    proj_frac = ...
    surface_fwhm = ...
    num_iters = ...
    vol_fwhm = ...


class SmoothOutputSpec(TraitedSpec):
    smoothed_file = ...


class Smooth(FSCommand):
    """Use FreeSurfer mris_volsmooth to smooth a volume

    This function smoothes cortical regions on a surface and non-cortical
    regions in volume.

    .. note::
       Cortical voxels are mapped to the surface (3D->2D) and then the
       smoothed values from the surface are put back into the volume to fill
       the cortical ribbon. If data is smoothed with this algorithm, one has to
       be careful about how further processing is interpreted.

    Examples
    --------

    >>> from nipype.interfaces.freesurfer import Smooth
    >>> smoothvol = Smooth(in_file='functional.nii', smoothed_file = 'foo_out.nii', reg_file='register.dat', surface_fwhm=10, vol_fwhm=6)
    >>> smoothvol.cmdline
    'mris_volsmooth --i functional.nii --reg register.dat --o foo_out.nii --fwhm 10.000000 --vol-fwhm 6.000000'

    """
    _cmd = ...
    input_spec = SmoothInputSpec
    output_spec = SmoothOutputSpec


class RobustRegisterInputSpec(FSTraitedSpec):
    source_file = ...
    target_file = ...
    out_reg_file = ...
    registered_file = ...
    weights_file = ...
    est_int_scale = ...
    trans_only = ...
    in_xfm_file = ...
    half_source = ...
    half_targ = ...
    half_weights = ...
    half_source_xfm = ...
    half_targ_xfm = ...
    auto_sens = ...
    outlier_sens = ...
    least_squares = ...
    no_init = ...
    init_orient = ...
    max_iterations = ...
    high_iterations = ...
    iteration_thresh = ...
    subsample_thresh = ...
    outlier_limit = ...
    write_vo2vox = ...
    no_multi = ...
    mask_source = ...
    mask_target = ...
    force_double = ...
    force_float = ...


class RobustRegisterOutputSpec(TraitedSpec):
    out_reg_file = ...
    registered_file = ...
    weights_file = ...
    half_source = ...
    half_targ = ...
    half_weights = ...
    half_source_xfm = ...
    half_targ_xfm = ...


class RobustRegister(FSCommand):
    """Perform intramodal linear registration (translation and rotation) using
    robust statistics.

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import RobustRegister
    >>> reg = RobustRegister()
    >>> reg.inputs.source_file = 'structural.nii'
    >>> reg.inputs.target_file = 'T1.nii'
    >>> reg.inputs.auto_sens = True
    >>> reg.inputs.init_orient = True
    >>> reg.cmdline # doctest: +ELLIPSIS
    'mri_robust_register --satit --initorient --lta .../structural_robustreg.lta --mov structural.nii --dst T1.nii'

    References
    ----------
    Reuter, M, Rosas, HD, and Fischl, B, (2010). Highly Accurate Inverse
        Consistent Registration: A Robust Approach.  Neuroimage 53(4) 1181-96.

    """
    _cmd = ...
    input_spec = RobustRegisterInputSpec
    output_spec = RobustRegisterOutputSpec


class FitMSParamsInputSpec(FSTraitedSpec):
    in_files = ...
    tr_list = ...
    te_list = ...
    flip_list = ...
    xfm_list = ...
    out_dir = ...


class FitMSParamsOutputSpec(TraitedSpec):
    t1_image = ...
    pd_image = ...
    t2star_image = ...


class FitMSParams(FSCommand):
    """Estimate tissue parameters from a set of FLASH images.

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import FitMSParams
    >>> msfit = FitMSParams()
    >>> msfit.inputs.in_files = ['flash_05.mgz', 'flash_30.mgz']
    >>> msfit.inputs.out_dir = 'flash_parameters'
    >>> msfit.cmdline
    'mri_ms_fitparms  flash_05.mgz flash_30.mgz flash_parameters'

    """
    _cmd = ...
    input_spec = FitMSParamsInputSpec
    output_spec = FitMSParamsOutputSpec


class SynthesizeFLASHInputSpec(FSTraitedSpec):
    fixed_weighting = ...
    tr = ...
    flip_angle = ...
    te = ...
    t1_image = ...
    pd_image = ...
    out_file = ...


class SynthesizeFLASHOutputSpec(TraitedSpec):
    out_file = ...


class SynthesizeFLASH(FSCommand):
    """Synthesize a FLASH acquisition from T1 and proton density maps.

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import SynthesizeFLASH
    >>> syn = SynthesizeFLASH(tr=20, te=3, flip_angle=30)
    >>> syn.inputs.t1_image = 'T1.mgz'
    >>> syn.inputs.pd_image = 'PD.mgz'
    >>> syn.inputs.out_file = 'flash_30syn.mgz'
    >>> syn.cmdline
    'mri_synthesize 20.00 30.00 3.000 T1.mgz PD.mgz flash_30syn.mgz'

    """
    _cmd = ...
    input_spec = SynthesizeFLASHInputSpec
    output_spec = SynthesizeFLASHOutputSpec


class MNIBiasCorrectionInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    iterations = ...
    protocol_iterations = ...
    distance = ...
    no_rescale = ...
    mask = ...
    transform = ...
    stop = ...
    shrink = ...


class MNIBiasCorrectionOutputSpec(TraitedSpec):
    out_file = ...


class MNIBiasCorrection(FSCommand):
    """Wrapper for nu_correct, a program from the Montreal Neurological Insitute (MNI)
    used for correcting intensity non-uniformity (ie, bias fields). You must have the
    MNI software installed on your system to run this. See [www.bic.mni.mcgill.ca/software/N3]
    for more info.

    mri_nu_correct.mni uses float internally instead of uchar. It also rescales the output so
    that the global mean is the same as that of the input. These two changes are linked and
    can be turned off with --no-float

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import MNIBiasCorrection
    >>> correct = MNIBiasCorrection()
    >>> correct.inputs.in_file = "norm.mgz"
    >>> correct.inputs.iterations = 6
    >>> correct.inputs.protocol_iterations = 1000
    >>> correct.inputs.distance = 50
    >>> correct.cmdline
    'mri_nu_correct.mni --distance 50 --i norm.mgz --n 6 --o norm_output.mgz --proto-iters 1000'

    References
    ----------
    [http://freesurfer.net/fswiki/mri_nu_correct.mni]
    [http://www.bic.mni.mcgill.ca/software/N3]
    [https://github.com/BIC-MNI/N3]

    """
    _cmd = ...
    input_spec = MNIBiasCorrectionInputSpec
    output_spec = MNIBiasCorrectionOutputSpec


class WatershedSkullStripInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    t1 = ...
    brain_atlas = ...
    transform = ...


class WatershedSkullStripOutputSpec(TraitedSpec):
    out_file = ...


class WatershedSkullStrip(FSCommand):
    """This program strips skull and other outer non-brain tissue and
    produces the brain volume from T1 volume or the scanned volume.

    The "watershed" segmentation algorithm was used to determine the
    intensity values for white matter, grey matter, and CSF.
    A force field was then used to fit a spherical surface to the brain.
    The shape of the surface fit was then evaluated against a previously
    derived template.

    The default parameters are: -w 0.82 -b 0.32 -h 10 -seedpt -ta -wta

    (Segonne 2004)

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import WatershedSkullStrip
    >>> skullstrip = WatershedSkullStrip()
    >>> skullstrip.inputs.in_file = "T1.mgz"
    >>> skullstrip.inputs.t1 = True
    >>> skullstrip.inputs.transform = "transforms/talairach_with_skull.lta"
    >>> skullstrip.inputs.out_file = "brainmask.auto.mgz"
    >>> skullstrip.cmdline
    'mri_watershed -T1 transforms/talairach_with_skull.lta T1.mgz brainmask.auto.mgz'
    """
    _cmd = ...
    input_spec = WatershedSkullStripInputSpec
    output_spec = WatershedSkullStripOutputSpec


class NormalizeInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    gradient = ...
    mask = ...
    segmentation = ...
    transform = ...


class NormalizeOutputSpec(TraitedSpec):
    out_file = ...


class Normalize(FSCommand):
    """
    Normalize the white-matter, optionally based on control points. The
    input volume is converted into a new volume where white matter image
    values all range around 110.

    Examples
    ========
    >>> from nipype.interfaces import freesurfer
    >>> normalize = freesurfer.Normalize()
    >>> normalize.inputs.in_file = "T1.mgz"
    >>> normalize.inputs.gradient = 1
    >>> normalize.cmdline
    'mri_normalize -g 1 T1.mgz T1_norm.mgz'
    """
    _cmd = ...
    input_spec = NormalizeInputSpec
    output_spec = NormalizeOutputSpec


class CANormalizeInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...
    atlas = ...
    transform = ...
    mask = ...
    control_points = ...
    long_file = ...


class CANormalizeOutputSpec(TraitedSpec):
    out_file = ...
    control_points = ...


class CANormalize(FSCommand):
    """This program creates a normalized volume using the brain volume and an
    input gca file.

    See Also
    --------
    For complete details, see the `FS Documentation
    <http://surfer.nmr.mgh.harvard.edu/fswiki/mri_ca_normalize>`__.

    Examples
    --------
    >>> from nipype.interfaces import freesurfer
    >>> ca_normalize = freesurfer.CANormalize()
    >>> ca_normalize.inputs.in_file = "T1.mgz"
    >>> ca_normalize.inputs.atlas = "atlas.nii.gz" # in practice use .gca atlases
    >>> ca_normalize.inputs.transform = "trans.mat" # in practice use .lta transforms
    >>> ca_normalize.cmdline
    'mri_ca_normalize T1.mgz atlas.nii.gz trans.mat T1_norm.mgz'

    """
    _cmd = ...
    input_spec = CANormalizeInputSpec
    output_spec = CANormalizeOutputSpec


class CARegisterInputSpec(FSTraitedSpecOpenMP):
    in_file = ...
    out_file = ...
    template = ...
    mask = ...
    invert_and_save = ...
    no_big_ventricles = ...
    transform = ...
    align = ...
    levels = ...
    A = ...
    l_files = InputMultiPath(File(exists=False), argstr="-l %s", desc="undocumented flag used in longitudinal processing")


class CARegisterOutputSpec(TraitedSpec):
    out_file = ...


class CARegister(FSCommandOpenMP):
    """Generates a multi-dimensional talairach transform from a gca file and talairach.lta file

    See Also
    --------
    For complete details, see the `FS Documentation
    <http://surfer.nmr.mgh.harvard.edu/fswiki/mri_ca_register>`__

    Examples
    --------
    >>> from nipype.interfaces import freesurfer
    >>> ca_register = freesurfer.CARegister()
    >>> ca_register.inputs.in_file = "norm.mgz"
    >>> ca_register.inputs.out_file = "talairach.m3z"
    >>> ca_register.cmdline
    'mri_ca_register norm.mgz talairach.m3z'

    """
    _cmd = ...
    input_spec = CARegisterInputSpec
    output_spec = CARegisterOutputSpec


class CALabelInputSpec(FSTraitedSpecOpenMP):
    in_file = ...
    out_file = ...
    transform = ...
    template = ...
    in_vol = ...
    intensities = ...
    no_big_ventricles = ...
    align = ...
    prior = ...
    relabel_unlikely = ...
    label = ...
    aseg = ...


class CALabelOutputSpec(TraitedSpec):
    out_file = ...


class CALabel(FSCommandOpenMP):
    """Label subcortical structures based in GCA model.

    See Also
    --------
    For complete details, see the `FS Documentation
    <http://surfer.nmr.mgh.harvard.edu/fswiki/mri_ca_label>`__

    Examples
    --------
    >>> from nipype.interfaces import freesurfer
    >>> ca_label = freesurfer.CALabel()
    >>> ca_label.inputs.in_file = "norm.mgz"
    >>> ca_label.inputs.out_file = "out.mgz"
    >>> ca_label.inputs.transform = "trans.mat"
    >>> ca_label.inputs.template = "Template_6.nii" # in practice use .gcs extension
    >>> ca_label.cmdline
    'mri_ca_label norm.mgz trans.mat Template_6.nii out.mgz'

    """
    _cmd = ...
    input_spec = CALabelInputSpec
    output_spec = CALabelOutputSpec


class MRIsCALabelInputSpec(FSTraitedSpecOpenMP):
    subject_id = ...
    hemisphere = ...
    canonsurf = ...
    classifier = ...
    smoothwm = ...
    curv = ...
    sulc = ...
    out_file = ...
    label = ...
    aseg = ...
    seed = ...
    copy_inputs = ...


class MRIsCALabelOutputSpec(TraitedSpec):
    out_file = ...


class MRIsCALabel(FSCommandOpenMP):
    """
    For a single subject, produces an annotation file, in which each
    cortical surface vertex is assigned a neuroanatomical label.This
    automatic procedure employs data from a previously-prepared atlas
    file. An atlas file is created from a training set, capturing region
    data manually drawn by neuroanatomists combined with statistics on
    variability correlated to geometric information derived from the
    cortical model (sulcus and curvature). Besides the atlases provided
    with FreeSurfer, new ones can be prepared using mris_ca_train).

    Examples
    ========

    >>> from nipype.interfaces import freesurfer
    >>> ca_label = freesurfer.MRIsCALabel()
    >>> ca_label.inputs.subject_id = "test"
    >>> ca_label.inputs.hemisphere = "lh"
    >>> ca_label.inputs.canonsurf = "lh.pial"
    >>> ca_label.inputs.curv = "lh.pial"
    >>> ca_label.inputs.sulc = "lh.pial"
    >>> ca_label.inputs.classifier = "im1.nii" # in pracice, use .gcs extension
    >>> ca_label.inputs.smoothwm = "lh.pial"
    >>> ca_label.cmdline
    'mris_ca_label test lh lh.pial im1.nii lh.aparc.annot'
    """
    _cmd = ...
    input_spec = MRIsCALabelInputSpec
    output_spec = MRIsCALabelOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    


class SegmentCCInputSpec(FSTraitedSpec):
    in_file = ...
    in_norm = ...
    out_file = ...
    out_rotation = ...
    subject_id = ...
    copy_inputs = ...


class SegmentCCOutputSpec(TraitedSpec):
    out_file = ...
    out_rotation = ...


class SegmentCC(FSCommand):
    """
    This program segments the corpus callosum into five separate labels in
    the subcortical segmentation volume 'aseg.mgz'. The divisions of the
    cc are equally spaced in terms of distance along the primary
    eigendirection (pretty much the long axis) of the cc. The lateral
    extent can be changed with the -T <thickness> parameter, where
    <thickness> is the distance off the midline (so -T 1 would result in
    the who CC being 3mm thick). The default is 2 so it's 5mm thick. The
    aseg.stats values should be volume.

    Examples
    ========
    >>> from nipype.interfaces import freesurfer
    >>> SegmentCC_node = freesurfer.SegmentCC()
    >>> SegmentCC_node.inputs.in_file = "aseg.mgz"
    >>> SegmentCC_node.inputs.in_norm = "norm.mgz"
    >>> SegmentCC_node.inputs.out_rotation = "cc.lta"
    >>> SegmentCC_node.inputs.subject_id = "test"
    >>> SegmentCC_node.cmdline
    'mri_cc -aseg aseg.mgz -o aseg.auto.mgz -lta cc.lta test'
    """
    _cmd = ...
    input_spec = SegmentCCInputSpec
    output_spec = SegmentCCOutputSpec
    def run(self, **inputs): # -> InterfaceResult:
        ...
    
    def aggregate_outputs(self, runtime=..., needed_outputs=...): # -> None:
        ...
    


class SegmentWMInputSpec(FSTraitedSpec):
    in_file = ...
    out_file = ...


class SegmentWMOutputSpec(TraitedSpec):
    out_file = ...


class SegmentWM(FSCommand):
    """
    This program segments white matter from the input volume.  The input
    volume should be normalized such that white matter voxels are
    ~110-valued, and the volume is conformed to 256^3.


    Examples
    ========
    >>> from nipype.interfaces import freesurfer
    >>> SegmentWM_node = freesurfer.SegmentWM()
    >>> SegmentWM_node.inputs.in_file = "norm.mgz"
    >>> SegmentWM_node.inputs.out_file = "wm.seg.mgz"
    >>> SegmentWM_node.cmdline
    'mri_segment norm.mgz wm.seg.mgz'
    """
    _cmd = ...
    input_spec = SegmentWMInputSpec
    output_spec = SegmentWMOutputSpec


class EditWMwithAsegInputSpec(FSTraitedSpec):
    in_file = ...
    brain_file = ...
    seg_file = ...
    out_file = ...
    keep_in = ...


class EditWMwithAsegOutputSpec(TraitedSpec):
    out_file = ...


class EditWMwithAseg(FSCommand):
    """
    Edits a wm file using a segmentation

    Examples
    ========
    >>> from nipype.interfaces.freesurfer import EditWMwithAseg
    >>> editwm = EditWMwithAseg()
    >>> editwm.inputs.in_file = "T1.mgz"
    >>> editwm.inputs.brain_file = "norm.mgz"
    >>> editwm.inputs.seg_file = "aseg.mgz"
    >>> editwm.inputs.out_file = "wm.asegedit.mgz"
    >>> editwm.inputs.keep_in = True
    >>> editwm.cmdline
    'mri_edit_wm_with_aseg -keep-in T1.mgz norm.mgz aseg.mgz wm.asegedit.mgz'
    """
    _cmd = ...
    input_spec = EditWMwithAsegInputSpec
    output_spec = EditWMwithAsegOutputSpec


class ConcatenateLTAInputSpec(FSTraitedSpec):
    in_lta1 = ...
    in_lta2 = ...
    out_file = ...
    invert_1 = ...
    invert_2 = ...
    invert_out = ...
    out_type = ...
    tal_source_file = ...
    tal_template_file = ...
    subject = ...


class ConcatenateLTAOutputSpec(TraitedSpec):
    out_file = ...


class ConcatenateLTA(FSCommand):
    """Concatenates two consecutive LTA transformations into one overall
    transformation

    Out = LTA2*LTA1

    Examples
    --------
    >>> from nipype.interfaces.freesurfer import ConcatenateLTA
    >>> conc_lta = ConcatenateLTA()
    >>> conc_lta.inputs.in_lta1 = 'lta1.lta'
    >>> conc_lta.inputs.in_lta2 = 'lta2.lta'
    >>> conc_lta.cmdline
    'mri_concatenate_lta lta1.lta lta2.lta lta1_concat.lta'

    You can use 'identity.nofile' as the filename for in_lta2, e.g.:

    >>> conc_lta.inputs.in_lta2 = 'identity.nofile'
    >>> conc_lta.inputs.invert_1 = True
    >>> conc_lta.inputs.out_file = 'inv1.lta'
    >>> conc_lta.cmdline
    'mri_concatenate_lta -invert1 lta1.lta identity.nofile inv1.lta'

    To create a RAS2RAS transform:

    >>> conc_lta.inputs.out_type = 'RAS2RAS'
    >>> conc_lta.cmdline
    'mri_concatenate_lta -invert1 -out_type 1 lta1.lta identity.nofile inv1.lta'
    """
    _cmd = ...
    input_spec = ConcatenateLTAInputSpec
    output_spec = ConcatenateLTAOutputSpec



"""
This type stub file was generated by pyright.
"""

import logging
from contextlib import contextmanager
from .utils import optional_args

"""Logging setup and utilities, including progress reporting"""
__all__ = ['ColorFormatter', 'LoggerHelper', 'filter_noninteractive_progress', 'log_progress', 'with_progress', 'with_result_progress']
def mbasename(s):
    """Returns an expanded basename, if the filename is deemed not informative

    A '.py' extension is stripped from file name, and the containing directory
    is prepended for too generic file names  like 'base', '__init__', and 'utils'

    Parameters
    ----------
    s: str
      Platform-native path

    Returns
    -------
    str
    """
    ...

class TraceBack:
    """Customizable traceback for inclusion debug log messages
    """
    def __init__(self, limit=..., collide=...) -> None:
        """
        Parameters
        ----------
        collide : bool
          if True, deduplicate a subsequent message by replacing a common
          prefix string with an ellipsis.
        """
        ...
    
    def __call__(self): # -> str | LiteralString:
        ...
    


class MemoryInfo:
    def __init__(self) -> None:
        ...
    
    def __call__(self): # -> LiteralString | str:
        """Return utilization of virtual memory

        Generic implementation using psutil
        """
        ...
    


class ColorFormatter(logging.Formatter):
    def __init__(self, use_color=..., log_name=..., log_pid=...) -> None:
        ...
    
    def format(self, record): # -> Any | str:
        ...
    


class ProgressHandler(logging.Handler):
    def __init__(self, other_handler=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def emit(self, record): # -> None:
        ...
    


def filter_noninteractive_progress(logger, record): # -> Literal[True]:
    """Companion of log_progress() to suppress undesired progress logging

    This filter is to be used with a log handler's addFilter() method
    for the case of a non-interactive session (e.g., pipe to log file).

    It inspects the log record for `dlm_progress_noninteractive_level`
    keys that can be injected via log_progress(noninteractive_level=).

    If a log-level was declared in this fashion, it will be evaluated
    against the logger's effective level, and records are discarded
    if their level is too low. If no log-level was declared, a log record
    passes this filter unconditionally.

    Parameters
    ----------
    logger: logging.Logger
      The logger instance whose effective level to check against.
    record:
      The log record to inspect.

    Returns
    -------
    bool
    """
    ...

def log_progress(lgrcall, pid, *args, **kwargs): # -> None:
    """Emit progress log messages

    This helper can be used to handle progress reporting without having
    to maintain display mode specific code.

    Typical progress reporting via this function involves three types of
    calls:

    1. Start reporting progress about a process
    2. Update progress information about a process
    3. Report completion of a process

    In order to be able to associate all three steps with a particular process,
    the `pid` identifier is used. This is an arbitrary string that must be
    chosen to be unique across all different, but simultaneously running
    progress reporting activities within a Python session. For many practical
    purposes this can be achieved by, for example, including path information
    in the identifier.

    To initialize a progress report this function is called without an
    `update` parameter. To report a progress update, this function is called
    with an `update` parameter. To finish a reporting on a particular activity
    a final call without an `update` parameter is required.


    Parameters
    ----------
    lgrcall : callable
      Something like lgr.debug or lgr.info
    pid : str
      Some kind of ID for the process the progress is reported on.
    *args : str
      Log message, and potential arguments
    total : int
      Max progress quantity of the process.
    label : str
      Process description. Should be very brief, goes in front of progress bar
      on the same line.
    unit : str
      Progress report unit. Should be very brief, goes after the progress bar
      on the same line.
    update : int
      To (or by) which quantity to advance the progress. Also see `increment`.
    increment : bool
      If set, `update` is interpreted as an incremental value, not absolute.
    initial : int
      If set, start value for progress bar
    noninteractive_level : int, optional
      In a non-interactive session where progress bars are not displayed,
      only log a progress report, if a logger's effective level includes the
      specified level. This can be useful logging all progress is inappropriate
      or too noisy for a log.
    maint : {'clear', 'refresh'}
      This is a special attribute that can be used by callers that are not
      actually reporting progress, but need to ensure that their (console)
      output does not interfere with any possibly ongoing progress reporting.
      Setting this attribute to 'clear' will cause the central ProgressHandler
      to temporarily stop the display of any active progress bars. With
      'refresh', all active progress bars will be redisplayed. After a 'clear'
      individual progress bars would be reactivated upon the next update log
      message, even without an explicit 'refresh'.
    """
    ...

@optional_args
def with_result_progress(fn, label=..., unit=..., log_filter=...): # -> Callable[..., Generator[Any, Any, None]]:
    """Wrap a progress bar, with status counts, around a function.

    Parameters
    ----------
    fn : generator function
        This function should accept a collection of items as a
        positional argument and any number of keyword arguments.  After
        processing each item in the collection, it should yield a status
        dict.
    log_filter : callable, optional
        If defined, only result records for which callable evaluates to True will be
        passed to log_progress

    label, unit : str
        Passed to log.log_progress.

    Returns
    -------
    A variant of `fn` that shows a progress bar.  Note that the wrapped
    function is not a generator function; the status dicts will be
    returned as a list.
    """
    ...

def with_progress(items, lgrcall=..., label=..., unit=...): # -> Generator[Any, Any, None]:
    """Wrap a progress bar, with status counts, around an iterable.

    Parameters
    ----------
    items : some iterable
    lgrcall: callable
      Callable for logging. If not specified - lgr.info is used
    label, unit : str
        Passed to log.log_progress.

    Yields
    ------
    Items of it while displaying the progress
    """
    ...

@contextmanager
def no_progress(): # -> Generator[None, Any, None]:
    """Context manager to clear progress bars for the duration of the context"""
    ...

class LoggerHelper:
    """Helper to establish and control a Logger"""
    def __init__(self, name=..., logtarget=...) -> None:
        """

        Parameters
        ----------
        name :
        logtarget : string, optional
          If we want to use our logger for other log targets, while having
          a uniform control over them
        """
        ...
    
    def set_level(self, level=..., default=...): # -> None:
        """Helper to set loglevel for an arbitrary logger

        By default operates for 'datalad'.
        TODO: deduce name from upper module name so it could be reused without changes
        """
        ...
    
    def get_initialized_logger(self, logtarget=...): # -> Logger:
        """Initialize and return the logger

        Parameters
        ----------
        logtarget: {'stderr', str }, optional
          Where to direct the logs. 'stderr' stands for the standard stream.
          Any other string is considered a filename.  Multiple entries could be
          specified comma-separated

        Returns
        -------
        logging.Logger
        """
        ...
    


lgr = ...

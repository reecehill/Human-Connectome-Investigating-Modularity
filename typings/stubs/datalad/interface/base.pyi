"""
This type stub file was generated by pyright.
"""

import string

"""High-level interface generation

"""
__docformat__ = ...
lgr = ...
default_logchannels = ...
def get_api_name(intfspec):
    """Given an interface specification return an API name for it"""
    ...

def get_cmdline_command_name(intfspec):
    """Given an interface specification return a cmdline command name"""
    ...

def get_interface_groups(include_plugins=...): # -> list[Unknown]:
    """Return a list of command groups.

    Parameters
    ----------
    include_plugins : bool, optional
        Whether to include a group named 'plugins' that has a list of
        discovered plugin commands.

    Returns
    -------
    A list of tuples with the form (GROUP_NAME, GROUP_DESCRIPTION, COMMANDS).
    """
    ...

def get_cmd_summaries(descriptions, groups, width=...): # -> list[Unknown]:
    """Return summaries for the commands in `groups`.

    Parameters
    ----------
    descriptions : dict
        A map of group names to summaries.
    groups : list of tuples
        A list of groups and commands in the form described by
        `get_interface_groups`.
    width : int, optional
        The maximum width of each line in the summary text.

    Returns
    -------
    A list with a formatted entry for each command. The first command of each
    group is preceded by an entry describing the group.
    """
    ...

def load_interface(spec): # -> Any | None:
    """Load and return the class for `spec`.

    Parameters
    ----------
    spec : tuple
        For a standard interface, the first item is the datalad source module
        and the second object name for the interface. For a plugin, the second
        item should be a dictionary that maps 'file' to the path the of module.

    Returns
    -------
    The interface class or, if importing the module fails, None.
    """
    ...

def get_cmd_doc(interface): # -> LiteralString | Literal['']:
    """Return the documentation for the command defined by `interface`.

    Parameters
    ----------
    interface : subclass of Interface
    """
    ...

def get_cmd_ex(interface): # -> str:
    """Return the examples for the command defined by 'interface'.

    Parameters
    ----------
    interface : subclass of Interface
    """
    ...

def dedent_docstring(text): # -> str | None:
    """Remove uniform indentation from a multiline docstring"""
    ...

def alter_interface_docs_for_api(docs): # -> str:
    """Apply modifications to interface docstrings for Python API use."""
    ...

def alter_interface_docs_for_cmdline(docs): # -> str:
    """Apply modifications to interface docstrings for cmdline doc use."""
    ...

def is_api_arg(arg): # -> bool:
    """Return True if argument is our API argument or self or used for internal
    purposes
    """
    ...

def update_docstring_with_parameters(func, params, prefix=..., suffix=..., add_args=...):
    """Generate a useful docstring from a parameter spec

    Amends any existing docstring of a callable with a textual
    description of its parameters. The Parameter spec needs to match
    the number and names of the callables arguments.
    """
    ...

def build_example(example, api=...): # -> str:
    """Build a code example.

    Take a dict from a classes _example_ specification (list of dicts) and
    build a string with an api or cmd example (for use in cmd help or
    docstring).

    Parameters
    ----------
    api : {'python', 'cmdline'}
        If 'python', build Python example for docstring. If 'cmdline', build
        cmd example.

    Returns
    -------
    ex : str
        Concatenated examples for the given class.
    """
    ...

def update_docstring_with_examples(cls_doc, ex):
    """Update a commands docstring with examples.

    Take _examples_ of a command, build the Python examples, and append
    them to the docstring.

    cls_doc: docstring
    ex: list
        list of dicts with examples
    """
    ...

def build_doc(cls, **kwargs):
    """Decorator to build docstrings for datalad commands

    It's intended to decorate the class, the __call__-method of which is the
    actual command. It expects that __call__-method to be decorated by
    eval_results.

    Parameters
    ----------
    cls: Interface
      class defining a datalad command
    """
    ...

NA_STRING = ...
class nagen:
    """A helper to provide a desired missing value if no value is known

    Usecases
    - could be used as a generator for `defaultdict`
    - since it returns itself upon getitem, should work even for complex
      nested dictionaries/lists .format templates
    """
    def __init__(self, missing=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __getitem__(self, *args): # -> Self@nagen:
        ...
    
    def __getattr__(self, item): # -> Self@nagen:
        ...
    


def nadict(*items): # -> defaultdict[Unknown, nagen]:
    """A generator of default dictionary with the default nagen"""
    ...

class DefaultOutputFormatter(string.Formatter):
    """A custom formatter for default output rendering using .format
    """
    def __init__(self, missing=...) -> None:
        """
        Parameters
        ----------
        missing: string, optional
          What to output for the missing values
        """
        ...
    
    def get_value(self, key, args, kwds):
        ...
    


class DefaultOutputRenderer:
    """A default renderer for .format'ed output line
    """
    def __init__(self, format) -> None:
        ...
    
    def __call__(self, x, **kwargs): # -> Any:
        ...
    


class Interface:
    """Base class for interface implementations"""
    _interrupted_exit_code = ...
    _OLDSTYLE_COMMANDS = ...
    @classmethod
    def setup_parser(cls, parser): # -> None:
        ...
    
    @classmethod
    def call_from_parser(cls, args): # -> list[Any] | Any:
        ...
    
    @classmethod
    def get_refds_path(cls, dataset): # -> str | Unknown:
        """Return a resolved reference dataset path from a `dataset` argument"""
        ...
    


def get_allargs_as_kwargs(call, args, kwargs): # -> OrderedDict[Unknown, Unknown]:
    """Generate a kwargs dict from a call signature and *args, **kwargs

    Basically resolving the argnames for all positional arguments, and
    resolvin the defaults for all kwargs that are not given in a kwargs
    dict
    """
    ...


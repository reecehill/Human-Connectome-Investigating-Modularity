function [trkEP_full,trk_len_full,trk_type_full]=conversion_tt(pathToFile, type, nTrackIterations)
% if pial= lh(rh).pial.surf.gii, transform using voxRAS;
% if pial= lh(rh).pial tranformation using vox2tkrRAS

% load tt file generated by dsi studio
close all;
restoredefaultpath;
gcp;
addpath('toolboxes/AlongTractStats');
addpath(genpath('toolboxes/SurfStat'));
addpath('toolboxes/FieldTrip');
ft_defaults;
ft_hastoolbox('gifti',1);
ft_hastoolbox('iso2mesh',1);
ft_hastoolbox('freesurfer',1);
disp('step1: performing conversion from .trk to surface and atlas')
disp(['Type: ' num2str(type) ' (' class(type) ')'])


%atlas image generated by FreeSurfer.
atlas=ft_read_mri([pathToFile '/T1w/aparc+aseg.nii.gz']);
disp("It's important to confirm the labels used in your atlas file" + ...
            " (e.g., aparc+aseg) and update the code accordingly. Assumed values for white matter have been used.");

if(exist([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz'],'file'))
    % trackImg generated by DSI Studio (.tt.nii.gz) - saved in aparc+aseg.nii.gz
    % space. Note there is also a .trk file that this file relies on for
    % computations. trackImg is optional for visualisation purposes.
    trackImg=ft_read_mri([pathToFile '/T1w/Diffusion/1m0.tt.nii.gz']);
end

if type==1
    atlasCRSToTkRAS = atlas.hdr.vox2ras; % vox2RAS: from voxel slices to scanner RAS coordinates
elseif type==2
    atlasCRSToTkRAS = atlas.hdr.tkrvox2ras; % from voxel slices to tk surface RAS coordinates.
else
    disp('wrong type of surface')
end


trk_len_full=[];
trk_type_full=[];
trkEP_full=[];

%% Loop through track files
for i=1:str2double(nTrackIterations)
    nTracksWithTwoUnknownEndpoints = 0;
    nTracksWithOneUnknownEndpoint = 0;
    %whiteMatterEndpointLabelIDs =[];

    %Read .trk meta and coordinates.
    [rawTrkHeader, rawtrkCoords_tkReg] = trk_read([pathToFile,'/T1w/Diffusion/1m',num2str(0+i-1),'.trk']);

%     trkCoords_ras = rawtrkCoords_tkReg;
    rawTrkLen=length(rawtrkCoords_tkReg);
    trk_len=zeros(rawTrkLen,1,'single');
    trk_type=zeros(rawTrkLen,3,'single');
    trkEP=zeros(rawTrkLen,6,'single');%
    storeTrkStartP = zeros([4,rawTrkLen]);
    storeTrkEndP = zeros([4,rawTrkLen]);
    storeTrkStartCoords = zeros([4,rawTrkLen]);
    voxel_size = rawTrkHeader.voxel_size;
    atlasDim = atlas.dim;
    milestones = round(rawTrkLen * (0:0.1:1));
    tic;
    disp("Looping through each track and converting into endpoints.");

    parfor k=1:rawTrkLen
        if ismember(k,milestones)
            disp((k/rawTrkLen)*100+"%");
        end
        trkMatrix_crs = rawtrkCoords_tkReg(k).matrix ./ voxel_size;

        % Flip Y [LPS (.trk) -> LAS (.anat)]
        trkMatrix_crs(:,2) = (-1 * trkMatrix_crs(:,2)) + atlasDim(2); %flip Y.
        % Define the endpoints of the track.
        trkMatrix_crs_terminals = [trkMatrix_crs(1,:)'  trkMatrix_crs(end,:)'; 1 1;];


        %% Transform track coordinates from CRS into Scanner RAS space
        % Get track coordinates from CRS into Scanner RAS space.
        trkMatrix_ras = atlasCRSToTkRAS * [trkMatrix_crs'; ones(1,size(trkMatrix_crs,1))];
        % Get track endpoints from CRS into Scanner RAS space.
        trkMatrix_ras_terminals = atlasCRSToTkRAS * trkMatrix_crs_terminals;

        isInDifferentSpace = false;
        if(isInDifferentSpace)
            % If the track files are saved in a different space (e.g., the
            % DSI Studio template), they must be registered into the
            % aparc+aseg file.

            % To generate register.dat
            % tkregister2 --mov [dsi-studio root]/atlas/ICBM152_adult/ICBM152_adult.T1W.nii.gz --targ [subjectRoot]/T1w/T1w.nii.gz --reg [subjectRoot]/T1w/register.dat --regheader --noedit
            tkregister_matrix    = importdata([pathToFile '/MNINonLinear/register.dat']);
            tkregister_matrix    = reshape(tkregister_matrix.data(4:end), [4 4])';

            % Register TkReg track endpoints from DSIStudio default to
            % subject.
            trkMatrix_registered_ras = tkregister_matrix * trkMatrix_ras;
            trkMatrix_registered_ras_terminals = tkregister_matrix * trkMatrix_ras_terminals;
        else
            % Skip registering TkReg track endpoints.
            trkMatrix_registered_ras = trkMatrix_ras;
            trkMatrix_registered_ras_terminals = trkMatrix_ras_terminals;
        end
        trkstartp = round(trkMatrix_crs_terminals(1:3,1)); %rename for readability
        trkendp = round(trkMatrix_crs_terminals(1:3,end)); %rename for readability
        trkstartp = boundByAtlasDimensions(trkstartp, atlasDim);
        trkendp = boundByAtlasDimensions(trkendp, atlasDim);

        storeTrkStartP(:, k) = [trkstartp; 1]; % store endpoint in matrix for visualisation.
        storeTrkStartCoords(:, k) = [trkMatrix_registered_ras(1:3,1); 1]; % store endpoint in matrix for visualisation.
        %storeTrkEndP(:, k) = [trkendp; 1];

        %% TODO: Insert validation check. Are points being moved inconsiderable
        %% distances?

        %Compute track length along each vertex
        trkPoints_notLast=trkMatrix_crs(1:end-1,:);
        trkPoints_notFirst=trkMatrix_crs(2:end,:);
        distBetweenTrkPoints=sqrt( (trkPoints_notLast(:,1)-trkPoints_notFirst(:,1)).^2 +(trkPoints_notLast(:,2)-trkPoints_notFirst(:,2)).^2 +(trkPoints_notLast(:,3)-trkPoints_notFirst(:,3)).^2);
        trk_len(k,1)=sum(distBetweenTrkPoints);

        % for the track to pial surface space
        trkEP(k,:)=[single(trkMatrix_registered_ras_terminals(1:3,1)') single(trkMatrix_registered_ras_terminals(1:3,end)')];

        % tmp information:
        % 1: trkstartp anatomical label ID
        % 2: trkendp anatomical label ID
        % 3: neighbouring voxels are in grey matter. (e.g., terminating within
        % subcortical structures). 1 = "ends in grey matter".
        tmp=NaN(1,3);
        try
            tmp(1:2)=[atlas.anatomy(trkstartp(1),trkstartp(2),trkstartp(3)),atlas.anatomy(trkendp(1),trkendp(2),trkendp(3))];
        catch
            %scatter3(trkMatrix(1,1),trkMatrix(1,2),trkMatrix(1,3));
            %scatter3(trkMatrix(end,1),trkMatrix(end,2),trkMatrix(end,3));
            disp("Error: The track endpoints yield indices that are not within the atlas image.");
            pause;
        end


        %% Check subcortical regions
        % For info on the choice of these numbers (1000, 3000 etc) check the
        % Freesurfer lookup table: https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLU
        ventricularSystemIndices = [14:15,24];
        whiteMatterIndices = [1:6,27:46,59:999,ventricularSystemIndices];
        subcorticalIndices = [7:13,16:23,25:26,47:58,1001:1099,1101:1999,2001:2099,2101:2999];
        unknownIndices = [0,1000,2000,3000,4000,1100,2100,3100,4100,11100,12100,13100,14100];
        if(ismember(tmp(1),whiteMatterIndices) || ...
                ismember(tmp(2),whiteMatterIndices))
            % If either endpoint is in the white matter, mark it.
            tmp(1,3)=0;
            
            if(tmp(1,3) == 0)
                if(ismember(tmp(1),whiteMatterIndices))
                    %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                end
                if(ismember(tmp(2),whiteMatterIndices))
                    %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                end
            end
        else
            % If the tracks do not terminate in white matter, confirm they
            % terminate in grey matter.
            if( ismember(tmp(1),subcorticalIndices) && ...
                    ismember(tmp(2),subcorticalIndices))
                % Both endpoints end in subcortical/grey matter...
                tmp(1,3)=1;
            elseif ( ismember(tmp(1),subcorticalIndices) && ...
                    ismember(tmp(2),unknownIndices))
                % Endpoint starts in subcortical/grey matter but
                % ends in "unknown"...
                try
                    nTracksWithOneUnknownEndpoint = nTracksWithOneUnknownEndpoint + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [1]...")
                    pause
                end
            elseif ( ismember(tmp(1),unknownIndices) && ...
                    ismember(tmp(2),subcorticalIndices))
                % Endpoint starts in "unknown" but
                % ends in subcortical/grey matter...
                try
                    nTracksWithOneUnknownEndpoint = nTracksWithOneUnknownEndpoint + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [2]...")
                    pause
                end
            elseif (ismember(tmp(1),unknownIndices) && ...
                    ismember(tmp(2),unknownIndices))
                % If both track endpoints are "unknown"...
                try
                    nTracksWithTwoUnknownEndpoints = nTracksWithTwoUnknownEndpoints + 1;
                    tmp(1,3)=checkInNeighbourVoxels_withsubcortical(atlas,trkstartp) && checkInNeighbourVoxels_withsubcortical(atlas,trkendp);
                    if(tmp(1,3) == 0)
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(1)]);
                           %whiteMatterEndpointLabelIDs = unique([whiteMatterEndpointLabelIDs; tmp(2)]);
                    end
                catch
                    disp("Error: checkInNeighbourVoxels_withsubcortical [3]...")
                    pause
                end
            else
                disp("Endpoint not analysed.");
                pause
            end
        end

        % only take consideration of cortical regjons
        %     if tmp(1)<1000 && tmp(1)>=3000 && tmp(1)~=0 && tmp(2)<1000 && tmp(2)>=3000 && tmp(2)~=0
        %         tmp(1,3)=0;
        %     elseif tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000 && tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000
        %         tmp(1,3)=1;
        %     elseif tmp(1)==0 && tmp(2)==0
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp)*checkInNeighbourVoxels(atlas,trkendp);
        %     elseif tmp(1)==0 && (tmp(2)>=1000 && tmp(2)<3000 && tmp(2)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkstartp);
        %     elseif tmp(2)==0 && (tmp(1)>=1000 && tmp(1)<3000 && tmp(1)~=2000)
        %         tmp(1,3)=checkInNeighbourVoxels(atlas,trkendp);
        %     end

        trk_type(k,:)=tmp;
    end
    disp("Done looping converting tracks to endpoints.")
    toc;
    disp(["Number of tracks with one unknown endpoint as per atlas:", num2str(nTracksWithOneUnknownEndpoint)]);
    disp(["Number of tracks with both endpoints in unknown as per atlas:", num2str(nTracksWithTwoUnknownEndpoints)]);
    disp(["Number of tracks with start AND end points in grey matter (filtered in):", sum(trk_type(:,3))]);
    if(sum(isnan(trk_type(:,3))) > 0)
        disp(["Number of tracks with endpoints uncategorised as white/grey matter:", num2str(sum(isnan(trk_type(:,3))))]);        
        pause
    end
    disp(["Number of tracks, therefore, concluded to be in white matter (filtered out):", size(trk_type,1)-sum(trk_type(:,3))]);
    disp(["Total tracts:", size(trk_type,1)]);
    
    trk_len_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen) =trk_len;
    trk_type_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trk_type;
    trkEP_full(1+((i-1)*rawTrkLen):(i)*rawTrkLen,:)=trkEP;

end


%% Visualisations
if(exist("trackImg", "var"))
    figure;
    title("Slices of atlas and trackImg nifti files")
    slice(double(atlas.anatomy),size(atlas.anatomy,2)/2,size(atlas.anatomy,1)/2,size(atlas.anatomy,3)/2);
    figure;
    trackImg.anatomy = flip(trackImg.anatomy,2);
    slice(double(trackImg.anatomy),size(trackImg.anatomy,2)/2,size(trackImg.anatomy,1)/2,size(trackImg.anatomy,3)/2);
end

if(1 == 0)
    trkCoords_tkReg = storeTrkStartCoords';

    % Convert: trkCoords_tkReg (tkReg) -> atlas CRS
    atlasCRS = (round(inv(atlasCRSToTkRAS)*trkCoords_tkReg'))';
    atlasCoords_tkReg = (atlasCRSToTkRAS*atlasCRS')';

    figure;
    title("Tracts and Aparc in coordinates (xyz)")
    hold on;
    legend;
    scatter3(atlasCoords_tkReg(1:1:end,1),atlasCoords_tkReg(1:1:end,2),atlasCoords_tkReg(1:1:end,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg(1:1:end,1),(trkCoords_tkReg(1:1:end,2)),trkCoords_tkReg(1:1:end,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'/tracts_aparc_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_aparc_xyz.png']);
    hold on;

    mycifti = ft_read_cifti([pathToFile,'/T1w/Results/tfMRI_MOTOR/tfMRI_MOTOR_hp200_s2_level2.feat/100307_tfMRI_MOTOR_level2_hp200_s2.dscalar.nii']);
    mygifti_L = gifti([pathToFile,'/T1w/fsaverage_LR32k/100307.L.pial.32k_fs_LR.surf.gii']);
    mygifti_R = gifti([pathToFile,'/T1w/fsaverage_LR32k/100307.R.pial.32k_fs_LR.surf.gii']);
    figure;
    title("Tracts and Aparc and fmri in coordinates (xyz)")
    hold on;
    legend;
    xlabel('x');
    ylabel('y');
    zlabel('z');
    mygifti_L_vertices_transformed = [mygifti_L.vertices];
    mygifti_R_vertices_transformed = [mygifti_R.vertices];

    % NB: vertices coords are in SurfaceRAS. Therefore, to go from aparc (CRS)
    % to this, we must use "type 1".
    mygifti_L.faces(mygifti_L.faces>1) = 1;
    plotsurf(mygifti_L_vertices_transformed(:,1:3), mygifti_L.faces, mycifti.x100307_tfmri_motor_level2_lf_hp200_s2(mycifti.brainstructure==1));
    plotsurf(mygifti_R_vertices_transformed(:,1:3), mygifti_R.faces, mycifti.x100307_tfmri_motor_level2_lf_hp200_s2(mycifti.brainstructure==2));
    scatter3(atlasCoords_tkReg(1:1:end,1),atlasCoords_tkReg(1:1:end,2),atlasCoords_tkReg(1:1:end,3), 'DisplayName', "atlasCoords_{tkReg}");
    scatter3(trkCoords_tkReg(1:1:end,1),(trkCoords_tkReg(1:1:end,2)),trkCoords_tkReg(1:1:end,3), 'DisplayName', "trkCoords_{tkReg}");
    savefig([pathToFile,'//tracts_aparc_fmri_xyz.fig']);
    saveas(gcf,[pathToFile,'/tracts_aparc_fmri_xyz.png']);

    figure;
    title("Tracts and Aparc in voxels (ijk)")
    % Build: take atlas.nii.gz and binarize it to approximate volume (CRS)
    atlasCRSIndices = find(atlas.anatomy > mean(atlas.anatomy,'ALL'));
    [atlasX, atlasY, atlasZ] = ind2sub(atlas.dim, atlasCRSIndices);
    atlasCRS = [atlasX atlasY atlasZ];
    trkCRS = storeTrkStartP;
    hold on;
    legend;
    scatter3(atlasCRS(1:1:end,1),atlasCRS(1:1:end,2),atlasCRS(1:1:end,3), 'DisplayName', "atlasCRS");
    scatter3(trkCRS(1,1:1:end),trkCRS(2,1:1:end),trkCRS(3,1:1:end), 'DisplayName', "trkCRS");
    savefig([pathToFile,'/tracts_aparc_ijk.fig']);
    saveas(gcf, [pathToFile,'/tracts_aparc_ijk.png']);
end
end
%%
%  coordsIn3d = zeros(size(allFunctionalData.modules.threeDimensions),3);
%             % Create matrix where each element is a vector of coordinates.
%             coordsIn3d(sub2ind(size(coordsIn3d),xSubsection,ySubsection,zSubsection))=allFunctionalData.nodes.mni152(activeNodes);

function mapDwiAndFmriToFaces(pathToSubjectDir,subject,conditions,visualiseData)
conditions = textscan(conditions(2:end-1), '%s','Delimiter',{',',char("'")},'MultipleDelimsAsOne',true); % Used to enable conversion of character array (from python) to cell string array
conditions = conditions{:};

for conditionIndex=1:length(conditions)
    conditionName = char(conditions(conditionIndex));
    %% INSTRUCTIONS
    % Anatomical, DWI, fMRI data are used in this script.
    try
        tic;
        if ~exist([pathToSubjectDir '/moduleResults'], 'dir')
            mkdir([pathToSubjectDir '/moduleResults'])
        end
        if ~exist([pathToSubjectDir '/moduleResults/figures'], 'dir')
            mkdir([pathToSubjectDir '/moduleResults/figures'])
        end
        if ~exist([pathToSubjectDir '/moduleResults/figures/' conditionName], 'dir')
            mkdir([pathToSubjectDir '/moduleResults/figures/' conditionName])
        end

        %% Initialise.
        %addpath('toolboxes/FieldTrip');

        %ft_defaults;
       
        %ft_hastoolbox('bct',1);
        addpath(genpath('/home/reece/iso2mesh/iso2mesh'));
        %ft_hastoolbox('iso2mesh',1);
        %addpath(genpath('toolboxes/SurfStat'));
        close all;

        surf = struct('nodes',[],'faces',[],'edges',[],'regions',[],'holes',[]);
        baseStruct.surf = surf;

        if(exist("allBrainData",'var') && ~isempty(allBrainData.leftHemisphere.surf.faces) && ~isempty(allBrainData.rightHemisphere.surf.faces) && ~isempty(allBrainData.leftHemisphere.optimalGamma) && ~isempty(allBrainData.rightHemisphere.optimalGamma))
            tempStore.leftStructuralModules = allBrainData.leftHemisphere.surf.faces(:,4);
            tempStore.rightStructuralModules = allBrainData.rightHemisphere.surf.faces(:,4);
            tempStore.leftOptimalGamma = allBrainData.leftHemisphere.optimalGamma;
            tempStore.rightOptimalGamma = allBrainData.rightHemisphere.optimalGamma;
        end
        allStructuralData = baseStruct;
        roiStructuralData = baseStruct;
        allFunctionalData = baseStruct;
        allBrainData = baseStruct;

        %% Parameters
        roiLabels = ["precentral.label"]; % only supports single values for now.
        showTicksPer = 1000;
        viewSliceOfAllFmriModules = 0;

        %% Load external parameters
        load([pathToSubjectDir '/matrices.mat']);
        load([pathToSubjectDir '/labelSRF.mat'], 'lo_faceROIidL', 'lo_faceROIidR',...
            'hi_faceROIidL', 'hi_faceROIidR',...
            'lo_glpfaces', 'lo_grpfaces',...
            'hi_glpfaces', 'hi_grpfaces',...
            'lo_glpvertex', 'lo_grpvertex',...
            'hi_glpvertex', 'hi_grpvertex',...
            'lo_centroidsSubCor',  'hi_centroidsSubCor',...
            'lo_faceROIidSubCor', 'hi_faceROIidSubCor',...
            'lo_faceToNodeMapLH', 'lo_faceToNodeMapRH',...
            'hi_faceToNodeMapLH', 'hi_faceToNodeMapRH',...
            'lo_centroidsL', 'lo_centroidsR',...
            'hi_centroidsL', 'hi_centroidsR',...
            'filenames', 'subfilenames');
        load([pathToSubjectDir '/edgeList.mat'],"subCoor");
        %load([pathToSubjectDir '/MNIcoor.mat'],"Coor_MNI152");
        %load([pathToSubjectDir '/1stlevel/fMRIModules_000' conditionName '.mat'], "fmriModules");


        %% Load ROI labels
        downsample='yes'
        if strcmp(downsample,'no') % method for no downsample
            labelIds=[hi_faceROIidL(:,1); hi_faceROIidR(:,1); double(max(hi_faceROIidR(:,1)))+hi_faceROIidSubCor];
            %faceROI_L=[hi_faceROIidL(:,1); hi_faceROIidR(:,1); hi_faceROIidSubCor+length(filenames)];
        else
            labelIds=[lo_faceROIidL(:,1); lo_faceROIidR(:,1); double(max(lo_faceROIidR(:,1)))+lo_faceROIidSubCor];
            %faceROI_all=[lo_faceROIidL(:,1); lo_faceROIidR(:,1); lo_faceROIidSubCor+length(filenames)];
        end

        useROI=true;
        if(useROI)
            % If ROI is used, then the faceIDs are going to relative to the
            % ROI. We must now scale them up to the whole hemisphere.
            allFileNames = [filenames subfilenames];

            roi = "lh.L_precentral";
            roiIds = find(contains(allFileNames,roi));
            roiL_ids = find(ismember(labelIds(:,1),roiIds));

            roi = "rh.R_precentral";
            roiIds = find(contains(allFileNames,roi));
            roiR_ids = find(ismember(labelIds(:,1),roiIds));
        end
        %% TODO: Automate getting transformation matrices.
        % To get tkrRAS coordinates from row,col,slice of fmri data:
        % inv(mri.hdr.tkrvox2ras)*rmmissing(Reg)*[R A S 1]'

        % where tMov is generated by:
        % mri_info --vox2ras-tkr
        % ${SUBJECTS_DIR}/sub-002/data/func/task-HcpMotor_acq-ap_bold.nii

        % Added by Reece to make compatible with Python and HCP.
        %!mri_info --vox2ras-tkr
        %${SUBJECTS_DIR}/sub-002/data/func/task-HcpMotor_acq-ap_bold.nii %no
        %longer needed

        %tMov = load([pathToSubjectDir
        %'/data/func/vox2ras-tkr.csv']); %no longer needed.

        % where REG was obtained by:
        %  tkregister2 --mov "${SUBJECTS_DIR}/sub-002/data/func/sartask-HcpMotor_acq-ap_bold.nii" --s sub-002/data/  --noedit --regheader --reg "${SUBJECTS_DIR}/sub-002/data/func/register.dat" --targ "${SUBJECTS_DIR}/sub-002/data/bert/mri/T1.nii"
        % Reg = table2array(readtable([pathToSubjectDir
        % ,'/data/func/register.dat'])); %no longer needed.

        %% Integrate/handle labels into dataset.
        allBrainData.leftHemisphere.labels.ids = lo_faceROIidL(:,1);
        allBrainData.rightHemisphere.labels.ids = lo_faceROIidR(:,1);
        allBrainData.leftHemisphere.labels.names = filenames( allBrainData.leftHemisphere.labels.ids);
        allBrainData.rightHemisphere.labels.names = filenames( allBrainData.rightHemisphere.labels.ids);
        %allBrainData.subCortical.labels.names = transpose(subfilenames(lo_subcort));

        %% All Anatomical data
        %allBrainData.surf.nodes_mni152 = Coor_MNI152;
        % Left hemisphere
        allBrainData.leftHemisphere.surf.faces = lo_glpfaces;
        %allBrainData.leftHemisphere.surf.faces = glpfaces;
        allBrainData.leftHemisphere.surf.nodes = lo_glpvertex;
        %allBrainData.leftHemisphere.surf.nodes = glpvertex;

        % Right hemisphere
        allBrainData.rightHemisphere.surf.faces = lo_grpfaces;
        %allBrainData.rightHemisphere.surf.faces = grpfaces;
        allBrainData.rightHemisphere.surf.nodes = lo_grpvertex;
        %allBrainData.rightHemisphere.surf.nodes = grpvertex;

        % Both hemispheres make a whole.
        %allBrainData.surf.faces_mni152 = Coor_MNI152;
        [allBrainData.surf.nodes, allBrainData.surf.faces] = mergesurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces);
        %allBrainData.surf.edges = meshedge(allBrainData.surf.faces);



        %% All Structural data
        % All structure data
        allStructuralData.adjacencyMatrix = adj_matrix_wei;


        %% ROI Anatomical Data
        % Add region of interest data (face IDs and centroids).
        roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain = roiL_ids;
        roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain = roiR_ids-length(lo_glpfaces(:,1));
        %roiStructuralData.faceIdsOfAllBrain = [roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain; length(allBrainData.leftHemisphere.surf.faces) + roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain];
        %roiStructuralData.surf.faces_mni152 = allBrainData.surf.faces_mni152(roiStructuralData.faceIdsOfAllBrain,:);
        roiStructuralData.leftHemisphere.surf.centroids = lo_centroidsL(roiL_ids,:);
        roiStructuralData.rightHemisphere.surf.centroids = lo_centroidsR(roiR_ids-length(lo_glpfaces),:);
        roiStructuralData.leftHemisphere.adjacencyMatrix = allStructuralData.adjacencyMatrix(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain);

        %     %Testing if labels are inaccurate...
        % Offset the face IDs of right hemisphere to skip past the left
        % hemisphere faces!
        roiStructuralData.rightHemisphere.adjacencyMatrix = allStructuralData.adjacencyMatrix(length(allBrainData.leftHemisphere.surf.faces) + roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,length(allBrainData.leftHemisphere.surf.faces) + roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain);
        %     adjacencyMatrixChangesAtPoint = find(ischange(roiStructuralData.rightHemisphere.adjacencyMatrix) ==1);
        %     [pointX, pointY] = ind2sub(size(roiStructuralData.rightHemisphere.adjacencyMatrix), adjacencyMatrixChangesAtPoint);
        %     %Update adjacency matrix accordingly...
        %     roiStructuralData.rightHemisphere.adjacencyMatrix = roiStructuralData.rightHemisphere.adjacencyMatrix(1:pointX,1:pointX);
        %     roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain = roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain(1:pointX);

        roiStructuralData.leftHemisphere.labels.names = allBrainData.leftHemisphere.labels.names(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain);
        roiStructuralData.rightHemisphere.labels.names = allBrainData.rightHemisphere.labels.names(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain);
        roiStructuralData.subCortical.labels.names = []; % script is incompatible with ROI within the subcortical regions.



        % --------
        % ----
        % --------



        %% ROI Structural Data
        %% Load modules
        readmatrix([pathToSubjectDir, '/exported_modules/left_structural_modules.csv']);
        allCsvFiles = dir(fullfile([pathToSubjectDir, '/exported_modules'], '*.csv'));
        allModules = struct();
        for k = 1:length(allCsvFiles)
            allModules(k).name = allCsvFiles(k).name(1:end-4);
            allModules(k).moduleGroup = readmatrix([pathToSubjectDir, '/exported_modules/', allCsvFiles(k).name]);
        end

        % Add structural data
        k = find(ismember([{allModules.name}],'all_left_structural_modules'));
        allBrainData.leftHemisphere.surf.faces(:,4) = allModules(k).moduleGroup';
        k = find(ismember([{allModules.name}],'all_right_structural_modules'));
        allBrainData.rightHemisphere.surf.faces(:,4) = allModules(k).moduleGroup';

        k = find(ismember([{allModules.name}],['left_',conditionName,'_functional_modules']));
        allBrainData.leftHemisphere.surf.faces(:,5) = nan;
        allBrainData.leftHemisphere.surf.faces(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain,5) = allModules(k).moduleGroup';
        roiBrainData.leftHemisphere.surf.faces(:,5) = allModules(k).moduleGroup';
        allFunctionalData.leftHemisphere.surf.faces(:,5) = nan(length(allBrainData.leftHemisphere.surf.faces(:,1)),1);
        allFunctionalData.leftHemisphere.surf.faces(roiL_ids,5) = allModules(k).moduleGroup';

        k = find(ismember([{allModules.name}],['right_',conditionName,'_functional_modules']));
        allBrainData.rightHemisphere.surf.faces(:,5) = nan;
        allBrainData.rightHemisphere.surf.faces(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain,5) = allModules(k).moduleGroup';
        roiBrainData.rightHemisphere.surf.faces(:,5) = allModules(k).moduleGroup';
        allFunctionalData.rightHemisphere.surf.faces(:,5) = nan;
        allFunctionalData.rightHemisphere.surf.faces(roiR_ids,5) = allModules(k).moduleGroup';

        load([pathToSubjectDir '/optimal_struc_modules.mat']);
        allBrainData.leftHemisphere.optimalGamma = optimal_gamma.left_structural;
        allBrainData.rightHemisphere.optimalGamma = optimal_gamma.right_structural;
        %% Now, mesh individual fMRI modules.

        figure(99);
        hold on;
        title('fMRI modules determined by meshing surfaces one at a time.');
        plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(:,1:3),'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');
        plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(:,1:3),'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');

        allFunctionalData.moduleIds = [allBrainData.leftHemisphere.surf.faces(:,5); allBrainData.rightHemisphere.surf.faces(:,5);];
        allFunctionalData.modules = zeros(1,0);

        for hemisphereIndex= 1:1:2
            hemispheres = {'left','right'};
            hemisphere = char(hemispheres(hemisphereIndex));
            fmriModules = allBrainData.([hemisphere, 'Hemisphere']).surf.faces(:,5);
            for moduleIndex=1:1:max(fmriModules,[],'all')
                moduleName = fmriModules(moduleIndex);
                % Get nodeIds that belong to current module (starting from 1, not 0).
                allFunctionalData.modules(moduleIndex).nodeIds = find(fmriModules == moduleName); % the ids of all nodes with a module.
                allFunctionalData.modules(moduleIndex).surf.faces = allBrainData.surf.faces(allFunctionalData.modules(moduleIndex).nodeIds,1:3);
                allFunctionalData.modules(moduleIndex).surf.nodes = allBrainData.surf.nodes;
                % View generated surface for each fMRI module.
                figure(99);
                subtitle(["Subject: ", subject, "Hemisphere: ", hemisphere, "Functional module: ", moduleIndex])
                plotsurf(allFunctionalData.modules(moduleIndex).surf.nodes,allFunctionalData.modules(moduleIndex).surf.faces);
            end
        end
        savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/fmri-modules-one-at-a-time'],'compact');


        %% Map fMRI activation clusters surface to combined anatomical surface.
        allBrainData.leftHemisphere.surfaceNorm = nodesurfnorm(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(:,1:3));
        allBrainData.rightHemisphere.surfaceNorm = nodesurfnorm(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(:,1:3));

        % Compute a vector that maps nodes to adjacent faces
        [allBrainData.leftHemisphere.nodesToFaces,~,~]=neighborelem(allBrainData.leftHemisphere.surf.faces(:,1:3),length(allBrainData.leftHemisphere.surf.nodes));
        [allBrainData.rightHemisphere.nodesToFaces,~,~]=neighborelem(allBrainData.rightHemisphere.surf.faces(:,1:3),length(allBrainData.rightHemisphere.surf.nodes));

        % Independently map each cluster to the surface.
        for moduleIndex=1:1:size(allFunctionalData.modules,2)
            % Generate point cloud of fMRI nodes to find closest DWI nodes.
            pointCloudVar = pointCloud(allFunctionalData.modules(moduleIndex).surf.nodes(:,1:3));

            % For each of the fMRI points, find the nearest node in the left
            % and right hemisphere OF THE PRECENTRAL GYRUS. Whichever is closest, project it to that one.

            %Create var of nodes, but move non-ROI nodes to 0,0,0 so they won't
            %match with the fmri.
            lNodesNotInROITempPositions = allBrainData.leftHemisphere.surf.nodes(:,:);
            lNodeIdsInROI = reshape(allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4)==0)),[],1);
            lNodesNotInROITempPositions(lNodeIdsInROI,:) = deal(0);
            rNodesNotInROITempPositions = allBrainData.rightHemisphere.surf.nodes;
            rNodeIdsInROI = reshape(allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4)==0)),[],1);
            rNodesNotInROITempPositions(rNodeIdsInROI,:) = deal(0);


            [distanceToLeftSurface,closestLeftSurfaceNodeIds] = dist2surf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surfaceNorm,pointCloudVar.Location);
            [distanceToRightSurface,closestRightSurfaceNodeIds] = dist2surf(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surfaceNorm,pointCloudVar.Location);

            meanDistanceToLeftSurface = mean(distanceToLeftSurface);
            meanDistanceToRightSurface = mean(distanceToRightSurface);



            if(meanDistanceToLeftSurface<=meanDistanceToRightSurface)
                table.projectedDistance = meanDistanceToLeftSurface;
                writetable(struct2table(table, "AsArray",true), [pathToSubjectDir '/projectedDistance_' conditionName '.csv'], "WriteMode","append");
                if(meanDistanceToLeftSurface>1.5) % If fmri voxel is >1.5mm out (voxel size from scanner) from the MRI image...
                    disp(["****Warning: A left fMRI module was more than 3mm away (" num2str(meanDistanceToLeftSurface) ") from the MRI."])
                end
                neighbouringFacesOfNode = allBrainData.leftHemisphere.nodesToFaces(closestLeftSurfaceNodeIds);
                allNeighbouringFaces = unique(cat(2,neighbouringFacesOfNode{:}));
                allBrainData.leftHemisphere.surf.faces(allNeighbouringFaces,5) = moduleIndex;
            else
                table.projectedDistance = meanDistanceToRightSurface;
                writetable(struct2table(table, "AsArray",true), [pathToSubjectDir '/projectedDistance_' conditionName '.csv'], "WriteMode","append");

                if(meanDistanceToRightSurface>1.5)
                    disp(["****Warning: A right fMRI module was more than 3mm away (" num2str(meanDistanceToRightSurface) ") from the MRI."])
                end
                neighbouringFacesOfNode = allBrainData.rightHemisphere.nodesToFaces(closestRightSurfaceNodeIds);
                allNeighbouringFaces = unique(cat(2,neighbouringFacesOfNode{:}));
                allBrainData.rightHemisphere.surf.faces(allNeighbouringFaces,5) = moduleIndex;
            end


            % For each fMRI node,
            %         for fmriPoint=1:size(pointCloudVar.Location,1)
            %             if(distanceToLeftSurface(fmriPoint)<=distanceToRightSurface(fmriPoint))
            %                 % Find face IDs that are closest to activate nodes.
            %                 neighbouringFacesOfNode = allBrainData.leftHemisphere.nodesToFaces(closestLeftSurfaceNodeIds(fmriPoint));
            %                 allNeighbouringFaces = unique(cat(2,neighbouringFacesOfNode{:}));
            %
            %                 % Change colour of neighbouring faces.
            %                 allBrainData.leftHemisphere.surf.faces(allNeighbouringFaces,5) = moduleIndex;
            %             elseif(distanceToLeftSurface(fmriPoint)>distanceToRightSurface(fmriPoint))
            %                 % Find face IDs that are closest to activate nodes.
            %                 neighbouringFacesOfNode = allBrainData.rightHemisphere.nodesToFaces(closestRightSurfaceNodeIds(fmriPoint));
            %                 allNeighbouringFaces = unique(cat(2,neighbouringFacesOfNode{:}));
            %
            %                 % Change colour of neighbouring faces.
            %                 allBrainData.rightHemisphere.surf.faces(allNeighbouringFaces,5) = moduleIndex;
            %             else
            %                 input('There was an fmri point that was equidistant to both left and right hemispheres...');
            %                 exit;
            %             end
            %         end


        end

        %         %% Build connectivity matrix from fMRI -- ABANDONED.
        %         leftFmriFaceIds = find(~allBrainData.leftHemisphere.surf.faces(:,5) == 0);
        %         leftFaceNeighbors = edgeneighbors(allBrainData.leftHemisphere.surf.faces(leftFmriFaceIds,1:3),'general');
        %         for faceId=leftFmriFaceIds
        %             % For each activate face, check if its neighbors are active. If
        %             % they are not, remove them from the list.
        %             for neighborId=leftFaceNeighbors
        %                 if(allBrainData.leftHemisphere.surf.faces([leftFaceNeighbors{neighborId,:}],5) >0)
        %             leftFaceNeighbors(faceId) =  [leftFaceNeighbors{2,:}]
        %         end

        % To illustrate faces that have overlap with DWI and fMRI, we add a 6th
        % column of ones where there is overlap.
        leftFacesWithOverlap = intersect(find(~allBrainData.leftHemisphere.surf.faces(:,4) == 0),find(~allBrainData.leftHemisphere.surf.faces(:,5) == 0));
        allBrainData.leftHemisphere.surf.faces(leftFacesWithOverlap,6) = 1;

        rightFacesWithOverlap = intersect(find(~allBrainData.rightHemisphere.surf.faces(:,4) == 0),find(~allBrainData.rightHemisphere.surf.faces(:,5) == 0));
        allBrainData.rightHemisphere.surf.faces(rightFacesWithOverlap,6) = 1;

        %% VISUALISATIONS

        if (1 == 0)
            % Visualise the merged brain.
            figure;
            title("Whole brain");
            subtitle("Left and right hemisphere merged before any computation.");
            plotmesh(allBrainData.surf.nodes, allBrainData.surf.faces);
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/whole-brain'],'compact');


            figure;

            % fMRI activations
            title('fMRI modules determined by meshing all surfaces at once.');
            hold on;
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces,'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces,'FaceAlpha',0.1,'FaceColor',[0.2 0.2 0.2],'EdgeColor','none');
            plotsurf(allFunctionalData.surf.nodes,allFunctionalData.surf.faces);
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/fmri-modules-at-once'],'compact');



            % Visualise fMRI activations on the anatomical surface.
            figure;
            hold on;
            title('fMRI activations projected to nearest surface triangle.');
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,5)==0),[1:3,5]),'FaceAlpha',0.7,'FaceColor',[0.9 0.9 0.9],'EdgeAlpha',0.2,'EdgeColor',[0.5 0.5 0.5],'DisplayName','Left hemisphere');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,5)==0),[1:3,5]),'FaceAlpha',0.7,'FaceColor',[0.9 0.9 0.9],'EdgeAlpha',0.2,'EdgeColor',[0.5 0.5 0.5],'DisplayName','Right hemisphere');

            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,5)>0),[1:3,5]),'FaceAlpha',0.8,'EdgeAlpha',0.7,'FaceColor','interp','DisplayName','fMRI Activations/Modules');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,5)>0),[1:3,5]),'FaceAlpha',0.8,'EdgeAlpha',0.7,'FaceColor','interp','DisplayName','fMRI Activations/Modules');
            lightangle(100,0);
            lightangle(0,0);
            lightangle(100,100);
            view(0,90);
            legend;
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/fmri-modules-to-surface'],'compact');


            figure;
            title("Structural modules of the precentral gyrus");
            hold on;
            xlabel('Left-Right');
            ylabel('Anterior-Posterior');
            zlabel('Inferior-Superior');
            hold on;
            ax = gca;               % get the current axis
            ax.Clipping = 'off';    % turn clipping off
            camlight;
            lightangle(-45,30);
            lightangle(100,0);
            lightangle(0,0);
            lightangle(100,100);
            lighting gouraud;
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4) == 0),1:4),'DisplayName','Left hemisphere','EdgeColor','#575757','EdgeAlpha',0.2,'FaceColor','#d69696','Marker','o','MarkerSize',1);
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4) == 0),1:4),'DisplayName','Right hemisphere','EdgeColor','#575757','EdgeAlpha',0.2,'FaceColor','#d69696','Marker','o','MarkerSize',1);
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4) > 0),1:4),'DisplayName','Structural module','EdgeColor','#575757','EdgeAlpha',0.2,'Marker','o','MarkerSize',1,'FaceLighting','none');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4) > 0),1:4),'DisplayName','Structural module','EdgeColor','#575757','EdgeAlpha',0.2,'Marker','o','MarkerSize',1,'FaceLighting','none');
            legend;
            view(190,25);
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/structural-modules'],'compact');

            figure;
            title("Faces of overlap between function and structure");
            hold on;
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,6) == 0),[1:3,6]),'DisplayName','Left hemisphere');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,6) == 0),[1:3,6]),'DisplayName','Right hemisphere');
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,6) > 0),[1:3,6]),'DisplayName','fMRI + Structure','FaceColor','r');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,6) > 0),[1:3,6]),'DisplayName','fMRI + Structure','FaceColor','r');
            legend;
            view(190,25);
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/faces-of-overlap'],'compact');



            %% PLOTTING OF ADJACENCY MATRICES.
            figure;
            axis vis3d equal;
            title('Global network - connectivity matrix');
            subtitle('Square shows local connectivity (figure 2)');
            plottedLabels = labelIds;
            spy(allStructuralData.adjacencyMatrix);
            % Broken, doesnt work when both hemisphere are selected!
            %Left hemisphere ROI
            rectangle('Position',[min(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain) min(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.leftHemisphere.surf.faceIdsOfAllBrain)], 'EdgeColor','red')
            % Right hemisphere ROI
            rectangle('Position',[length(allBrainData.leftHemisphere.surf.faces) + min(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain) length(allBrainData.leftHemisphere.surf.faces) + min(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain) length(roiStructuralData.rightHemisphere.surf.faceIdsOfAllBrain)], 'EdgeColor','red')

            xticks(1:showTicksPer:length(plottedLabels));
            yticks(1:showTicksPer:length(plottedLabels));
            xticklabels(plottedLabels(1:showTicksPer:end));
            yticklabels(plottedLabels(1:showTicksPer:end));
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/global-matrix'],'compact');


            if(numel(roiStructuralData.leftHemisphere.adjacencyMatrix) > 0)
                figure;
                title('Local network (lSF-lSP) - connectivity matrix (left)')

                plottedLabels = roiStructuralData.leftHemisphere.labels.names;
                spy(roiStructuralData.leftHemisphere.adjacencyMatrix);

                xticks(1:(showTicksPer/50):length(plottedLabels));
                yticks(1:(showTicksPer/50):length(plottedLabels));
                xticklabels(plottedLabels(1:(showTicksPer/50):end));
                yticklabels(plottedLabels(1:(showTicksPer/50):end));
                savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/local-left-matrix'],'compact');
            end

            if(numel(roiStructuralData.rightHemisphere.adjacencyMatrix) > 0)
                figure;
                title('Local network (lSF-lSP) - connectivity matrix (right)')

                plottedLabels = roiStructuralData.rightHemisphere.labels.names;
                spy(roiStructuralData.rightHemisphere.adjacencyMatrix);

                xticks(1:(showTicksPer/50):length(plottedLabels));
                yticks(1:(showTicksPer/50):length(plottedLabels));
                xticklabels(plottedLabels(1:(showTicksPer/50):end));
                yticklabels(plottedLabels(1:(showTicksPer/50):end));
                savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/local-right-matrix'],'compact');

            end
            toc;
            disp("Saving...");
            % Remove data that we won't use again.
            allBrainData.surf = [];
            allBrainData.leftHemisphere.surfaceNorm = [];
            allBrainData.rightHemisphere.surfaceNorm = [];
            allBrainData.leftHemisphere.nodesToFaces = [];
            allBrainData.rightHemisphere.nodesToFaces = [];
            if(size(allFunctionalData.modules,2) == 0)
                disp("This subject had no fMRI activations!");
            end

        end

        %% IMPORTED FROM CALCULATEOVERLAP.M
        leftOverlappingFaces = find(allBrainData.leftHemisphere.surf.faces(:,6) == 1);
        leftOffset = max(allBrainData.leftHemisphere.surf.faces(:,5))+1;
        allBrainData.leftHemisphere.surf.faces(allBrainData.leftHemisphere.surf.faces(:,5)>0,5) = allBrainData.leftHemisphere.surf.faces(allBrainData.leftHemisphere.surf.faces(:,5)>0,5) + leftOffset;
        allBrainData.leftHemisphere.surf.faces(:,7) = allBrainData.leftHemisphere.surf.faces(:,4) + allBrainData.leftHemisphere.surf.faces(:,5);

        Lmodules =allBrainData.leftHemisphere.surf.faces(:,4);
        uniqueLModules = unique(Lmodules);
        for moduleIndex=1:length(uniqueLModules)
            %% For each module, get its outline.
            moduleName=uniqueLModules(moduleIndex);
            % Edges are defined by two indexes - the two nodes they connect.
            leftStrucModuleFacesIndexes{moduleIndex} = find(allBrainData.leftHemisphere.surf.faces(:,4) == moduleName);
            leftStrucModuleFacesBiggerThan1Indexes{moduleIndex} = length(find(allBrainData.leftHemisphere.surf.faces(:,4) == moduleName)) > 1;
            leftStrucModuleNodeIndexesTemp = allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},1:3);
            leftStrucModuleNodeIndexes = unique(leftStrucModuleNodeIndexesTemp(:));
            allBrainData.leftHemisphere.surf.nodes(leftStrucModuleNodeIndexes,4) = moduleIndex;
            [strucEdges{moduleIndex},~]=surfedge(allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},1:3));
        end

        leftFuncModuleIndexes = transpose(unique(allBrainData.leftHemisphere.surf.faces(leftOverlappingFaces,5)));
        %funcModuleIndexes = transpose(unique(allBrainData.leftHemisphere.surf.faces(allBrainData.leftHemisphere.surf.faces(:,5)>0,5)));


        for funcModuleIndex=1:length(leftFuncModuleIndexes)
            moduleName=leftFuncModuleIndexes(funcModuleIndex);
            leftFuncModuleFacesIndexes{funcModuleIndex} = intersect(leftOverlappingFaces,find(allBrainData.leftHemisphere.surf.faces(:,5) == funcModuleIndex));

            leftGlobalFuncModuleFacesIndexes{funcModuleIndex}= find(allBrainData.leftHemisphere.surf.faces(:,5) == funcModuleIndex);

            leftFuncModuleNodeIndexesTemp = allBrainData.leftHemisphere.surf.faces(leftFuncModuleFacesIndexes{funcModuleIndex},1:3);
            leftFuncModuleNodeIndexes{funcModuleIndex} = unique(leftFuncModuleNodeIndexesTemp(:));
            if(~isempty(allBrainData.leftHemisphere.surf.faces(leftFuncModuleFacesIndexes{funcModuleIndex},1:3)))
                [leftFuncEdges{funcModuleIndex},~]=surfedge(allBrainData.leftHemisphere.surf.faces(leftFuncModuleFacesIndexes{funcModuleIndex},1:3));
            else
                leftFuncEdges{funcModuleIndex} = nan;
            end
        end

        rightOverlappingFaces = find(allBrainData.rightHemisphere.surf.faces(:,6) == 1);
        rightOffset = max(allBrainData.rightHemisphere.surf.faces(:,5))+1;
        allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5) = allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5) + rightOffset;
        allBrainData.rightHemisphere.surf.faces(:,7) = allBrainData.rightHemisphere.surf.faces(:,4) + allBrainData.rightHemisphere.surf.faces(:,5);

        %globalFunctionalModules = transpose(unique(allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5)));

        rightFuncModuleIndexes = unique(allBrainData.rightHemisphere.surf.faces(rightOverlappingFaces,5));

        for moduleIndex=1:length(rightFuncModuleIndexes)
            moduleName=rightFuncModuleIndexes(moduleIndex);
            %% For each module, get its outline.
            % Edges are defined by two indexes - the two nodes they connect.
            rightStrucModuleFacesIndexes{moduleIndex} = find(allBrainData.rightHemisphere.surf.faces(:,4) == moduleName);
            rightStrucModuleFacesBiggerThan1Indexes{moduleIndex} = length(find(allBrainData.rightHemisphere.surf.faces(:,4) == moduleName)) > 1;
            rightStrucModuleNodeIndexesTemp = allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3);
            rightStrucModuleNodeIndexes = unique(rightStrucModuleNodeIndexesTemp(:));
            rightStrucModuleAreaMm{moduleIndex} = sum(elemvolume(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3)));
            allBrainData.rightHemisphere.surf.nodes(rightStrucModuleNodeIndexes,4) = moduleIndex;
            if(~isempty(allBrainData.leftHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3)))
                [strucEdges{moduleIndex},~]=surfedge(allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3));
            end
        end

        rightFuncModuleIndexes = transpose(unique(allBrainData.rightHemisphere.surf.faces(rightOverlappingFaces,5)));
        %funcModuleIndexes = transpose(unique(allBrainData.rightHemisphere.surf.faces(allBrainData.rightHemisphere.surf.faces(:,5)>0,5)));

        for funcModuleIndex=1:length(rightFuncModuleIndexes)
            moduleName=rightFuncModuleIndexes(funcModuleIndex);
            rightFuncModuleFacesIndexes{funcModuleIndex} = intersect(rightOverlappingFaces,find(allBrainData.rightHemisphere.surf.faces(:,5) == moduleName));
            rightFuncModuleAreaMm{funcModuleIndex} = sum(elemvolume(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},1:3)));

            rightGlobalFuncModuleFacesIndexes{funcModuleIndex}= find(allBrainData.rightHemisphere.surf.faces(:,5) == moduleName);
            rightGlobalFuncModuleAreaMm{funcModuleIndex} = sum(elemvolume(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},1:3)));

            rightFuncModuleNodeIndexesTemp = allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},1:3);
            rightFuncModuleNodeIndexes{funcModuleIndex} = unique(rightFuncModuleNodeIndexesTemp(:));
            [rightFuncEdges{funcModuleIndex},~]=surfedge(allBrainData.rightHemisphere.surf.faces(rightFuncModuleFacesIndexes{funcModuleIndex},(1:3)));
        end


        %% More plots
        if (1 == 0)
            figure;
            xlabel('Left-Right');
            ylabel('Anterior-Posterior');
            zlabel('Inferior-Superior');
            hold on;
            ax = gca;               % get the current axis
            ax.Clipping = 'off';    % turn clipping off
            title("Left motor homonculus parcellated into triangular nodes");
            %plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(:,1:3),'DisplayName','Left hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
            plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(find(allBrainData.leftHemisphere.surf.faces(:,4) > 0),1:3),'DisplayName','Left hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
            leftColormap_hsv = hsv(double(maxLeftStructuralModule));
            for moduleIndex=1:maxLeftStructuralModule
                color = leftColormap_hsv(moduleIndex,:);
                plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},1:3),'DisplayName',['Structural Module: #' num2str(moduleIndex)],'EdgeAlpha',0.3,'FaceColor',[color]);
                %plotedges(allBrainData.leftHemisphere.surf.nodes(:,1:3), strucEdges{moduleIndex},'linewidth',randi(5,1),'Color',[color 0.9],'linestyle','-','DisplayName',['Structural Module: #' num2str(moduleIndex)]);
            end

            leftColormap_jet = jet(length(rightFuncModuleIndexes));
            count = 0;
            for funcModuleIndex=1:length(rightFuncModuleIndexes)
                moduleName=rightFuncModuleIndexes(funcModuleIndex)
                count = count+1;
                color = leftColormap_jet(count,:);
                %plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surf.faces(intersect(leftOverlappingFaces,funcModuleFacesIndexes{funcModuleIndex}),1:3),'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'EdgeAlpha',0.3,'FaceColor',colormap_jet(funcModuleIndex,:));
                plotedges(allBrainData.leftHemisphere.surf.nodes(:,1:3), leftFuncEdges{funcModuleIndex},'linewidth',3,'Color',[color],'linestyle','-','DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3,'AlignVertexCenters','on','HandleVisibility','off');
                plot(NaN,NaN,'linewidth',5,'Color',[color],'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3)
            end

            camlight;
            lighting gouraud;
            legend;
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/left-precentral-gyrus-struc-and-func'],'compact');


            figure;
            xlabel('Left-Right');
            ylabel('Anterior-Posterior');
            zlabel('Inferior-Superior');
            hold on;
            ax = gca;               % get the current axis
            ax.Clipping = 'off';    % turn clipping off
            title("Right motor homonculus parcellated into triangular nodes");
            %plotsurf(allBrainData.leftHemisphere.surf.nodes,allBrainData.leftHemisphere.surf.faces(:,1:3),'DisplayName','Left hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
            plotsurf(allBrainData.rightHemisphere.surf.nodes,allBrainData.rightHemisphere.surf.faces(find(allBrainData.rightHemisphere.surf.faces(:,4) > 0),1:3),'DisplayName','Right hemisphere','FaceAlpha',0.5,'EdgeColor','black','EdgeAlpha',0.05,'FaceColor','white');
            rightColormap_hsv = hsv(length(rightFuncModuleIndexes));
            for moduleIndex=1:length(rightFuncModuleIndexes)
                moduleName=rightFuncModuleIndexes(moduleIndex);
                color = rightColormap_hsv(moduleIndex,:);
                plotsurf(allBrainData.rightHemisphere.surf.nodes(:,1:3),allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},1:3),'DisplayName',['Structural Module: #' num2str(moduleIndex)],'EdgeAlpha',0.3,'FaceColor',[color]);
            end

            rightColormap_jet = jet(length(rightFuncModuleIndexes));
            count = 0;
            for funcModuleIndex=1:length(rightFuncModuleIndexes)
                moduleName=rightFuncModuleIndexes(funcModuleIndex)
                count = count+1;
                color = rightColormap_jet(count,:);
                %plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),allBrainData.leftHemisphere.surf.faces(intersect(leftOverlappingFaces,funcModuleFacesIndexes{funcModuleIndex}),1:3),'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'EdgeAlpha',0.3,'FaceColor',colormap_jet(funcModuleIndex,:));
                plotedges(allBrainData.rightHemisphere.surf.nodes(:,1:3), rightFuncEdges{funcModuleIndex},'linewidth',3,'Color',[color],'linestyle','-','DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3,'AlignVertexCenters','on','HandleVisibility','off');
                plot(NaN,NaN,'linewidth',5,'Color',[color],'DisplayName',['Functional Module: #' num2str(funcModuleIndex)],'Marker','o','MarkerSize',3)
            end
            camlight;
            lighting gouraud;
            legend;
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/right-precentral-gyrus-struc-and-func'],'compact');



            figure;
            hold on;
            title("Independent view of each structural module from left hemisphere");
            modulesWith1OrMoreFaces = cat(2,leftStrucModuleFacesBiggerThan1Indexes{:});
            tiledlayout(ceil(sum(modulesWith1OrMoreFaces)/3),3,'TileSpacing','None','Padding','None');

            for moduleIndex=1:length(rightFuncModuleIndexes)
                moduleName=rightFuncModuleIndexes(moduleIndex);
                if(modulesWith1OrMoreFaces(moduleIndex) == 1);
                    ax = nexttile;               % get the current axis
                    hold on;
                    ax.Clipping = 'off';    % turn clipping offcamlight;
                    light(ax,'Position',[0 0 0]);
                    light(ax,'Position',[200 200 200]);
                    light(ax,'Position',[-100 70 0]);
                    lighting(ax, 'gouraud');
                    plotsurf(allBrainData.leftHemisphere.surf.nodes(:,1:3),...
                        allBrainData.leftHemisphere.surf.faces(leftStrucModuleFacesIndexes{moduleIndex},(1:3)),'DisplayName',['Structural Module: ' moduleIndex],'EdgeAlpha',0.3,'FaceColor',leftColormap_hsv(moduleIndex,:));
                end
            end
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/isolated-struc-modules-left'],'compact');


            figure;
            hold on;
            title("Independent view of each structural module from right hemisphere");
            rightModulesWith1OrMoreFaces = cat(2,rightStrucModuleFacesBiggerThan1Indexes{:});
            tiledlayout(ceil(sum(rightModulesWith1OrMoreFaces)/3),3,'TileSpacing','None','Padding','None');

            for moduleIndex=1:maxRightStructuralModule
                if(rightModulesWith1OrMoreFaces(moduleIndex) == 1);
                    ax = nexttile;               % get the current axis
                    hold on;
                    ax.Clipping = 'off';    % turn clipping offcamlight;
                    light(ax,'Position',[0 0 0]);
                    light(ax,'Position',[200 200 200]);
                    light(ax,'Position',[-100 70 0]);
                    lighting(ax, 'gouraud');
                    plotsurf(allBrainData.rightHemisphere.surf.nodes(:,1:3),...
                        allBrainData.rightHemisphere.surf.faces(rightStrucModuleFacesIndexes{moduleIndex},(1:3)),'DisplayName',['Structural Module: ' moduleIndex],'EdgeAlpha',0.3,'FaceColor',rightColormap_hsv(moduleIndex,:));
                end
            end
            savefig(gcf,[pathToSubjectDir '/moduleResults/figures/' conditionName '/isolated-struc-modules-right'],'compact');

        end



        if(~visualiseData==1)
            close all;
        end

        filename=[pathToSubjectDir,'/moduleResults/allBrainData__',conditionName '.mat'];
        %save(filename,'allBrainData','-v7.3'); %Adding 7.3 makes filesize
        %larger than necessary.
        save(filename,'allBrainData');
        disp("Script finished successfully.");
    catch ME
        disp("Script failed.")
        rethrow(ME);
    end
end
end